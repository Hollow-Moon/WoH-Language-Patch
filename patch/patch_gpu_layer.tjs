

global.TVP_RGB2COLOR = function(r, g, b)
{
    return ((((r)<<16) + ((g)<<8) + (b)) | 0xff000000);
};

global.TVP_RGBA2COLOR = function(r, g, b, a)
{
    return (((a)<<24) + (((r)<<16) + ((g)<<8) + (b)));
};

class WindowShimBitmapLayerTreeOwner extends BitmapLayerTreeOwner
{
	var window = void;
	var texture = void;
	var call_on_paint_list = [];
	function WindowShimBitmapLayerTreeOwner(window)
	{
		this.window = window;
		super.BitmapLayerTreeOwner();
	}

	function get_texture()
	{
		var primaryLayer = this.primaryLayer;
		if (typeof(primaryLayer) === "Object" && primaryLayer !== null)
		{
			var call_on_paint_list_tmp = [];
			call_on_paint_list_tmp.assign(this.call_on_paint_list);
			this.call_on_paint_list.clear();
			for (var i = 0; i < call_on_paint_list_tmp.count; i += 1)
			{
				var item = call_on_paint_list_tmp[i];
				if (isvalid(item))
				{
					item.onPaint_call_recursive();
				}
			}
		}
		else
		{
			Debug.message("no primary layer");
			return;
		}
		if (texture === void)
		{
			texture = new Offscreen(this.width, this.height);
			texture.copyRect(0, 0, this.bitmap, 0, 0, this.width, this.height);
			this.clearDirtyRect();
		}
		else
		{
			if (texture.width != this.width || texture.height != this.height)
			{
				invalidate texture;
				texture = new Offscreen(this.width, this.height);
				texture.copyRect(0, 0, this.bitmap, 0, 0, this.width, this.height);
				this.clearDirtyRect();
			}
			else
			{
				if (this.isUpdated)
				{
					texture.copyRect(0, 0, this.bitmap, 0, 0, this.width, this.height);
					//var rect = this.dirtyRect;
					//texture.copyRect(rect.left, rect.top, this.bitmap, rect);
					//this.clearDirtyRect();
				}
			}
		}
		return texture;
	}

	function draw()
	{
		var canvas = this.window.canvas;
		//canvas.clearColor = 0xff000000;
		canvas.matrix.reset();
		canvas.renderTarget = void;
		if (typeof(canvas.clipRect) !== "Object")
		{
			canvas.clipRect = new Rect(0, 0, canvas.width, canvas.height);
		}
		canvas.enableClipRect = false;
		canvas.fill(canvas.width, canvas.height, 0x00FFFFFF);
		canvas.clearColor = 0x00000000;
		canvas.clear();
		canvas.blendMode = bmOpaque;
		canvas.a_opacity = 1.0;

		canvas.save();
		var primaryLayer = this.primaryLayer;
		var texture = this.get_texture();
		if (texture !== void)
		{
@if(0)
			canvas.drawTexture(texture);
@endif
			if (typeof(primaryLayer) === "Object" && primaryLayer !== null)
			{
				primaryLayer.Draw();
			}
		}
		canvas.restore();
		//canvas.fill(300, 300, 0xff000000);
		canvas.flush();
	}

	// Avoid calling fire when already in firing
	var in_fire = false;

	// Default arguments are added because BitmapLayerTreeOwner native does not check argument count
	// which can cause segfault

	function fireClick(x=0, y=0)
	{
		var ret = void;
		if (this.in_fire)
		{
			return;
		}
		this.in_fire = true;
		try
		{
			ret = super.fireClick(x, y);
		}
		catch(e)
		{
			this.in_fire = false;
			throw e;
		}
		this.in_fire = false;
		return ret;
	}

	function fireDoubleClick(x=0, y=0)
	{
		var ret = void;
		if (this.in_fire)
		{
			return;
		}
		this.in_fire = true;
		try
		{
			ret = super.fireDoubleClick(x, y);
		}
		catch(e)
		{
			this.in_fire = false;
			throw e;
		}
		this.in_fire = false;
		return ret;
	}

	function fireMouseDown(x=0, y=0, button=0, shift=0)
	{
		var ret = void;
		if (this.in_fire)
		{
			return;
		}
		this.in_fire = true;
		try
		{
			ret = super.fireMouseDown(x, y, button, shift);
		}
		catch(e)
		{
			this.in_fire = false;
			throw e;
		}
		this.in_fire = false;
		return ret;
	}

	function fireMouseUp(x=0, y=0, button=0, shift=0)
	{
		var ret = void;
		if (this.in_fire)
		{
			return;
		}
		this.in_fire = true;
		try
		{
			ret = super.fireMouseUp(x, y, button, shift);
		}
		catch(e)
		{
			this.in_fire = false;
			throw e;
		}
		this.in_fire = false;
		return ret;
	}

	function fireMouseMove(x=0, y=0, shift=0)
	{
		var ret = void;
		if (this.in_fire)
		{
			return;
		}
		this.in_fire = true;
		try
		{
			ret = super.fireMouseMove(x, y, shift);
		}
		catch(e)
		{
			this.in_fire = false;
			throw e;
		}
		this.in_fire = false;
		return ret;
	}

	function fireMouseWheel(shift=0, delta=0, x=0, y=0)
	{
		var ret = void;
		if (this.in_fire)
		{
			return;
		}
		this.in_fire = true;
		try
		{
			ret = super.fireMouseWheel(shift, delta, x, y);
		}
		catch(e)
		{
			this.in_fire = false;
			throw e;
		}
		this.in_fire = false;
		return ret;
	}

	function fireMouseOutOfWindow()
	{
		var ret = void;
		if (this.in_fire)
		{
			return;
		}
		this.in_fire = true;
		try
		{
			ret = super.fireMouseOutOfWindow();
		}
		catch(e)
		{
			this.in_fire = false;
			throw e;
		}
		this.in_fire = false;
		return ret;
	}

	function fireKeyDown(key=0, shift=0)
	{
		var ret = void;
		if (this.in_fire)
		{
			return;
		}
		this.in_fire = true;
		try
		{
			ret = super.fireKeyDown(key, shift);
		}
		catch(e)
		{
			this.in_fire = false;
			throw e;
		}
		this.in_fire = false;
		return ret;
	}

	function fireKeyPress(key=0)
	{
		var ret = void;
		if (this.in_fire)
		{
			return;
		}
		this.in_fire = true;
		try
		{
			ret = super.fireKeyPress(key);
		}
		catch(e)
		{
			this.in_fire = false;
			throw e;
		}
		this.in_fire = false;
		return ret;
	}

	function fireKeyUp(key=0, shift=0)
	{
		var ret = void;
		if (this.in_fire)
		{
			return;
		}
		this.in_fire = true;
		try
		{
			ret = super.fireKeyUp(key, shift);
		}
		catch(e)
		{
			this.in_fire = false;
			throw e;
		}
		this.in_fire = false;
		return ret;
	}

	var last_cursor_x = 0;
	var last_cursor_y = 0;
	function onGetCursorPos(x, y)
	{
		// Bad API design. You can't write to pointer / pass by reference in TJS.
	}

	function onSetCursorPos(x, y)
	{
		this.last_cursor_x = x;
		this.last_cursor_y = y;
	}

	function onChangeLayerImage()
	{
		// stub
	}

	function onDisableAttentionPoint()
	{
		// stub
	}

	function onReleaseMouseCapture()
	{
		// stub
	}

	function onResetImeMode()
	{
		// stub
	}

	function onResizeLayer(w, h)
	{
		this.window.setSize(w, h);
	}

	function onSetAttentionPoint(layer, x, y)
	{
		// stub
	}

	function onSetHintText(sender, hint)
	{
		// stub
	}

	function onSetImeMode(mode)
	{
		// stub
	}

	function onSetMouseCursor(cursor)
	{
		// stub
	}
}

global.Window_patch_gpu_layer_original = Window;
class Window_patch_gpu_layer_override extends Window_patch_gpu_layer_original
{
	var bitmap_layer_tree_owner = void;
	function Window_patch_gpu_layer_override()
	{
		{
			bitmap_layer_tree_owner = new WindowShimBitmapLayerTreeOwner(this);
		}
		super.Window(...);
	}

	property primaryLayer
	{
		getter
		{
			if (typeof(this.canvas) === "Object" && this.canvas !== null && typeof(this.bitmap_layer_tree_owner) === "Object")
			{
				return this.bitmap_layer_tree_owner.primaryLayer;
			}
			return super.primaryLayer;
		}
	}

	property focusedLayer
	{
		getter
		{
			if (typeof(this.canvas) === "Object" && this.canvas !== null && typeof(this.bitmap_layer_tree_owner) === "Object")
			{
				return this.bitmap_layer_tree_owner.focusedLayer;
			}
			return super.focusedLayer;
		}
		setter(v)
		{
			if (typeof(this.canvas) === "Object" && this.canvas !== null && typeof(this.bitmap_layer_tree_owner) === "Object")
			{
				this.bitmap_layer_tree_owner.focusedLayer = v;
				return;
			}
			super.focusedLayer = v;
		}
	}

	function Window()
	{
		Window_patch_gpu_layer_override(...);
	}

	function onDraw()
	{
		if (typeof(this.canvas) === "Object" && this.canvas !== null && typeof(this.bitmap_layer_tree_owner) === "Object")
		{
			this.bitmap_layer_tree_owner.draw();
		}
@if(0)
		return super.onDraw(...);
@endif
	}

	function onMouseDown(x, y, button, shift)
	{
		if (typeof(this.canvas) === "Object" && this.canvas !== null && typeof(this.bitmap_layer_tree_owner) === "Object")
		{
			bitmap_layer_tree_owner.fireMouseDown(x, y, button, shift);
		}
		return super.onMouseDown(...);
	}

	function onMouseUp(x, y, button, shift)
	{
		if (typeof(this.canvas) === "Object" && this.canvas !== null && typeof(this.bitmap_layer_tree_owner) === "Object")
		{
			bitmap_layer_tree_owner.fireClick(x, y);
			bitmap_layer_tree_owner.fireMouseUp(x, y, button, shift);
		}
		return super.onMouseUp(...);
	}

	function onMouseMove(x, y, shift)
	{
		if (typeof(this.canvas) === "Object" && this.canvas !== null && typeof(this.bitmap_layer_tree_owner) === "Object")
		{
			bitmap_layer_tree_owner.fireMouseMove(x, y, shift);
		}
		return super.onMouseMove(...);
	}

	function onMouseWheel(shift, delta, x, y)
	{
		if (typeof(this.canvas) === "Object" && this.canvas !== null && typeof(this.bitmap_layer_tree_owner) === "Object")
		{
			bitmap_layer_tree_owner.fireMouseWheel(shift, delta, x, y);
		}
		return super.onMouseWheel(...);
	}

	function onMouseLeave()
	{
		if (typeof(this.canvas) === "Object" && this.canvas !== null && typeof(this.bitmap_layer_tree_owner) === "Object")
		{
			bitmap_layer_tree_owner.fireMouseOutOfWindow();
		}
		return super.onMouseLeave(...);
	}

	function onKeyDown(key, shift)
	{
		if (typeof(this.canvas) === "Object" && this.canvas !== null && typeof(this.bitmap_layer_tree_owner) === "Object")
		{
			bitmap_layer_tree_owner.fireKeyDown(key, shift);
		}
		return super.onKeyDown(...);
	}

	function onKeyPress(key)
	{
		if (typeof(this.canvas) === "Object" && this.canvas !== null && typeof(this.bitmap_layer_tree_owner) === "Object")
		{
			bitmap_layer_tree_owner.fireKeyPress(key);
		}
		return super.onKeyPress(...);	
	}

	function onKeyUp(key, shift)
	{
		if (typeof(this.canvas) === "Object" && this.canvas !== null && typeof(this.bitmap_layer_tree_owner) === "Object")
		{
			bitmap_layer_tree_owner.fireKeyUp(key, shift);
		}
		return super.onKeyUp(...);
	}
}
global.Window = Window_patch_gpu_layer_override;

global.Layer_patch_gpu_layer_original = Layer;
class Layer_patch_gpu_layer_override extends Layer_patch_gpu_layer_original
{
	var orig_window = void;
	property window
	{
		getter
		{
			return this.orig_window;
		}
	}

	function Layer_patch_gpu_layer_override(window, parent)
	{
		this.orig_window = window;
		if (typeof(window.bitmap_layer_tree_owner) === "Object" && window.bitmap_layer_tree_owner !== null)
		{
			super.Layer(window.bitmap_layer_tree_owner, parent);
		}
		else
		{
			super.Layer(window, parent);
		}	
	}

	function Layer()
	{
		Layer_patch_gpu_layer_override(...);
	}

@if(0)
	function GetTypeNameString()
	{
		switch(this.type)
		{
			case ltBinder:			return "ltBinder";
			case ltOpaque:			return "ltOpaque";
			case ltAlpha:			return "ltAlpha";
			case ltAdditive:		return "ltAdditive";
			case ltSubtractive:		return "ltSubtractive";
			case ltMultiplicative:	return "ltMultiplicative";
			case ltDodge:			return "ltDodge";
			case ltDarken:			return "ltDarken";
			case ltLighten:			return "ltLighten";
			case ltScreen:			return "ltScreen";
			case ltAddAlpha:		return "ltAddAlpha";
			case ltPsNormal:		return "PsNormal";
			case ltPsAdditive:		return "PsAdditive";
			case ltPsSubtractive:	return "PsSubtractive";
			case ltPsMultiplicative:return "PsMultiplicative";
			case ltPsScreen:		return "PsScreen";
			case ltPsOverlay:		return "PsOverlay";
			case ltPsHardLight:		return "PsHardLight";
			case ltPsSoftLight:		return "PsSoftLight";
			case ltPsColorDodge:	return "PsColorDodge";
			case ltPsColorDodge5:	return "PsColorDodge5";
			case ltPsColorBurn:		return "PsColorBurn";
			case ltPsLighten:		return "PsLighten";
			case ltPsDarken:		return "PsDarken";
			case ltPsDifference:	return "PsDifference";
			case ltPsDifference5:	return "PsDifference5";
			case ltPsExclusion:		return "PsExclusion";

			default:				return "unknown";
		}
	}

	function DumpStructure(level = 0)
	{
		var indent = "";
		for (var i = 0; i < level; i += 1)
		{
			indent += "  ";
		}
		var name = this.name;
		if (name == "")
		{
			name = "<noname>";
		}

		var ptr = " " + this;
		var ptr2 = " (native NOTIMPL)";

		Debug.message(indent + name +
			ptr + ptr2 +
			"( " + this.left + "," +
			this.top + ")-(" + this.right +
			"," + this.bottom + ") (" +
			this.width + "x" + this.height +
			")" + " " +
			(this.visible ? "visible" : "invisible") +
			" index=" + this.absolute +
			(this.provinceImageBuffer ? " p" : "") +
			" " + this.GetTypeNameString()
			);
		level += 1;
		for (var i = 0, internal_forloop_count = this.children.count; i < internal_forloop_count; i += 1)
		{
			this.children[i].DumpStructure(level);
		}
	}

	function dump_reimpl()
	{
		this.DumpStructure(0);
	}


	property type
	{
		getter
		{
			return this.typeOriginal;
		}
		setter(v)
		{
			if (this.typeOriginal != v)
			{
				switch (this.typeOriginal)
				{
					case ltOpaque:
					case ltAlpha:
					case ltAdditive:
					case ltSubtractive:
					case ltMultiplicative:
					case ltDodge:
					case ltDarken:
					case ltLighten:
					case ltScreen:
					case ltAddAlpha:
					case ltPsNormal:
					case ltPsAdditive:
					case ltPsSubtractive:
					case ltPsMultiplicative:
					case ltPsScreen:
					case ltPsOverlay:
					case ltPsHardLight:
					case ltPsSoftLight:
					case ltPsColorDodge:
					case ltPsColorDodge5:
					case ltPsColorBurn:
					case ltPsLighten:
					case ltPsDarken:
					case ltPsDifference:
					case ltPsDifference5:
					case ltPsExclusion:
						this.setInitialImageProperties();
						break;
					default:
						break;
				}
				switch (this.typeOriginal)
				{
					case ltBinder:
					case ltOpaque:
					case ltAlpha:
					case ltSubtractive:
					case ltMultiplicative:
					case ltDarken:
					case ltPsSubtractive:
					case ltPsMultiplicative:
					case ltPsColorBurn:
					case ltPsDarken:
						this._neutralColor = this._transparentColor = TVP_RGBA2COLOR(255, 255, 255, 0);
						break;
					case ltAdditive:
					case ltDodge:
					case ltLighten:
					case ltScreen:
					case ltAddAlpha:
					case ltPsNormal:
					case ltPsAdditive:
					case ltPsScreen:
					case ltPsColorDodge:
					case ltPsColorDodge5:
					case ltPsLighten:
					case ltPsDifference:
					case ltPsDifference5:
					case ltPsExclusion:
						this._neutralColor = this._transparentColor = TVP_RGBA2COLOR(0, 0, 0, 0);
						break;
					case ltPsOverlay:
					case ltPsHardLight:
					case ltPsSoftLight:
						this._neutralColor = this._transparentColor = TVP_RGBA2COLOR(128, 128, 128, 0);
						break;
					default:
						break;
				}
				switch (this.typeOriginal)
				{
					case ltBinder:
						this._canHaveImage = false;
						break;
					case ltOpaque:
					case ltAlpha:
					case ltAdditive:
					case ltSubtractive:
					case ltMultiplicative:
					case ltDodge:
					case ltDarken:
					case ltLighten:
					case ltScreen:
					case ltAddAlpha:
					case ltPsNormal:
					case ltPsAdditive:
					case ltPsSubtractive:
					case ltPsMultiplicative:
					case ltPsScreen:
					case ltPsOverlay:
					case ltPsHardLight:
					case ltPsSoftLight:
					case ltPsColorDodge:
					case ltPsColorDodge5:
					case ltPsColorBurn:
					case ltPsLighten:
					case ltPsDarken:
					case ltPsDifference:
					case ltPsDifference5:
					case ltPsExclusion:
						this._canHaveImage = true;
						break;
					default:
						break;
				}
			}
			this.typeOriginal = v;
		}
	}

@endif

	var texture = void;
	function get_texture()
	{
		var bitmap = new Bitmap();
		this.copyToBitmapFromMainImage(bitmap);
		if (this.texture === void)
		{
			this.texture = new Offscreen(super.imageWidth, super.imageHeight);
			this.texture.copyRect(0, 0, bitmap, 0, 0, super.imageWidth, super.imageHeight);
		}
		else
		{
			if (this.texture.width != super.imageWidth || this.texture.height != super.imageHeight)
			{
				invalidate this.texture;
				this.texture = new Offscreen(super.imageWidth, super.imageHeight);
				this.texture.copyRect(0, 0, bitmap, 0, 0, super.imageWidth, super.imageHeight);
			}
			else
			{
				this.texture.copyRect(0, 0, bitmap, 0, 0, super.imageWidth, super.imageHeight);
			}
		}
		invalidate bitmap;
		return this.texture;
	}

	var _inCompletion = false;
	function BeforeCompletion()
	{
		if (this._inCompletion)
		{
			return;
		}

@if(0)
		if (this.callOnPaint)
		{
			this.callOnPaint = false;
			if (typeof(this.onPaint) === "Object")
			{
				this.onPaint();
			}
		}
@endif

		// TODO: transition handling

		for (var i = 0, internal_forloop_count = this.children.count; i < internal_forloop_count; i += 1)
		{
			this.children[i].BeforeCompletion();
		}
	}

	function AfterCompletion()
	{
		if (this._inCompletion)
		{
			return;
		}

		// TODO: transition handling

		for (var i = 0, internal_forloop_count = this.children.count; i < internal_forloop_count; i += 1)
		{
			this.children[i].AfterCompletion();
		}
	}

	function Draw()
	{
		if (!this.visible)
		{
			return;
		}
		var canvas = this.window.canvas;
		canvas.matrix.translate(super.left, super.top);
@if(0)
		var current_cliprect = new Rect(super.clipLeft, super.clipTop, super.clipLeft + super.clipWidth, super.clipTop + super.clipHeight);
		canvas.enableClipRect = true;
		var clipRect = canvas.clipRect;
		clipRect.clip(current_cliprect);
@endif

		// draw self
		canvas.matrix.translate(super.imageLeft, super.imageTop);
		if (super.hasImage && super.opacity !== 0)
		{
			var texture = this.get_texture();
			switch (super.type)
			{
				case ltAlpha:
				{
					canvas.blendMode = bmAlpha;
					break;
				}
				case ltAddAlpha:
				{
					canvas.blendMode = bmAddWithAlpha;
					break;
				}
				case ltAdditive:
				{
					canvas.blendMode = bmAdd;
					break;
				}
				case ltCoverRect:
				case ltOpaque:
				{
					canvas.blendMode = bmOpaque;
					break;
				}
				default:
				{
					// TODO: fix alpha
					canvas.blendMode = bmAlpha;
					break;
				}
			}

			
			if (texture !== void)
			{
				canvas.a_opacity = 1 - (super.opacity / 255.0);
				canvas.drawTexture(texture);
				canvas.a_opacity = 1.0;
			}
		}
		canvas.matrix.translate(0 - super.imageLeft, 0 - super.imageTop);

		// draw children
		var children = this.children;
		for (var i = 0, internal_forloop_count = children.count; i < internal_forloop_count; i += 1)
		{
			children[i].Draw();
		}

		// TODO: send completion message
		canvas.matrix.translate(0 - super.left, 0 - super.top);
	}

	function piledCopy_to_canvas()
	{
@if(0)
		var any_visible = false;
		for (var i = 0, internal_forloop_count = src.children.count; i < internal_forloop_count; i += 1)
		{
			if (src.children[i].visible)
			{
				any_visible = true;
				break;
			}
		}
		if (any_visible == false && this.imageLeft == 0 && this.imageTop == 0 && this.width == src.width && this.height == src.height)
		{
			this.assignImages(src);
			return;
		}
@endif

		this.BeforeCompletion();
		// ...
		this._inCompletion = true;
		this.Draw();
		this._inCompletion = false;
		this.AfterCompletion();
	}

	function callOnPaint_updated(v)
	{
		var call_on_paint_list = window.bitmap_layer_tree_owner.call_on_paint_list;
		if (v)
		{
			if (call_on_paint_list.find(this) === -1)
			{
				call_on_paint_list.add(this);
			}
		}
		else
		{
			call_on_paint_list.remove(this);
		}
	}

	var _call_on_paint = false;
	property callOnPaint
	{
		getter
		{
			return this._call_on_paint;
		}
		setter(v)
		{
			this._call_on_paint = v;
			this.callOnPaint_updated(v);
		}
	}

	function onPaint_call_recursive()
	{
		if (this._call_on_paint)
		{
			this._call_on_paint = false;
			if (typeof(this.onPaint) === "Object")
			{
				this.onPaint();
			}
		}
		// draw children
		var children = this.children;
		for (var i = 0, internal_forloop_count = children.count; i < internal_forloop_count; i += 1)
		{
			children[i].onPaint_call_recursive();
		}
	}

	function update()
	{
		// Don't call update() here. This causes callOnPaint to be set and could cause a recursive call -> out of stack
@if(0)
		var ret = super.update(...);
@endif
		this._call_on_paint = true;
		this.callOnPaint_updated(true);
@if(0)
		return ret;
@endif
	}
}
global.Layer = Layer_patch_gpu_layer_override;
