
global.Layer_patch_drawtext_join_characters_original = global.Layer;
class Layer_patch_drawtext_join_characters_override extends global.Layer_patch_drawtext_join_characters_original
{
	function Layer_patch_drawtext_join_characters_override()
	{
		super.Layer(...);
	}

	function Layer()
	{
		this.Layer_patch_drawtext_join_characters_override(...);
	}

	function drawText(left, top, text, color, opacity, aa, slevel, scolor, swidth, sofsx, sofsy)
	{
		text += "";
		if ((text.length > 1) && (text.indexOf("―") !== -1 || text.indexOf("■") !== -1))
		{
			var x = 0;
			for (var i = 0, internal_forloop_count = text.length; i < internal_forloop_count; i += 1)
			{
				var character = text[i];
				var textwidth = this.font.getTextWidth(character);
				var textheight = this.font.getTextHeight(character);
				var found_same_characters = 1;
				if (("―■").indexOf(character) !== -1)
				{
					for (var j = i + 1, internal_forloop_count = text.length; j < internal_forloop_count; j += 1)
					{
						var character2 = text[j];
						if (character2 === character)
						{
							found_same_characters += 1;
						}
						else
						{
							break;
						}
					}
				}
				if (found_same_characters > 1)
				{
					// If font shadow is used, we need to leave additional room for them in our temp layer.
					var shadowPaddingL = global.Math.max(0, swidth-sofsx);
					var shadowPaddingR = global.Math.max(0, swidth+sofsx);
					var shadowPaddingT = global.Math.max(0, swidth-sofsy);
					var shadowPaddingB = global.Math.max(0, swidth+sofsy);

					var textWidthShadowSingle = shadowPaddingL + global.Math.ceil(textwidth) + shadowPaddingR;
					var textHeightShadow = shadowPaddingT + global.Math.ceil(textheight) + shadowPaddingB;

					var	tmp	= this.window.temporaryLayer_patch_drawtext_join_characters;
					tmp.setImageSize(textWidthShadowSingle, textHeightShadow);
					tmp.fillRect(0, 0, tmp.imageWidth, tmp.imageHeight, 0);

					tmp.font.assign_font_properties(this.font);
					tmp.drawText(shadowPaddingL, shadowPaddingT, character, color, opacity, aa, slevel, scolor, swidth, sofsx, sofsy);

					var frontPieceWidth = shadowPaddingL + global.Math.ceil(textwidth / 2);
					var endPieceWidth = textWidthShadowSingle - frontPieceWidth - 1;
					var textWidthShadowFull = shadowPaddingL + global.Math.ceil(textwidth * found_same_characters) + shadowPaddingR;

					// Use a second temporary layer to combine the parts, so we can overlap the front/end parts without glitches.
					var	tmp2 = this.window.temporaryLayer_patch_drawtext_join_characters2;
					tmp2.setImageSize(textWidthShadowFull, textHeightShadow);
					tmp2.fillRect(0, 0, tmp2.imageWidth, tmp2.imageHeight, 0);

					tmp2.stretchCopy(0, 0, textWidthShadowFull, textHeightShadow, tmp, frontPieceWidth, 0, 1, textHeightShadow);
					tmp2.copyRect(0, 0, tmp, 0, 0, frontPieceWidth, textHeightShadow);
					tmp2.copyRect(textWidthShadowFull - endPieceWidth, 0, tmp, frontPieceWidth + 1, 0, endPieceWidth, textHeightShadow);
					
					this.operateRect(global.Math.round(left+x-shadowPaddingL), top-shadowPaddingT, tmp2, 0, 0, tmp2.imageWidth, tmp2.imageHeight, global.omAuto, 255);

					i += found_same_characters - 1;
					textwidth *= found_same_characters;
				}
				else
				{
					super.drawText(left + x, top, character, color, opacity, aa, slevel, scolor, swidth, sofsx, sofsy);
				}
				x += textwidth;
			}
			return;
		}
		return super.drawText(...);
	}

}
global.Layer = global.Layer_patch_drawtext_join_characters_override;

global.Window_patch_drawtext_join_characters_original = global.Window;
class Window_patch_drawtext_join_characters_override extends global.Window_patch_drawtext_join_characters_original
{
	function Window_patch_drawtext_join_characters_override()
	{
		super.Window(...);
	}

	function Window()
	{
		this.Window_patch_drawtext_join_characters_override(...);
	}

	var tempLayer_patch_drawtext_join_characters = void;
	property temporaryLayer_patch_drawtext_join_characters
	{
		getter
		{
			if (this.tempLayer_patch_drawtext_join_characters === void)
			{
				this.tempLayer_patch_drawtext_join_characters = new global.Layer(this, this.primaryLayer);
				this.tempLayer_patch_drawtext_join_characters.name = "Temporary layer for joining text";
			}
			return this.tempLayer_patch_drawtext_join_characters;
		}
	}

	var tempLayer_patch_drawtext_join_characters2 = void;
	property temporaryLayer_patch_drawtext_join_characters2
	{
		getter
		{
			if (this.tempLayer_patch_drawtext_join_characters2 === void)
			{
				this.tempLayer_patch_drawtext_join_characters2 = new global.Layer(this, this.primaryLayer);
				this.tempLayer_patch_drawtext_join_characters2.name = "Temporary layer for joining text 2";
			}
			return this.tempLayer_patch_drawtext_join_characters2;
		}
	}
}
global.Window = global.Window_patch_drawtext_join_characters_override;

