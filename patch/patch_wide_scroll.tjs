@if(!WIDE_MODE)
global.kag.tagHandlers.initscroll = function(mp) {
	return 0;
};

global.kag.tagHandlers.dispscroll = function(mp) {
	return 0;
};
@endif

@if(WIDE_MODE)
global.kag.tagHandlers.initscroll = function(mp) {
	// Parameters: from, to, time
	mp.time = -1;
	return this.tagHandlers.dispscroll(mp);
} incontextof global.kag;

global.kag.tagHandlers.dispscroll = function(mp) {
	// Parameters: from, to, time
	this.originalscrollYOffset = void;
	var moveTime = (mp.time != 0)? mp.time : 600;

	// The meaning of "from" and "to" is somewhat counter-intuitive since they reference the distance between the bottom end of the image and the bottom end of the window.
	// So, the value is 0 when the bottom end of the image is touching the bottom end of the client area (e.g. completely scrolled down).
	// The value is 150 when the top end of the image is touching the top end of the client area (e.g. completely scolled up). 150 is the maximum scroll possible in 16:9.
	// This is because the actual offset is 200 (150*wideFactor) with vertically 600 px visible of a total of 800.
	//    @dispscroll from=150 time=5000 to=0
	// ...means to scroll from the very top of the image to the very bottom of the image within 5s.

	var yOffset = +mp.from;

	if (this.scrollYOffset == yOffset) {
		return 0;
	}

	// TODO time=-1 is a patch when being called from initscroll
	if ((!this.wideScreen && !global.isCropped) || mp.time == -1) {
		this.updateScrollPosition(,yOffset);
		return 0;
	}

	//var waitMoveTag = %["tagname" => "wm", "canskip" => 1];
	//conductor.pendings.insert(0, waitMoveTag);
	var moveTagParams = %["layer" => "primaryLayer", "time" => moveTime, "bg" => true, "textoff" => 1, "path" => "(0,"+("" + yOffset)+",255)"];
	return this.tagHandlers.move(moveTagParams);
} incontextof global.kag;

global.kag.updateScrollPosition = function(x, y) {
	this.scrollXOffset = x if x !== void;
	this.scrollYOffset = y if y !== void;

	if (!this.wideScreen && !global.isCropped) return;
	this.primaryLayer.updateTopScroll();
} incontextof global.kag;

global.kag.scrollDown = function() {
	this.originalscrollYOffset = this.scrollYOffset if this.originalscrollYOffset === void;
	this.updateScrollPosition(,global.Math.min(this.scrollYOffset+this.scrollYOffsetSpeed, this.scrollYOffsetMax));
} incontextof global.kag;

global.kag.scrollUp = function() {
	this.originalscrollYOffset = this.scrollYOffset if this.originalscrollYOffset === void;
	this.updateScrollPosition(,global.Math.max(this.scrollYOffset-this.scrollYOffsetSpeed, this.scrollYOffsetMin));
} incontextof global.kag;

global.kag.scrollReset = function() {
	if (this.originalscrollYOffset !== void) {
		this.updateScrollPosition(,this.originalscrollYOffset);
		this.originalscrollYOffset = void;
	}
} incontextof global.kag;


class LinearMoverBackground extends global.LinearMoverEx
{
	function LinearMoverBackground()
	{
		super.LinearMoverEx(...);
	}

	function updateData(a, b)
	{
		global.kag.updateScrollPosition(a, b);
	}
}
@endif
