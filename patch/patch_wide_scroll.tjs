@if(!WIDE_MODE)
global.kag.tagHandlers.initscroll = function(mp) {
	return 0;
};

global.kag.tagHandlers.dispscroll = function(mp) {
	return 0;
};
@endif

@if(WIDE_MODE)
global.kag.tagHandlers.initscroll = function(mp) {
	// Parameters: from, to, time
	mp.time = -1;
	return this.tagHandlers.dispscroll(mp);
} incontextof global.kag;

global.kag.tagHandlers.dispscroll = function(mp) {
	// Parameters: from, to, time
	this.originalscrollYOffset = void;
	var moveTime = (mp.time != 0)? mp.time : 600;

	// The "from" parameter represents the distance between the bottom end of the image and the bottom end of the window.
	// So, the value is 0 when the bottom end of the image is touching the bottom end of the client area (e.g. completely scrolled down).
	// The value is 150 when the top end of the image is touching the top end of the client area (e.g. completely scolled up).
	// The "to" parameter does nothing. The background always start scrolling from the position previously set to the value specified in "from".

	var yOffset = +mp.from;

	if (this.scrollYOffset == yOffset) {
		return 0;
	}

	// TODO time=-1 is a patch when being called from initscroll
	if ((!this.wideScreen && !global.isCropped) || mp.time == -1) {
		this.updateScrollPosition(,yOffset);
		return 0;
	}

	//var waitMoveTag = %["tagname" => "wm", "canskip" => 1];
	//conductor.pendings.insert(0, waitMoveTag);
	var moveTagParams = %["layer" => "primaryLayer", "time" => moveTime, "bg" => true, "textoff" => 1, "path" => "(0,"+("" + yOffset)+",255)"];
	return this.tagHandlers.move(moveTagParams);
} incontextof global.kag;

global.kag.updateScrollPosition = function(x, y) {
	this.scrollXOffset = x if x !== void;
	this.scrollYOffset = y if y !== void;

	if (!this.wideScreen && !global.isCropped) return;
	this.primaryLayer.updateTopScroll();
} incontextof global.kag;

global.kag.scrollDown = function() {
	this.originalscrollYOffset = this.scrollYOffset if this.originalscrollYOffset === void;
	this.updateScrollPosition(,global.Math.min(this.scrollYOffset+this.scrollYOffsetSpeed, this.scrollYOffsetMax));
} incontextof global.kag;

global.kag.scrollUp = function() {
	this.originalscrollYOffset = this.scrollYOffset if this.originalscrollYOffset === void;
	this.updateScrollPosition(,global.Math.max(this.scrollYOffset-this.scrollYOffsetSpeed, this.scrollYOffsetMin));
} incontextof global.kag;

global.kag.scrollReset = function() {
	if (this.originalscrollYOffset !== void) {
		this.updateScrollPosition(,this.originalscrollYOffset);
		this.originalscrollYOffset = void;
	}
} incontextof global.kag;


class LinearMoverBackground extends global.LinearMoverEx
{
	function LinearMoverBackground()
	{
		super.LinearMoverEx(...);
	}

	function updateData(a, b)
	{
		global.kag.updateScrollPosition(a, b);
	}
}
@endif
