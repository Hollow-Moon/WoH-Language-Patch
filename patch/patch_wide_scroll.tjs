@if(!WIDE_MODE)
global.kag.tagHandlers.initscroll = function(mp) {
	return 0;
};

global.kag.tagHandlers.dispscroll = function(mp) {
	return 0;
};
@endif

@if(WIDE_MODE)
global.kag.tagHandlers.initscroll = function(mp) {
	// Parameters: from, to, time
	mp.time = -1;
	return this.tagHandlers.dispscroll(mp);
} incontextof global.kag;

global.kag.tagHandlers.dispscroll = function(mp) {
	// Parameters: from, to, time
	this.originalscrollYOffset = void;
	var moveTime = (mp.time != 0)? mp.time : 600;

	// The "from" parameter represents the distance between the bottom end of the image and the bottom end of the window.
	// So, the value is 0 when the bottom end of the image is touching the bottom end of the client area (e.g. completely scrolled down).
	// The value is 150 when the top end of the image is touching the top end of the client area (e.g. completely scolled up).
	// The "to" parameter does nothing. The background always start scrolling from the position previously set to the value specified in "from".

	var yFrom = +mp.from;
	var yTo = +mp.to;

	// TODO time=-1 is a patch when being called from initscroll
	if ((!this.wideScreen && !global.isCropped) || mp.time == -1) {
		this.updateScrollPosition(,yTo);
		return 0;
	}

	if (this.scrollYOffset != yFrom) {
		this.conductor.pendings.insert(0, %[tagname: "move", layer: "primaryLayer", time: moveTime, bg: true, textoff: 1, path: "(0,"+("" + yFrom)+",255)"]);
	}
	if (yFrom != yTo) {
		this.conductor.pendings.insert(1, %[tagname: "move", layer: "primaryLayer", time: moveTime, bg: true, textoff: 1, path: "(0,"+("" + yTo)+",255)"]);
	}
	return 0;
} incontextof global.kag;

global.kag.updateScrollPosition = function(x, y) {
	this.scrollXOffset = x if x !== void;
	this.scrollYOffset = y if y !== void;

	if (!this.wideScreen && !global.isCropped) return;
	this.primaryLayer.updateTopScroll();
} incontextof global.kag;

global.kag.scrollDown = function() {
	this.originalscrollYOffset = this.scrollYOffset if this.originalscrollYOffset === void;
	this.updateScrollPosition(,global.Math.min(this.scrollYOffset+this.scrollYOffsetSpeed, this.scrollYOffsetMax));
} incontextof global.kag;

global.kag.scrollUp = function() {
	this.originalscrollYOffset = this.scrollYOffset if this.originalscrollYOffset === void;
	this.updateScrollPosition(,global.Math.max(this.scrollYOffset-this.scrollYOffsetSpeed, this.scrollYOffsetMin));
} incontextof global.kag;

global.kag.scrollReset = function() {
	if (this.originalscrollYOffset !== void) {
		this.updateScrollPosition(,this.originalscrollYOffset);
		this.originalscrollYOffset = void;
	}
} incontextof global.kag;


class LinearMoverBackground extends global.LinearMoverEx
{
	function LinearMoverBackground()
	{
		super.LinearMoverEx(...);
	}

	function updateData(a, b)
	{
		global.kag.updateScrollPosition(a, b);
	}
}
@endif
