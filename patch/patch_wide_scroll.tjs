@if(!WIDE_MODE)
global.add_kag_window_tag_handler("initscroll", function(mp) {
	return 0;
});

global.add_kag_window_tag_handler("dispscroll", function(mp) {
	return 0;
});
@endif

@if(WIDE_MODE)
global.add_kag_window_tag_handler("initscroll", function(mp) {
	// Parameters: from, to, time
	mp.time = -1;
	return this.tagHandlers.dispscroll(mp);
});

global.add_kag_window_tag_handler("dispscroll", function(mp) {
	// Parameters: from, to, time
	this.originalscrollYOffset = void;
	var moveTime = (mp.time != 0)? mp.time : 600;
	var yFrom = +mp.from;
	var yTo = +mp.to;
	var scrollAll = mp.all? true : false;

	// TODO time=-1 is a patch when being called from initscroll
	if ((!this.wideScreen && !global.isCropped) || mp.time == -1) {
		this.updateScrollPosition(,yTo);
		return 0;
	}

	var pendingIndex = 0;
	if (this.scrollYOffset != yFrom) {
		var firstMoveTime = yFrom != yTo? 300 : moveTime;
		this.conductor.pendings.insert(pendingIndex++, %[tagname: "move", layer: "primaryLayer", time: firstMoveTime, bg: true, textoff: 1, path: "(0,"+("" + yFrom)+",255)", all: scrollAll]);
	}
	if (yFrom != yTo) {
		if (pendingIndex > 0) {
			this.conductor.pendings.insert(pendingIndex++, %[tagname: "wm", canskip: 1]);
		}
		this.conductor.pendings.insert(pendingIndex, %[tagname: "move", layer: "primaryLayer", time: moveTime, bg: true, textoff: 1, path: "(0,"+("" + yTo)+",255)", all: scrollAll]);
	}
	return 0;
});

global.add_kag_window_tag_handler("waitscroll", function(mp) {
	if (!this.wideScreen && !global.isCropped) return 0;
	return this.tagHandlers.wm(mp);
});

global.kag.updateScrollPosition = function(x, y, scrollAll) {
	this.scrollXOffset = x if x !== void;
	this.scrollYOffset = y if y !== void;

	if (!this.wideScreen && !global.isCropped) return;
	this.primaryLayer.updateTopScroll(scrollAll);
} incontextof global.kag;

global.kag.scrollDown = function() {
	this.originalscrollYOffset = this.scrollYOffset if this.originalscrollYOffset === void;
	this.updateScrollPosition(,global.Math.min(this.scrollYOffset+this.scrollYOffsetSpeed, this.scrollYOffsetMax));
} incontextof global.kag;

global.kag.scrollUp = function() {
	this.originalscrollYOffset = this.scrollYOffset if this.originalscrollYOffset === void;
	this.updateScrollPosition(,global.Math.max(this.scrollYOffset-this.scrollYOffsetSpeed, this.scrollYOffsetMin));
} incontextof global.kag;

global.kag.scrollReset = function() {
	if (this.originalscrollYOffset !== void) {
		this.updateScrollPosition(,this.originalscrollYOffset);
		this.originalscrollYOffset = void;
	}
} incontextof global.kag;


class LinearMoverBackground extends global.LinearMoverEx
{
	var scrollAll = false;

	function LinearMoverBackground()
	{
		super.LinearMoverEx(...);
	}

	function updateData(a, b)
	{
		global.kag.updateScrollPosition(a, b, scrollAll);
	}
}
@endif
