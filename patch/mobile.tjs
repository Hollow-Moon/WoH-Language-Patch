global.is_mobile = false;

global.ssf = %[];

function playMenuOpenSE() {
    //Mobile only.
}

kag.setMessageLayerShadowMode = function(edge, shadow) {
	//Mobile only.
};

kag.setVirtualWideMode = function(value) {
	//Mobile only.
};

kag.tagHandlers.download = function(mp) {
	// Mobile only.
	return 0;
} incontextof kag;

kag.tagHandlers.openflowchart = function(mp) {
	// Mobile only.
	return 0;
} incontextof kag;

kag.tagHandlers.setbgmnonstopmode = function(mp) {
	// Mobile only.
	return 0;
} incontextof kag;

kag.tagHandlers.fixedframemode = function(mp) {
	// Mobile only.
	return 0;
} incontextof kag;

kag.tagHandlers.texturemag = function(mp) {
	// Mobile only.
	return 0;
} incontextof kag;

kag.tagHandlers.setwipemode = function(mp) {
	// Mobile only.
	return 0;
} incontextof kag;

kag.tagHandlers.setignorecinescoautofitmode = function(mp) {
	// Mobile only.
	return 0;
} incontextof kag;

kag.tagHandlers.setnocameraresetmode = function(mp) {
	// Mobile only.
	return 0;
} incontextof kag;

kag.tagHandlers.dflick = function(mp) {
	// Mobile only.
	return 0;
} incontextof kag;

kag.tagHandlers.lflick = function(mp) {
	// Mobile only.
	return 0;
} incontextof kag;

kag.tagHandlers.rflick = function(mp) {
	// Mobile only.
	return 0;
} incontextof kag;

kag.tagHandlers.uflick = function(mp) {
	// Mobile only.
	return 0;
} incontextof kag;

kag.tagHandlers.fillcolor = function(mp) {
	var layer = kag[mp.page].base;
	layer.colorRect(0, 0, +layer.width, +layer.height, +mp.color, +mp.opacity);
	return 0;
} incontextof kag;


property layersToFix
{
	getter
	{
		var layers = [];
		if (typeof(global.kag) === "Object" && isvalid(global.kag))
		{
			var kag = global.kag;
			if (typeof(kag.sysbase) === "Object" && isvalid(kag.sysbase))
			{
				layers.add([kag.sysbase]);
			}
			if (typeof(kag.fore) === "Object" && isvalid(kag.fore))
			{
				var fore = kag.fore;
				if (typeof(fore.messages) === "Object" && isvalid(fore.messages))
				{
					layers.add(fore.messages);
				}
				if (typeof(fore.layers) === "Object" && isvalid(fore.layers))
				{
					layers.add(fore.layers);
				}
				if (typeof(fore.belts) === "Object" && isvalid(fore.belts))
				{
					layers.add(fore.belts);
				}
			}
			if (typeof(kag.back) === "Object" && isvalid(kag.back))
			{
				var back = kag.back;
				if (typeof(back.messages) === "Object" && isvalid(back.messages))
				{
					layers.add(back.messages);
				}
				if (typeof(back.layers) === "Object" && isvalid(back.layers))
				{
					layers.add(back.layers);
				}
				if (typeof(back.belts) === "Object" && isvalid(back.belts))
				{
					layers.add(back.belts);
				}
			}
		}
		var layers2 = [];
		if (typeof(global.flow_tracker_object) === "Object" && isvalid(global.flow_tracker_object))
		{
			var flow_tracker_object = global.flow_tracker_object;
			if (typeof(flow_tracker_object.flowlayer) === "Object" && isvalid(flow_tracker_object.flowlayer))
			{
				layers2.add(flow_tracker_object.flowlayer);
			}
			if (typeof(flow_tracker_object.flaglayer) === "Object" && isvalid(flow_tracker_object.flaglayer))
			{
				layers2.add(flow_tracker_object.flaglayer);
			}
		}
		if (typeof(global.gamemenu) === "Object" && isvalid(global.gamemenu))
		{
			var gamemenu = global.gamemenu;
			if (typeof(gamemenu.gmenu) === "Object" && isvalid(gamemenu.gmenu))
			{
				layers2.add(gamemenu.gmenu);
			}
		}
		if (typeof(global.shortcut_object) === "Object" && isvalid(global.shortcut_object))
		{
			var shortcut_object = global.shortcut_object;
			if (typeof(shortcut_object.menulayer) === "Object" && isvalid(shortcut_object.menulayer))
			{
				layers2.add(shortcut_object.menulayer);
			}
		}
		if (typeof(global.yesnolayer) === "Object" && isvalid(global.yesnolayer))
		{
			var yesnolayer = global.yesnolayer;
			layers2.add(yesnolayer);
			if (typeof(yesnolayer.reverse) === "Object" && isvalid(yesnolayer.reverse))
			{
				layers2.add(yesnolayer.reverse);
			}
		}
		if (typeof(global.titlemenu_object) === "Object" && isvalid(global.titlemenu_object)
			&& typeof(global.titlemenu_object.menulayer) === "Object" && isvalid(global.titlemenu_object.menulayer)
			&& typeof(global.titlemenu_object.menulayer.innermenus) === "Object" && isvalid(global.titlemenu_object.menulayer.innermenus)
			&& global.titlemenu_object.menulayer.innermenus.count > 0) {
			var innerMenu = global.titlemenu_object.menulayer.innermenus[0];
			if (typeof(innerMenu) === "Object" && isvalid(innerMenu) && innerMenu instanceof "GalleryMenuLayer"
				&& typeof(innerMenu.thumbnailLayer) === "Object" && isvalid(innerMenu.thumbnailLayer)
				&& typeof(innerMenu.thumbnailLayer.image) === "Object" && isvalid(innerMenu.thumbnailLayer.image)
				&& typeof(innerMenu.thumbnailLayer.image.maskLayer) === "Object" && isvalid(innerMenu.thumbnailLayer.image.maskLayer)) {
					layers2.add(innerMenu.thumbnailLayer.image.maskLayer);
			}
		}
		layers.add(layers2);
		return layers;
	}
}


kag.tagHandlers.initscroll = function(mp) {
@if(!WIDE_MODE)
	return 0;
@endif
@if(WIDE_MODE)
	// Parameters: from , to, time
	mp.time = -1;
	return tagHandlers.dispscroll(mp);
@endif
} incontextof kag;

kag.tagHandlers.dispscroll = function(mp) {
@if(!WIDE_MODE)
	return 0;
@endif
@if(WIDE_MODE)
	originalscrollYOffset = void;
	// Parameters: from, to, time
	var moveTime = (mp.time != 0)? mp.time : 600;
	// TODO dunno what's the difference between "from" and "to" - they are almost always given the same value - need to test a scene where this is not the case.
	var yOffset = +mp.from;

	if (scrollYOffset == yOffset) {
		return 0;
	}

	// TODO time=-1 is a patch when being called from initscroll
	if ((!wideScreen && !isCropped) || mp.time == -1) {
		updateScrollPosition(,yOffset);
		return 0;
	}

	//var waitMoveTag = %["tagname" => "wm", "canskip" => 1];
	//conductor.pendings.insert(0, waitMoveTag);
	var moveTagParams = %["layer" => "primaryLayer", "time" => moveTime, "bg" => true, "textoff" => 1, "path" => "(0,"+("" + yOffset)+",255)"];
	return tagHandlers.move(moveTagParams);

	return 0;
@endif
} incontextof kag;

@if(WIDE_MODE)
kag.updateScrollPosition = function(x, y) {
	scrollXOffset = x if x !== void;
	scrollYOffset = y if y !== void;

	if (!wideScreen && !isCropped) return;

	var layersToFix = global.layersToFix;
	for (var i = 0, internal_forloop_count = layersToFix.count; i < internal_forloop_count; i += 1) {
		if (layersToFix[i] === void) {
			continue;
		}
		for(var j = 0, internal_forloop_count = layersToFix[i].count; j < internal_forloop_count; j += 1) {
			var currentLayer = layersToFix[i][j];
			if (currentLayer === void) {
				continue;
			}
			currentLayer.setPos(currentLayer.left, currentLayer.top);
		}
	}
} incontextof kag;

kag.scrollDown = function() {
	originalscrollYOffset = scrollYOffset if originalscrollYOffset === void;
	updateScrollPosition(,Math.min(scrollYOffset+scrollYOffsetSpeed, scrollYOffsetMax));
} incontextof kag;

kag.scrollUp = function() {
	originalscrollYOffset = scrollYOffset if originalscrollYOffset === void;
	updateScrollPosition(,Math.max(scrollYOffset-scrollYOffsetSpeed, scrollYOffsetMin));
} incontextof kag;

kag.scrollReset = function() {
	if (originalscrollYOffset !== void) {
		updateScrollPosition(,originalscrollYOffset);
		originalscrollYOffset = void;
	}
} incontextof kag;


class LinearMoverBackground extends LinearMoverEx
{
	function LinearMoverBackground()
	{
		super.LinearMoverEx(...);
	}

	function updateData(a, b)
	{
		kag.updateScrollPosition(a, b);
	}
}
@endif
