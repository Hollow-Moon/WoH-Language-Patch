var opPatchName = "op";
function get_opPatchExists() { { return patchExists(opPatchName); } }
function get_movieMenuPatch(kag=global.kag) { { return get_opPatchExists() && kag.sflags.movieMenuPatch; } }
function get_playVitaOp(kag=global.kag) { { return get_opPatchExists() && kag.sflags.playVitaOp; } }

var patchMenuIndex = -1;
function getPatchMenuIndex(kag)
{
@if(kirikiriz)
	patchMenuIndex = kag.helpMenu.index;
@endif
@if(!kirikiriz)
	patchMenuIndex = 4; // No "index" member so we hardcode the number.
@endif
	return patchMenuIndex;
}

class GameFlag
{
	var owner;
	var holder;
	var name;
	var reverse;
	var defaultValue;

	property value {
		getter { return reverse? !holder[name] : holder[name]; }
		setter(v) { holder[name] = reverse? !v : v; }
	}

	function GameFlag(owner, holder, name, defaultValue=void, reverse=false)
	{
		this.owner = owner;
		this.holder = holder;
		this.name = name;
		this.reverse = reverse;
		this.defaultValue = defaultValue;

		if (defaultValue !== void && typeof holder[name] == "undefined") {
			value = defaultValue;
		}
	}

	function toggleValue()
	{
		value = !value;
	}
}

class ComplexGameFlag extends GameFlag
{
	function ComplexGameFlag() { super.GameFlag(...); }

	property value
	{
		getter
		{
			// TODO code duplication between getter and setter.
			var path = name.split(".");
			var currentHolder = holder;
			for (var i=0; i<path.count-1; i++) {
				currentHolder = currentHolder[path[i]];
			}
			var lastPath = path[path.count-1];

			return reverse? !currentHolder[lastPath] : currentHolder[lastPath];
		}
		setter(v)
		{
			var path = name.split(".");
			var currentHolder = holder;
			for (var i=0; i<path.count-1; i++) {
				currentHolder = currentHolder[path[i]];
			}
			var lastPath = path[path.count-1];

			currentHolder[lastPath] = reverse? !v : v;
		}
	}
}

// For some reason this can't be an instance method...
function inverseFlag(flag)
{
	return new GameFlag(flag.owner, flag.holder, flag.name, !flag.defaultValue, !flag.reverse);
}

class CompositeAndFlag
{
	var flags;

	function CompositeAndFlag(flags)
	{
		this.flags = flags;
	}

	property value {
		getter
		{
			for(var i=0; i<flags.count; i++) {
				if (!flags[i].value) {
					return false;
				}
			}
			return true;
		}
		setter(v)
		{
			for(var i=0; i<flags.count; i++) {
				flags[i].value = v;
			}
		}
	}

	function toggleValue()
	{
		for(var i=0; i<flags.count; i++) {
			flags[i].toggleValue();
		}
	}
}

class KAGFlagMenuItem extends KAGMenuItem
{
	var flag;
	var radioValue;
	var previousFlagValue;
	var restart;

	function KAGFlagMenuItem(window, name, group=0, flag, radioValue=true, restart=false)
	{
		super.KAGMenuItem(window, name, group, onFlagMenuItemClick, false);

		this.flag = flag;
		this.radioValue = radioValue;
		this.restart = restart;
		initialize();
	}

	function onFlagMenuItemClick(sender)
	{
		previousFlagValue = sender.flag.value;

		var allowed = sender.beforeCallback(sender);
		if (!allowed) return;

		var flagValueChanged = true;
		if (sender.radio) {
			if (sender.flag.value === radioValue) {
				flagValueChanged = false;
			}
			sender.flag.value = radioValue;
		} else {
			sender.flag.toggleValue();
		}

		sender.checked = sender.flag.value === radioValue;

		sender.afterCallback(sender);

		if (restart && flagValueChanged && restartCondition()) {
			with (owner) {
				.extraConductor.clear(); // Fix code for AutoPath
				.onReloadScenarioMenuItemClick(sender);
			}
		}
	}

	function restartCondition() {
		return true;
	}

	function onlyTitleRestartCondition() {
		return owner.conductor.curStorage === "タイトル.ks" || owner.conductor.curStorage === "title.ks";
	}

	function onlyScenarioRestartCondition() {
		return !onlyTitleRestartCondition();
	}

	function updateChecked()
	{
		this.checked = flag.value === radioValue;
	}

	function initialize()
	{
		updateChecked();
		afterCallback(this, true);
	}

	function disableIfPatchDoesntExist(patchName)
	{
		if (patchName !== void && !patchExists(patchName)) {
			if (flag.value) {
				onFlagMenuItemClick(this);
			}
			this.enabled = false;
		}
	}

	function beforeCallback(sender, firstTime=false) { return true; }
	function afterCallback(sender, firstTime=false) { }
}

class KAGFlagFolderMenuItem extends KAGFlagMenuItem
{
	var patchNames;
	var folderNames;
	var inverseFolderNames;
	var languageSpecific;

	property patchName
	{
		getter
		{
			if (patchNames.count > 1) {
				throw new Exception("Can't use patchName with more than one patch.");
			}
			return patchNames[0];
		}
	}

	function KAGFlagFolderMenuItem(window, name, group=0, flag, patchNames="", folderNames=void, inverseFolderNames=void, languageSpecific=true)
	{
		if (typeof patchNames === "String") {
			patchNames = [patchNames];
		}
		this.patchNames = patchNames;
		if (folderNames === void && inverseFolderNames === void) {
			folderNames = "";
		}
		if (typeof folderNames === "String") {
			folderNames = [folderNames];
		}
		if (typeof inverseFolderNames === "String") {
			inverseFolderNames = [inverseFolderNames];
		}
		this.folderNames = folderNames;
		this.inverseFolderNames = inverseFolderNames;
		this.languageSpecific = languageSpecific;
		super.KAGFlagMenuItem(window, name, group, flag);
		for (var i=0; i<patchNames.count; i++) {
			disableIfPatchDoesntExist(patchNames[i]);
		}
	}

	function afterCallback(sender, firstTime=false)
	{
		// Radio options that are not of boolean type should implement their own logic.
		// if (sender.radio) return;

		if (sender.flag.value) {
			loadAllFolders(firstTime);
		} else {
			unloadAllFolders(firstTime); // Don't unload if wasn't ever loaded.
		}
	}

	function loadFolders(folderNames)
	{
		var patches_arr = [];
		for (var i=0; i<patchNames.count; i++) {
			if (patchNames[i] !== void) {
				//dm("loading: " + patchNames[i] + ">" + folderNames[i]);
				patches_arr.add([patchNames[i], folderNames[i]]);
@if(HD_MODE)
				patches_arr.add([patchNames[i], folderNames[i]+hdFolderSuffix]) if owner.isHd;
@endif
			}
			if (languageSpecific) {
				patches_arr.add([languagePatchName(japaneseLanguage), folderNames[i]]);
				patches_arr.add([languagePatchName(owner.sflags.language), folderNames[i]]) if owner.sflags.language !== void && owner.sflags.language !== japaneseLanguage;
			}
		}
		load_patches(patches_arr);
		invalidate patches_arr;
		delete patches_arr;
	}

	function unloadFolders(folderNames)
	{
		var patches_arr = [];
		for (var i=0; i<patchNames.count; i++) {
			if (languageSpecific) {
				patches_arr.add([languagePatchName(owner.sflags.language), folderNames[i]]) if owner.sflags.language !== void && owner.sflags.language !== japaneseLanguage;
				patches_arr.add([languagePatchName(japaneseLanguage), folderNames[i]]);
			}
			if (patchNames[i] !== void) {
				//dm("unloading: " + patchNames[i] + ">" + folderNames[i]);
@if(HD_MODE)
				patches_arr.add([patchNames[i], folderNames[i]+hdFolderSuffix]) if owner.isHd;
@endif
				patches_arr.add([patchNames[i], folderNames[i]]);
			}
		}
		unload_patches(patches_arr);
		invalidate patches_arr;
		delete patches_arr;
	}

	function loadAllFolders(firstTime=false)
	{
		unloadFolders(inverseFolderNames) if inverseFolderNames !== void && !firstTime;
		loadFolders(folderNames) if folderNames !== void;
	}

	function unloadAllFolders(firstTime=false)
	{
		unloadFolders(folderNames) if folderNames !== void && !firstTime;
		loadFolders(inverseFolderNames) if inverseFolderNames !== void;
	}
}

class KAGCensorMenuItem extends KAGMenuItem
{
	var hCensoredMenuItem;
	var hUncensoredMenuItem;
	var hDecensoredMenuItem;

	var matureMenuItem;

	var currentState;

	var previouslyFullyCensored;


	function KAGCensorMenuItem(window, name, hFlag, hPatchName, hCensorPatchName, maturePatchName)
	{
		super.KAGMenuItem(window, name, 0, void, false);
		addChildren(hFlag, hPatchName, hCensorPatchName, maturePatchName);
	}

	function addChildren(hFlag, hPatchName, hCensorPatchName, maturePatchName)
	{
		var matureFlag = new GameFlag(owner, owner.sflags, matureFlagName, true);
		var matureCensorFlag = inverseFlag(matureFlag);
		var decensorFlag = new GameFlag(owner, owner.sflags, decensoredFlagName, false);

		var hCensorFlagComposite = new CompositeAndFlag([inverseFlag(hFlag), inverseFlag(decensorFlag)]);
		var hFlagComposite = new CompositeAndFlag([hFlag, inverseFlag(decensorFlag)]);
		var decensorFlagComposite = new CompositeAndFlag([hFlag, decensorFlag]);

		this.add(this.hCensoredMenuItem = new KAGFlagFolderMenuItem(owner, __t("&Hコンテンツを検閲する"), 1, hCensorFlagComposite, hCensorPatchName, censoredHFolderName));
		this.hCensoredMenuItem.beforeCallback = this.beforeCallback;
		this.hCensoredMenuItem.afterCallback = this.afterCallback;
		this.add(this.hUncensoredMenuItem = new KAGFlagFolderMenuItem(owner, __t("Hコンテンツを検閲しない(&U)"), 1, hFlagComposite, hPatchName, uncensoredHFolderName));
		this.hUncensoredMenuItem.beforeCallback = this.beforeCallback;
		this.hUncensoredMenuItem.afterCallback = this.afterCallback;
		this.add(this.hDecensoredMenuItem = new KAGFlagFolderMenuItem(owner, __t("Hコンテンツを強制的に無検閲する(&D)"), 1, decensorFlagComposite,
@if(GAME_FATE)
		[hPatchName, decensoredPatchName], [uncensoredHFolderName, decensoredFolderName]));
@endif
@if(GAME_FHAT)
		decensoredPatchName, decensoredFolderName));
@endif
@if(GAME_WOHN)
		[], []));
@endif
		this.hDecensoredMenuItem.beforeCallback = this.beforeCallback;
		this.hDecensoredMenuItem.afterCallback = this.afterCallback;

		(addSeperationLine incontextof owner)(this);

		this.add(this.matureMenuItem = new KAGFlagFolderMenuItem(owner, __t("成人向けコンテンツを検閲する(&M)"),, matureCensorFlag, maturePatchName, censoredMatureFolderName, uncensoredMatureFolderName));
		this.matureMenuItem.beforeCallback = this.beforeCallback;
		this.matureMenuItem.afterCallback = this.afterCallback;

		updateCurrentState();
	}

	function addSeperationLine(menu)
	{
		menu.add(new MenuItem(this, "-"));
	}

	function updateCurrentState()
	{
		var items = [hCensoredMenuItem, hUncensoredMenuItem, hDecensoredMenuItem];
		for (var i=0; i<items.count; i++) {
			if (items[i].checked) {
				currentState = items[i];
				break;
			}
		}
		loadCurrentState();
	}

	function beforeCallback(sender)
	{
		if (sender == hCensoredMenuItem && isHScene()) {
			System.inform("Cannot turn off H-scenes during an H-scene. Try changing the settings again after the scene, or from the main menu.");
			return false;
		}

		previouslyFullyCensored = get_fullyCensored(owner);
		return true;
	}

	function afterCallback(sender)
	{
		if (previouslyFullyCensored && !get_fullyCensored(owner)) {
			unloadFullyCensored(currentState);
		}

		if (sender === matureMenuItem) {
			(KAGFlagFolderMenuItem.afterCallback incontextof sender)(sender);
		} else {
			currentState.unloadAllFolders();
			currentState = sender;
			loadCurrentState();
		}
	}

	function loadCurrentState()
	{
		currentState.loadAllFolders();

		if (!previouslyFullyCensored && get_fullyCensored(owner)) {
			loadFullyCensored(currentState);
		}

		updateDecensorConfig(owner);
	}

	function loadFullyCensored(sender)
	{
		load_patches([
			[sender.patchName, fullyCensoredFolderName],
			[languagePatchName(japaneseLanguage), fullyCensoredFolderName],
			(owner.sflags.language !== void && owner.sflags.language !== japaneseLanguage) ? [languagePatchName(owner.sflags.language), fullyCensoredFolderName] : void,
		]);
	}

	function unloadFullyCensored(sender)
	{
		unload_patches([
			(owner.sflags.language !== void && owner.sflags.language !== japaneseLanguage) ? [languagePatchName(owner.sflags.language), fullyCensoredFolderName] : void,
			[languagePatchName(japaneseLanguage), fullyCensoredFolderName],
			[sender.patchName, fullyCensoredFolderName],
		]);
	}
}

class LoadScenarioMenuItem extends KAGMenuItem
{
	var scenarioFileName;
	var labelName;

	function LoadScenarioMenuItem(window, name, scenarioFileName, labelName=void)
	{
		super.KAGMenuItem(window, name, 0, onLoadScenarioMenuItemClick, false);
		this.scenarioFileName = scenarioFileName;
		this.labelName = labelName === void? labelName : "*" + labelName;
	}

	function onLoadScenarioMenuItemClick(sender)
	{
		if (typeof global.titlemenu_object !== "undefined") {
			titlemenu_object.menulayer.goLabel(scenarioFileName, labelName);
		} else {
			owner.processCall(scenarioFileName, labelName);
		}
	}
}

function addPatchMenu() {
	menu.insert(this.patchMenu = new KAGMenuItem(this, __t("パッチ(&P)"), 0, void, false), getPatchMenuIndex(this));
	(addCensorMenu incontextof this)(patchMenu, __t("検閲(&C)"));
	(addVoiceMenu incontextof this)(patchMenu);
	(addVitaMenu incontextof this)(patchMenu);
	(addGalleryMenu incontextof this)(patchMenu);
	(addMovieMenu incontextof this)(patchMenu);

	(addDevelopmentMenu incontextof this)();
@if(ZOOM_WINDOW)
	(addWindowSizeMenu incontextof this)(this.displayMenu);
@endif
@if(HD_MODE)
	(addHdMenu incontextof this)(this.displayMenu);
	(addMessageWindowMenu incontextof this)(patchMenu);
@endif

	(addOptionsMenu incontextof this)(patchMenu);
	(addPatchMenuItems incontextof this)(patchMenu);
}

function addDevelopmentMenu() {
	menu.add(this.devMenuItem = new KAGMenuItem(this, "&Development", 0, void, false));
	this.devMenuItem.visible = devMode || devMode2;
	(addDevelopmentMenuItems incontextof this)(devMenuItem);
	devMenuItem.add(this.throwExceptionItem = new KAGMenuItem(this, "Throw Exception", 1, function(sender) { throw new Exception("This is a test Exception."); }, false));
	devMenuItem.add(this.throwConductorExceptionItem = new KAGMenuItem(this, "Throw ConductorException", 1, function(sender) { throw new ConductorException("This is a test ConductorException."); }, false));
}

function addVoiceMenu(patchMenu) {
	var unmatchedVoiceFlag = new GameFlag(this, this.sflags, "playUnmatchedVoices", true);
	var playUnusedVoicesFlag = new GameFlag(this, this.sflags, "unusedVoices", true);
	var customWaitvoiceFlag = new GameFlag(this, this.sflags, "customWaitvoice", true);
	var fadeBgmWithVoiceFlag = new GameFlag(this, this.scflags, "fadeBgmWithVoice", false);
	var customVoiceReplayFlag = new GameFlag(this, this.sflags, "customVoiceReplay", false);
	var disableStopVoiceWithClickFlag = new GameFlag(this, this.scflags, "disableStopVoiceWithClick", false);

	patchMenu.add(this.voiceMenuItem = new KAGMenuItem(this, __t("ボイス(&V)"), 0, void, false));
	voiceMenuItem.add(this.playUnmatchedVoicesMenuItem = new KAGFlagMenuItem(this, __t("不一緻なボイスを再生する(&M)"),, unmatchedVoiceFlag));
	voiceMenuItem.add(this.playUnusedVoicesMenuItem = new KAGFlagMenuItem(this, __t("未使用ボイスを再生する(&U)"),, playUnusedVoicesFlag));
	voiceMenuItem.add(this.customWaitvoiceMenuItem = new KAGFlagMenuItem(this, __t("あつらえのWait-Voiceタグを使用する(&W)"),, customWaitvoiceFlag));
@if(FADE_BGM_WITH_VOICE==1)
	voiceMenuItem.add(this.fadeBgmWithVoiceMenuItem = new KAGFlagMenuItem(this, __t("ボイス再生中に&BGM音量を下げる"),, fadeBgmWithVoiceFlag));
@endif
	voiceMenuItem.add(this.customVoiceReplayIconsMenuItem = new KAGFlagMenuItem(this, __t("あつらえのボイス再生アイコンを使用する(&R)"),, customVoiceReplayFlag));
	voiceMenuItem.add(this.disableStopVoiceWithClickMenuItem = new KAGFlagMenuItem(this, __t("クリックすると現在のボイスが停止しません(&V)"),, disableStopVoiceWithClickFlag));

	(addVoiceMenuItems incontextof this)(voiceMenuItem);
}

function addVitaMenu(patchMenu) {
	var playVitaOpFlag = new GameFlag(this, this.sflags, "playVitaOp", get_opPatchExists(this));
	var vitaMovieMenuFlag = new GameFlag(this, this.sflags, "movieMenuPatch", get_opPatchExists(this));
	var vitaAboutFlag = new GameFlag(this, this.sflags, "aboutPatch", get_vitaPatchExists(this));

	patchMenu.add(this.vitaMenuItem = new KAGMenuItem(this, __t("&Vitaコンテンツ"), 0, void, false));
	vitaMenuItem.add(this.vitaOPMenuItem = new KAGFlagMenuItem(this, __t("Vitaの&OPをゲーム中に再生する"),, playVitaOpFlag));
	this.vitaOPMenuItem.disableIfPatchDoesntExist(opPatchName);
	vitaMenuItem.add(this.vitaMovieMenuItem = new KAGFlagFolderMenuItem(this, __t("Vitaのムービーメニュ(&M)"),, vitaMovieMenuFlag, opPatchName, "override",, false));
	this.vitaMovieMenuItem.disableIfPatchDoesntExist(opPatchName);
	vitaMenuItem.add(this.vitaAboutMenuItem = new KAGFlagMenuItem(this, __t("Vitaの「このスフとについて」ページ(&A)"),, vitaAboutFlag));

	(addVitaMenuItems incontextof this)(vitaMenuItem);
}

function addMovieMenu(patchMenu) {
	var subbedVideosFlag = new GameFlag(this, this.sflags, subbedVideosFlagName, true);
	var skipMoviesFlag = new GameFlag(this, this.sflags, "skipMovies", false);
	var forceMpvPlaybackFlag = new GameFlag(this, this.sflags, "forceMpvPlayback", false);

	patchMenu.add(this.movieMenuItem = new KAGMenuItem(this, __t("ムービー(&M)"), 0, void, false));
	movieMenuItem.add(this.subbedVideosMenuItem = new KAGFlagFolderMenuItem(this, __t("ムービー再生中に字幕を表示する(&S)"),, subbedVideosFlag,,videosFolderName));
	movieMenuItem.add(this.skipMoviesMenuItem = new KAGFlagMenuItem(this, __t("ゲーム中にムービーをスキップする(&K)"),,skipMoviesFlag));
	movieMenuItem.add(this.forceMpvPlaybackMenuItem = new KAGFlagMenuItem(this, "Force movie playback using mpv",,forceMpvPlaybackFlag));
	if(typeof(global.playVideoMPV) == "undefined") {
		this.forceMpvPlaybackMenuItem.enabled = false;
	}
}

function addOptionsMenu(patchMenu) {
	var historyTitleFlag = new GameFlag(this, this.sflags, "historyTitle", false);

	patchMenu.add(this.patchOptionsMenuItem = new KAGMenuItem(this, __t("設定(&O)"), 0, void, false));
	patchOptionsMenuItem.add(this.historyTitleMenuItem = new KAGFlagMenuItem(this, __t("メッセージ歴史でシーンのタイトルを表示する(&H)"),, historyTitleFlag));
	patchOptionsMenuItem.add(this.engineConfigurationItem = new KAGMenuItem(this, "Open engine configuration dialog", 1, function() { global.System.shellExecute(Storages.getLocalName(global.System.exeName), '-userconf'); },false));

	(addOptionsMenuItems incontextof this)(patchOptionsMenuItem);
}

function addWindowSizeMenu(displayMenu) {
	displayMenu.add(new MenuItem(this, "-"));

		displayMenu.add(this.windowSizeMenu = new KAGMenuItem(this, __t("ウィンドウ内部のサイズ指定(&S)"), 0, void, false));

@if(GAME_WOHN)
			windowSizeMenu.add(this.window1024MenuItem = new KAGMenuItem(this, __t("1024x576 (デフォルト)"), 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1024); }, false));
@endif
@if(GAME_FATE||GAME_FHAT)
@if(!HD_MODE)
			windowSizeMenu.add(this.window800MenuItem = new KAGMenuItem(this, __t("800x600 (デフォルト)"), 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,800); }, false));
@endif
@if(HD_MODE)
			windowSizeMenu.add(this.window800MenuItem = new KAGMenuItem(this, __t("1.00x (デフォルト)"), 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,800); }, false));
@endif
@endif

			windowSizeMenu.add(new MenuItem(this, "-"));

@if(GAME_WOHN)
			windowSizeMenu.add(this.window1280MenuItem = new KAGMenuItem(this, "1280x720", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1280); }, false));

			windowSizeMenu.add(this.window1440MenuItem = new KAGMenuItem(this, "1440x810", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1440); }, false));

			windowSizeMenu.add(this.window1600MenuItem = new KAGMenuItem(this, "1600x900", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1600); }, false));

			windowSizeMenu.add(this.window1920MenuItem = new KAGMenuItem(this, "1920x1080", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1920); }, false));

			windowSizeMenu.add(this.window640MenuItem = new KAGMenuItem(this, "640x360", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,640); }, false));

			windowSizeMenu.add(this.window800MenuItem = new KAGMenuItem(this, "800x450", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,800); }, false));
@endif
@if(GAME_FATE||GAME_FHAT)
@if(!HD_MODE)
			windowSizeMenu.add(this.window1024MenuItem = new KAGMenuItem(this, "1024x768", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1024); }, false));

			windowSizeMenu.add(this.window1280MenuItem = new KAGMenuItem(this, "1280x960", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1280); }, false));

			windowSizeMenu.add(this.window1440MenuItem = new KAGMenuItem(this, "1440x1080", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1440); }, false));

			windowSizeMenu.add(this.window640MenuItem = new KAGMenuItem(this, "640x480", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,640); }, false));
@endif
@if(HD_MODE)
			windowSizeMenu.add(this.window1024MenuItem = new KAGMenuItem(this, "1.28x", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1024); }, false));

			windowSizeMenu.add(this.window1280MenuItem = new KAGMenuItem(this, "1.60x", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1280); }, false));

			windowSizeMenu.add(this.window1440MenuItem = new KAGMenuItem(this, "1.80x", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1440); }, false));

			windowSizeMenu.add(this.window640MenuItem = new KAGMenuItem(this, "0.80x", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,640); }, false));
@endif
@endif

			windowSizeMenu.add(new MenuItem(this, "-"));

			windowSizeMenu.add(this.windowResizeableMenuItem = new KAGMenuItem(this, __t("サイズを固定する"), 0,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,0); }, false));
}

function addHdMenu(displayMenu) {
	var wideResolutions = %[ "&Wide (16:9)" => standardWideRatio];

	displayMenu.add(new MenuItem(this, "-"));

	displayMenu.add(this.qualityMenu = new KAGMenuItem(this, "&Quality", 0, void, false));
	this.qualityMenu.enabled = false;

		qualityMenu.add(this.lqMenuItem = new KAGMenuItem(this, "Low", 1,
			function(sender) { onQualityMenuItemClick(sender.owner.lqMenuItem,'low'); }, false));

		qualityMenu.add(this.hqMenuItem = new KAGMenuItem(this, "High", 1,
			function(sender) { onQualityMenuItemClick(sender.owner.hqMenuItem,'high'); }, false));
		this.hqMenuItem.enabled = hdPatchExists;

	displayMenu.add(this.wideMenu = new KAGMenuItem(this, "&Aspect Ratio", 0, void, false));
	this.wideMenu.enabled = false;

		wideMenu.add(this.notWideMenuItem = new KAGMenuItem(this, "&Standard (4:3)", 1,
			function(sender) { onWideMenuItemClick(sender.owner.notWideMenuItem,'standard'); }, false));

		wideMenu.add(this.wideMenuItem = new KAGMenuItem(this, "&Match desktop", 1,
			function(sender) { onWideMenuItemClick(sender.owner.wideMenuItem,'wide'); }, false));

		var keys = Scripts.getObjectKeys(wideResolutions);
		for (var i=0; i<keys.count; i++) {
			var key = keys[i];
			var ratio = wideResolutions[key];
			if (ratio == systemRatio) {
				continue;
			}
			var wideMenuItemName = "wideRatio"+key.replace(/[:&\() ]/g, "")+"MenuItem";
			this.wideMenu.add(this[wideMenuItemName] = new KAGMenuItem(this, key, 1, function(sender) { onWideMenuItemClick(sender.owner.wideMenuItem, sender.ratio); }));
			this[wideMenuItemName].ratio = ratio;
		}

@if(CROP_MODE)
		wideMenu.add(this.wideCroppedMenuItem = new KAGMenuItem(this, "Wide (&cropped)", 1,
			function(sender) { onWideMenuItemClick(sender.owner.wideCroppedMenuItem,'standard',true) }, false));
@endif

	if (isHd) {
		this.hqMenuItem.checked = true;
	} else {
		this.lqMenuItem.checked = true;
	}
	if (wideScreen) {
		this.wideMenuItem.checked = true;
	} else {
		this.notWideMenuItem.checked = true;
	}
}

function addMessageWindowMenu(patchMenu)
{
	patchMenu.add(this.messageWindowMenuItem = new KAGMenuItem(this, "&Message Window", 0, void, false));
@if(GAME_FATE)
	var mobileWindowFlag = new GameFlag(this, this.sflags, "mobileWindow", false);
	messageWindowMenuItem.add(this.mobileMessageWindowMenuItem = new KAGFlagMenuItem(this, "&Mobile message window",, mobileWindowFlag,,true));
	this.mobileMessageWindowMenuItem.restartCondition = this.mobileMessageWindowMenuItem.onlyScenarioRestartCondition;
	var mobileBreakGlyphsFlag = new GameFlag(this, this.sflags, "mobileBreakGlyphs", false);
	messageWindowMenuItem.add(this.mobileBreakGlyphsMenuItem = new KAGFlagMenuItem(this, "Mobile text &break glyphs",, mobileBreakGlyphsFlag,,true));
	this.mobileBreakGlyphsMenuItem.restartCondition = this.mobileBreakGlyphsMenuItem.onlyScenarioRestartCondition;
@endif
	var wideStrechWindowFlag = new GameFlag(this, this.sflags, "wideStrechWindow", true);
	messageWindowMenuItem.add(this.wideMessageStretchMenuItem = new KAGFlagMenuItem(this, "4:3 message window in &wide mode",, inverseFlag(wideStrechWindowFlag),,true));
}
