var opPatchName = "op";
function get_opPatchExists() { { return patchExists(opPatchName); } }
function get_movieMenuPatch(kag=global.kag) { { return get_opPatchExists() && kag.sflags.movieMenuPatch; } }
function get_playVitaOp(kag=global.kag) { { return get_opPatchExists() && kag.sflags.playVitaOp; } }

var patchMenuIndex = -1;
function getPatchMenuIndex(kag)
{
@if(kirikiriz)
	patchMenuIndex = kag.helpMenu.index;
@endif
@if(!kirikiriz)
	patchMenuIndex = 4; // No "index" member so we hardcode the number.
@endif
	return patchMenuIndex;
}

class GameFlag
{
	var owner;
	var holder;
	var name;
	var reverse;
	var defaultValue;

	property value
	{
		getter
		{
			return (typeof(this.reverse) === "Integer" && this.reverse) ? !this.holder[name] : this.holder[name];
		}
		setter (v)
		{
			this.holder[name] = (typeof(this.reverse) === "Integer" && this.reverse) ? !v : v;
		}
	}

	function GameFlag(owner, holder, name, defaultValue=void, reverse=false)
	{
		this.owner = owner;
		this.holder = holder;
		this.name = name;
		this.reverse = reverse;
		this.defaultValue = defaultValue;

		if (this.defaultValue !== void && typeof(this.holder) === "Object" && typeof(this.holder[name]) === "undefined")
		{
			this.value = this.defaultValue;
		}
	}

	function toggleValue()
	{
		this.value = !this.value;
	}
}

class ComplexGameFlag extends GameFlag
{
	function ComplexGameFlag()
	{
		super.GameFlag(...);
	}

	property value
	{
		getter
		{
			// TODO code duplication between getter and setter.
			var path = this.name.split(".");
			var currentHolder = this.holder;
			for (var i=0; i<path.count-1; i++) {
				currentHolder = currentHolder[path[i]];
			}
			var lastPath = path[path.count-1];

			return (typeof(this.reverse) === "Integer" && this.reverse) ? !currentHolder[lastPath] : currentHolder[lastPath];
		}
		setter (v)
		{
			var path = this.name.split(".");
			var currentHolder = this.holder;
			for (var i=0; i<path.count-1; i++)
			{
				currentHolder = currentHolder[path[i]];
			}
			var lastPath = path[path.count-1];

			currentHolder[lastPath] = (typeof(this.reverse) === "Integer" && this.reverse) ? !v : v;
		}
	}
}

// For some reason this can't be an instance method...
function inverseFlag(flag)
{
	return new GameFlag(flag.owner, flag.holder, flag.name, !flag.defaultValue, !flag.reverse);
}

class CompositeAndFlag
{
	var flags;

	function CompositeAndFlag(flags)
	{
		this.flags = flags;
	}

	property value {
		getter
		{
			for(var i=0; i<flags.count; i++) {
				if (!flags[i].value) {
					return false;
				}
			}
			return true;
		}
		setter(v)
		{
			for(var i=0; i<flags.count; i++) {
				flags[i].value = v;
			}
		}
	}

	function toggleValue()
	{
		for(var i=0; i<flags.count; i++) {
			flags[i].toggleValue();
		}
	}
}

class KAGFlagMenuItem extends KAGMenuItem
{
	var flag;
	var radioValue;
	var previousFlagValue;
	var restart;

	function KAGFlagMenuItem(window, name, group=0, flag, radioValue=true, restart=false)
	{
		super.KAGMenuItem(window, name, group, onFlagMenuItemClick, false);

		this.flag = flag;
		this.radioValue = radioValue;
		this.restart = restart;
		initialize();
	}

	function onFlagMenuItemClick(sender)
	{
		previousFlagValue = sender.flag.value;

		var allowed = sender.beforeCallback(sender);
		if (!allowed) return;

		var flagValueChanged = true;
		if (sender.radio) {
			if (sender.flag.value === radioValue) {
				flagValueChanged = false;
			}
			sender.flag.value = radioValue;
		} else {
			sender.flag.toggleValue();
		}

		sender.checked = sender.flag.value === radioValue;

		sender.afterCallback(sender);

		if (restart && flagValueChanged && restartCondition()) {
			with (owner) {
				.extraConductor.clear(); // Fix code for AutoPath
				.onReloadScenarioMenuItemClick(sender);
			}
		}
	}

	function restartCondition()
	{
		return true;
	}

	function onlyTitleRestartCondition()
	{
		if (typeof owner.conductor !== "Object") {
			return false;
		}
		return owner.conductor.curStorage === "タイトル.ks" || owner.conductor.curStorage === "title.ks";
	}

	function onlyScenarioRestartCondition()
	{
		return !onlyTitleRestartCondition();
	}

	function updateChecked()
	{
		this.checked = flag.value === radioValue;
	}

	function initialize()
	{
		updateChecked();
		afterCallback(this, true);
	}

	function disableIfPatchDoesntExist(patchName)
	{
		if (patchName !== void && !patchExists(patchName)) {
			if (flag.value) {
				onFlagMenuItemClick(this);
			}
			this.enabled = false;
		}
	}

	function beforeCallback(sender, firstTime=false) { return true; }
	function afterCallback(sender, firstTime=false) { }
}

class KAGFlagFolderMenuItem extends KAGFlagMenuItem
{
	var patchNames;
	var folderNames;
	var inverseFolderNames;
	var languageSpecific;

	property patchName
	{
		getter
		{
			if (patchNames.count > 1) {
				throw new Exception("Can't use patchName with more than one patch.");
			}
			return patchNames[0];
		}
	}

	function KAGFlagFolderMenuItem(window, name, group=0, flag, patchNames="", folderNames=void, inverseFolderNames=void, languageSpecific=true)
	{
		if (typeof patchNames === "String") {
			patchNames = [patchNames];
		}
		this.patchNames = patchNames;
		if (folderNames === void && inverseFolderNames === void) {
			folderNames = "";
		}
		if (typeof folderNames === "String") {
			folderNames = [folderNames];
		}
		if (typeof inverseFolderNames === "String") {
			inverseFolderNames = [inverseFolderNames];
		}
		this.folderNames = folderNames;
		this.inverseFolderNames = inverseFolderNames;
		this.languageSpecific = languageSpecific;
		super.KAGFlagMenuItem(window, name, group, flag);
		for (var i=0; i<patchNames.count; i++) {
			disableIfPatchDoesntExist(patchNames[i]);
		}
	}

	function afterCallback(sender, firstTime=false)
	{
		// Radio options that are not of boolean type should implement their own logic.
		// if (sender.radio) return;

		if (sender.flag.value) {
			loadAllFolders(firstTime);
		} else {
			unloadAllFolders(firstTime); // Don't unload if wasn't ever loaded.
		}
	}

	function loadFolders(folderNames)
	{
		var patches_arr = [];
		for (var i=0; i<patchNames.count; i++) {
			if (patchNames[i] !== void) {
				//dm("loading: " + patchNames[i] + ">" + folderNames[i]);
				patches_arr.add([patchNames[i], folderNames[i]]);
@if(HD_MODE)
				patches_arr.add([patchNames[i], folderNames[i]+hdFolderSuffix]) if owner.isHd;
@endif
			}
			if (languageSpecific) {
				patches_arr.add([languagePatchName(japaneseLanguage), folderNames[i]]);
				patches_arr.add([languagePatchName(owner.sflags.language), folderNames[i]]) if owner.sflags.language !== void && owner.sflags.language !== japaneseLanguage;
			}
		}
		load_patches(patches_arr);
		invalidate patches_arr;
		delete patches_arr;
	}

	function unloadFolders(folderNames)
	{
		var patches_arr = [];
		for (var i=0; i<patchNames.count; i++) {
			if (languageSpecific) {
				patches_arr.add([languagePatchName(owner.sflags.language), folderNames[i]]) if owner.sflags.language !== void && owner.sflags.language !== japaneseLanguage;
				patches_arr.add([languagePatchName(japaneseLanguage), folderNames[i]]);
			}
			if (patchNames[i] !== void) {
				//dm("unloading: " + patchNames[i] + ">" + folderNames[i]);
@if(HD_MODE)
				patches_arr.add([patchNames[i], folderNames[i]+hdFolderSuffix]) if owner.isHd;
@endif
				patches_arr.add([patchNames[i], folderNames[i]]);
			}
		}
		unload_patches(patches_arr);
		invalidate patches_arr;
		delete patches_arr;
	}

	function loadAllFolders(firstTime=false)
	{
		unloadFolders(inverseFolderNames) if inverseFolderNames !== void && !firstTime;
		loadFolders(folderNames) if folderNames !== void;
	}

	function unloadAllFolders(firstTime=false)
	{
		unloadFolders(folderNames) if folderNames !== void && !firstTime;
		loadFolders(inverseFolderNames) if inverseFolderNames !== void;
	}
}

class KAGCensorMenuItem extends KAGMenuItem
{
	var hCensoredMenuItem;
	var hUncensoredMenuItem;
	var hDecensoredMenuItem;

	var matureMenuItem;

	var currentState;

	var previouslyFullyCensored;


	function KAGCensorMenuItem(window, name, hFlag)
	{
		super.KAGMenuItem(window, name, 0, void, false);
		addChildren(hFlag);
	}

	function addChildren(hFlag)
	{
		var matureFlag = new GameFlag(owner, owner.sflags, matureFlagName, true);
		var matureCensorFlag = inverseFlag(matureFlag);
		var decensorFlag = new GameFlag(owner, owner.sflags, decensoredFlagName, false);

		var hCensorFlagComposite = new CompositeAndFlag([inverseFlag(hFlag), inverseFlag(decensorFlag)]);
		var hFlagComposite = new CompositeAndFlag([hFlag, inverseFlag(decensorFlag)]);
		var decensorFlagComposite = new CompositeAndFlag([hFlag, decensorFlag]);

		this.add(this.hCensoredMenuItem = new KAGFlagFolderMenuItem(owner, __t("&Hコンテンツを検閲する"), 1, hCensorFlagComposite, hCensorPatchName, censoredHFolderName));
		this.hCensoredMenuItem.beforeCallback = this.beforeCallback;
		this.hCensoredMenuItem.afterCallback = this.afterCallback;
		this.add(this.hUncensoredMenuItem = new KAGFlagFolderMenuItem(owner, __t("Hコンテンツを検閲しない(&U)"), 1, hFlagComposite, hPatchName, uncensoredHFolderName));
		this.hUncensoredMenuItem.beforeCallback = this.beforeCallback;
		this.hUncensoredMenuItem.afterCallback = this.afterCallback;
		this.add(this.hDecensoredMenuItem = new KAGFlagFolderMenuItem(owner, __t("Hコンテンツを強制的に無検閲する(&D)"), 1, decensorFlagComposite,
@if(GAME_FATE)
		[hPatchName, decensoredPatchName], [uncensoredHFolderName, decensoredFolderName]));
@endif
@if(GAME_FHAT)
		decensoredPatchName, decensoredFolderName));
@endif
@if(GAME_WOHN)
		[], []));
@endif
		this.hDecensoredMenuItem.beforeCallback = this.beforeCallback;
		this.hDecensoredMenuItem.afterCallback = this.afterCallback;

		(addSeperationLine incontextof owner)(this);

		this.add(this.matureMenuItem = new KAGFlagFolderMenuItem(owner, __t("成人向けコンテンツを検閲する(&M)"),, matureCensorFlag, maturePatchName, censoredMatureFolderName, uncensoredMatureFolderName));
		this.matureMenuItem.beforeCallback = this.beforeCallback;
		this.matureMenuItem.afterCallback = this.afterCallback;

		updateCurrentState();
	}

	function addSeperationLine(menu)
	{
		menu.add(new MenuItem(this, "-"));
	}

	function updateCurrentState()
	{
		var items = [hCensoredMenuItem, hUncensoredMenuItem, hDecensoredMenuItem];
		for (var i=0; i<items.count; i++) {
			if (items[i].checked) {
				currentState = items[i];
				break;
			}
		}
		loadCurrentState();
	}

	function beforeCallback(sender)
	{
		if (sender == hCensoredMenuItem && isHScene()) {
			System.inform("Cannot turn off H-scenes during an H-scene. Try changing the settings again after the scene, or from the main menu.");
			return false;
		}

		previouslyFullyCensored = get_fullyCensored(owner);
		return true;
	}

	function afterCallback(sender)
	{
		if (previouslyFullyCensored && !get_fullyCensored(owner)) {
			unloadFullyCensored(currentState);
		}

		if (sender === matureMenuItem) {
			(KAGFlagFolderMenuItem.afterCallback incontextof sender)(sender);
		} else {
			currentState.unloadAllFolders();
			currentState = sender;
			loadCurrentState();
		}
	}

	function loadCurrentState()
	{
		currentState.loadAllFolders();

		if (!previouslyFullyCensored && get_fullyCensored(owner)) {
			loadFullyCensored(currentState);
		}

		updateDecensorConfig(owner);
	}

	function loadFullyCensored(sender)
	{
		load_patches([
			[sender.patchName, fullyCensoredFolderName],
			[languagePatchName(japaneseLanguage), fullyCensoredFolderName],
			(owner.sflags.language !== void && owner.sflags.language !== japaneseLanguage) ? [languagePatchName(owner.sflags.language), fullyCensoredFolderName] : void,
		]);
	}

	function unloadFullyCensored(sender)
	{
		unload_patches([
			(owner.sflags.language !== void && owner.sflags.language !== japaneseLanguage) ? [languagePatchName(owner.sflags.language), fullyCensoredFolderName] : void,
			[languagePatchName(japaneseLanguage), fullyCensoredFolderName],
			[sender.patchName, fullyCensoredFolderName],
		]);
	}
}

class LoadScenarioMenuItem extends KAGMenuItem
{
	var scenarioFileName;
	var labelName;

	function LoadScenarioMenuItem(window, name, scenarioFileName, labelName=void)
	{
		super.KAGMenuItem(window, name, 0, onLoadScenarioMenuItemClick, false);
		this.scenarioFileName = scenarioFileName;
		this.labelName = labelName === void? labelName : "*" + labelName;
	}

	function onLoadScenarioMenuItemClick(sender)
	{
		if (typeof global.titlemenu_object !== "undefined") {
			titlemenu_object.menulayer.goLabel(scenarioFileName, labelName);
		} else {
			owner.processCall(scenarioFileName, labelName);
		}
	}
}

function addEnableDisableRestartMenuFunctions()
{
	this.restart_menu_state = true;
	this.restart_menu_state_stack = [];
	this.pushRestartMenuState = function()
	{
		this.restart_menu_state_stack.add(this.restart_menu_state);
	};

	this.popRestartMenuState = function()
	{
		if (this.restart_menu_state_stack.count > 0)
		{
			this.setRestartMenuState(this.restart_menu_state_stack[this.restart_menu_state_stack.count - 1]);
			this.restart_menu_state_stack.erase(this.restart_menu_state_stack.count - 1);
		}
	};

	this.setRestartMenuState = function(state)
	{
		this.restart_menu_state = state;
		if (typeof(this.menu) === "Object")
		{
@if(HD_MODE)
			this.qualityMenu.enabled = state;
			this.wideMenu.enabled = state;
@endif
			if (typeof(this.titleThemeMenuItem) === "Object")
			{
				this.titleThemeMenuItem.enabled = state;
			}
			if (typeof(this.routeMenuItem) === "Object")
			{
				this.routeMenuItem.enabled = state;
			}
			if (typeof(this.languageMenu) === "Object")
			{
				this.languageMenu.enabled = state;
				// The following will cause a rebuild of the menu
				this.languageMenu.group = this.languageMenu.group;
			}
		}
	};

	this.enableRestartMenus = function()
	{
		this.setRestartMenuState(true);
	};

	this.disableRestartMenus = function()
	{
		this.setRestartMenuState(false);
	};

	this.disableRestartMenus();
}

function addPatchMenu() {
	menu.insert(this.patchMenu = new KAGMenuItem(this, __t("パッチ(&P)"), 0, void, false), getPatchMenuIndex(this));
	(addCensorMenu incontextof this)(patchMenu, __t("検閲(&C)"));
	(addVoiceMenu incontextof this)(patchMenu);
	(addVitaMenu incontextof this)(patchMenu);
	(addGalleryMenu incontextof this)(patchMenu);
	(addMovieMenu incontextof this)(patchMenu);

	(addDevelopmentMenu incontextof this)();
	(addConductorVerbosityMenu incontextof this)();
@if(ZOOM_WINDOW)
	(addWindowSizeMenu incontextof this)(this.displayMenu);
	if (this.isPseudoMode())
	{
		(addFullScreenMenu incontextof this)(this.displayMenu);
	}
@endif
@if(HD_MODE)
	(addHdMenu incontextof this)(this.displayMenu);
	(addMessageWindowMenu incontextof this)(patchMenu);
@endif

	(addOptionsMenu incontextof this)(patchMenu);
	(addPatchMenuItems incontextof this)(patchMenu);

	(addEnableDisableRestartMenuFunctions incontextof this)();
}

function addDevelopmentMenu() {
	menu.add(this.devMenuItem = new KAGMenuItem(this, "&Development", 0, void, false));
	this.devMenuItem.visible = devMode || devMode2;
	(addDevelopmentMenuItems incontextof this)(devMenuItem);
	devMenuItem.add(this.throwExceptionItem = new KAGMenuItem(this, "Throw Exception", 1, function(sender) { throw new Exception("This is a test Exception."); }, false));
	devMenuItem.add(this.throwConductorExceptionItem = new KAGMenuItem(this, "Throw ConductorException", 1, function(sender) { throw new ConductorException("This is a test ConductorException."); }, false));
	devMenuItem.add(this.openCommandPromptInProjectDirectory = new KAGMenuItem(this, "Open command prompt in project directory", 1, function(sender) { global.System.shellExecute("cmd.exe", "/k cd " + ('"%s"').sprintf(Storages.getLocalName(Storages.getFullPath(".")))); }, false));
	devMenuItem.add(this.gitCheckoutDashDashCurrentDirectory = new KAGMenuItem(this, "git checkout -- .", 1, function(sender) { global.build_exec_command_line("git.exe", ["-C", Storages.getLocalName(Storages.getFullPath(".")), "checkout", "--", "."], false, false); }, false));
	devMenuItem.add(this.gitPullOriginMaster = new KAGMenuItem(this, "git pull origin master", 1, function(sender) { global.build_exec_command_line("git.exe", ["-C", Storages.getLocalName(Storages.getFullPath(".")), "pull", "origin", "master"], false, false); }, false));
}

function addConductorVerbosityMenu() {
	debugMenu.add(this.debugLevelNoneMenuItem = new KAGMenuItem(this, __t("デバッグレベル:なし"), 2,
		this.onDebugLevelNoneMenuItemClick, false));
	this.debugLevelNoneMenuItem.checked = this.debugLevel === tkdlNone;

	debugMenu.add(this.debugLevelSimpleMenuItem = new KAGMenuItem(this, __t("デバッグレベル:シンプル"), 2,
		this.onDebugLevelSimpleMenuItemClick, false));
	this.debugLevelSimpleMenuItem.checked = this.debugLevel === tkdlSimple;

	debugMenu.add(this.debugLevelVerboseMenuItem = new KAGMenuItem(this, __t("デバッグレベル:詳細"), 2,
		this.onDebugLevelVerboseMenuItemClick, false));
	this.debugLevelVerboseMenuItem.checked = this.debugLevel === tkdlVerbose;

	debugMenu.add(new MenuItem(this, "-"));
}

function addVoiceMenu(patchMenu) {
	var unmatchedVoiceFlag = new GameFlag(this, this.sflags, "playUnmatchedVoices", true);
	var playUnusedVoicesFlag = new GameFlag(this, this.sflags, "unusedVoices", true);
	var customWaitvoiceFlag = new GameFlag(this, this.sflags, "customWaitvoice", true);
	var fadeBgmWithVoiceFlag = new GameFlag(this, this.scflags, "fadeBgmWithVoice", false);
	var customVoiceReplayFlag = new GameFlag(this, this.sflags, "customVoiceReplay", false);
	var disableStopVoiceWithClickFlag = new GameFlag(this, this.scflags, "disableStopVoiceWithClick", false);

	patchMenu.add(this.voiceMenuItem = new KAGMenuItem(this, __t("ボイス(&V)"), 0, void, false));
	voiceMenuItem.add(this.playUnmatchedVoicesMenuItem = new KAGFlagMenuItem(this, __t("不一緻なボイスを再生する(&M)"),, unmatchedVoiceFlag));
	voiceMenuItem.add(this.playUnusedVoicesMenuItem = new KAGFlagMenuItem(this, __t("未使用ボイスを再生する(&U)"),, playUnusedVoicesFlag));
	voiceMenuItem.add(this.customWaitvoiceMenuItem = new KAGFlagMenuItem(this, __t("あつらえのWait-Voiceタグを使用する(&W)"),, customWaitvoiceFlag));
@if(FADE_BGM_WITH_VOICE==1)
	voiceMenuItem.add(this.fadeBgmWithVoiceMenuItem = new KAGFlagMenuItem(this, __t("ボイス再生中に&BGM音量を下げる"),, fadeBgmWithVoiceFlag));
@endif
	voiceMenuItem.add(this.customVoiceReplayIconsMenuItem = new KAGFlagMenuItem(this, __t("あつらえのボイス再生アイコンを使用する(&R)"),, customVoiceReplayFlag));
	voiceMenuItem.add(this.disableStopVoiceWithClickMenuItem = new KAGFlagMenuItem(this, __t("クリックすると現在のボイスが停止しません(&V)"),, disableStopVoiceWithClickFlag));

	(addVoiceMenuItems incontextof this)(voiceMenuItem);
}

function addVitaMenu(patchMenu) {
	var playVitaOpFlag = new GameFlag(this, this.sflags, "playVitaOp", get_opPatchExists(this));
	var vitaMovieMenuFlag = new GameFlag(this, this.sflags, "movieMenuPatch", get_opPatchExists(this));
	var vitaAboutFlag = new GameFlag(this, this.sflags, "aboutPatch", get_vitaPatchExists(this));

	patchMenu.add(this.vitaMenuItem = new KAGMenuItem(this, __t("&Vitaコンテンツ"), 0, void, false));
	vitaMenuItem.add(this.vitaOPMenuItem = new KAGFlagMenuItem(this, __t("Vitaの&OPをゲーム中に再生する"),, playVitaOpFlag));
	this.vitaOPMenuItem.disableIfPatchDoesntExist(opPatchName);
	vitaMenuItem.add(this.vitaMovieMenuItem = new KAGFlagFolderMenuItem(this, __t("Vitaのムービーメニュ(&M)"),, vitaMovieMenuFlag, opPatchName, "override",, false));
	this.vitaMovieMenuItem.disableIfPatchDoesntExist(opPatchName);
	vitaMenuItem.add(this.vitaAboutMenuItem = new KAGFlagMenuItem(this, __t("Vitaの「このスフとについて」ページ(&A)"),, vitaAboutFlag));

	(addVitaMenuItems incontextof this)(vitaMenuItem);
}

function addMovieMenu(patchMenu) {
	var subbedVideosFlag = new GameFlag(this, this.sflags, subbedVideosFlagName, true);
	var skipMoviesFlag = new GameFlag(this, this.sflags, "skipMovies", false);
	var forceMpvPlaybackFlag = new GameFlag(this, this.sflags, "forceMpvPlayback", false);

	patchMenu.add(this.movieMenuItem = new KAGMenuItem(this, __t("ムービー(&M)"), 0, void, false));
	movieMenuItem.add(this.subbedVideosMenuItem = new KAGFlagFolderMenuItem(this, __t("ムービー再生中に字幕を表示する(&S)"),, subbedVideosFlag,,videosFolderName));
	movieMenuItem.add(this.skipMoviesMenuItem = new KAGFlagMenuItem(this, __t("ゲーム中にムービーをスキップする(&K)"),,skipMoviesFlag));
	movieMenuItem.add(this.forceMpvPlaybackMenuItem = new KAGFlagMenuItem(this, __t("mpvを使用して強制的に動画を再生する"),,forceMpvPlaybackFlag));
	if(typeof(global.playVideoMPV) == "undefined") {
		this.forceMpvPlaybackMenuItem.enabled = false;
	}
}

function addOptionsMenu(patchMenu) {
	var historyTitleFlag = new GameFlag(this, this.sflags, "historyTitle", false);
	var showLogoFlag = new GameFlag(this, this.sflags, "showLogo", true);
	var savedataRepairFlag = new GameFlag(this, this.sflags, "savedataRepair", false);

	patchMenu.add(this.patchOptionsMenuItem = new KAGMenuItem(this, __t("設定(&O)"), 0, void, false));
	patchOptionsMenuItem.add(this.historyTitleMenuItem = new KAGFlagMenuItem(this, __t("メッセージ歴史でシーンのタイトルを表示する(&H)"),, historyTitleFlag));
	patchOptionsMenuItem.add(this.engineConfigurationItem = new KAGMenuItem(this, __t("エンジン構成ダイアログを開く"), 1, function() { global.showEngineConfigureDialog(); },false));
	patchOptionsMenuItem.add(this.showLogoMenuItem = new KAGFlagMenuItem(this, __t("起動時にTYPE-MOONロゴを表示"),, showLogoFlag));
	patchOptionsMenuItem.add(this.savedataRepairMenuItem = new KAGFlagMenuItem(this, __t("修復保存データモードを有効にする"),, savedataRepairFlag));

	(addOptionsMenuItems incontextof this)(patchOptionsMenuItem);
}

function addFullScreenMenu(displayMenu)
{
	displayMenu.add(new MenuItem(this, "-"));

	displayMenu.add(this.fullscreenMenu = new KAGMenuItem(this, __t("フルスクリーン時の拡大表示(&M)"), 0, void, false));

		fullscreenMenu.add(this.innerMagnifyMenuItem = new KAGMenuItem(this, __t("モニタ内にフィットさせる(&I)"), 1,
			onInnerMagnifyMenuItemClick, false));

		fullscreenMenu.add(this.outerMagnifyMenuItem = new KAGMenuItem(this, __t("モニタいっぱいに拡大する(&O)"), 1,
			onOuterMagnifyMenuItemClick, false));

		fullscreenMenu.add(this.noneMagnifyMenuItem = new KAGMenuItem(this, __t("拡大しない(&N)"), 1,
			onNoneMagnifyMenuItemClick, false));
}

function addWindowSizeMenu(displayMenu) {
	displayMenu.add(new MenuItem(this, "-"));

		displayMenu.add(this.windowSizeMenu = new KAGMenuItem(this, __t("ウィンドウ内部のサイズ指定(&S)"), 0, void, false));

@if(GAME_WOHN)
			windowSizeMenu.add(this.window1024MenuItem = new KAGMenuItem(this, "1024x576", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1024); }, false));
			this.window1024MenuItem.is_default_size = true;
@endif
@if(GAME_FATE||GAME_FHAT)
@if(!HD_MODE)
			windowSizeMenu.add(this.window800MenuItem = new KAGMenuItem(this, "800x600", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,800); }, false));
			this.window800MenuItem.is_default_size = true;
@endif
@if(HD_MODE)
			windowSizeMenu.add(this.window800MenuItem = new KAGMenuItem(this, "1.00x", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,800); }, false));
			this.window800MenuItem.is_default_size = true;
@endif
@endif

			windowSizeMenu.add(new MenuItem(this, "-"));

@if(GAME_WOHN)
			windowSizeMenu.add(this.window1280MenuItem = new KAGMenuItem(this, "1280x720", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1280); }, false));

			windowSizeMenu.add(this.window1440MenuItem = new KAGMenuItem(this, "1440x810", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1440); }, false));

			windowSizeMenu.add(this.window1600MenuItem = new KAGMenuItem(this, "1600x900", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1600); }, false));

			windowSizeMenu.add(this.window1920MenuItem = new KAGMenuItem(this, "1920x1080", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1920); }, false));

			windowSizeMenu.add(this.window640MenuItem = new KAGMenuItem(this, "640x360", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,640); }, false));

			windowSizeMenu.add(this.window800MenuItem = new KAGMenuItem(this, "800x450", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,800); }, false));
@endif
@if(GAME_FATE||GAME_FHAT)
@if(!HD_MODE)
			windowSizeMenu.add(this.window1024MenuItem = new KAGMenuItem(this, "1024x768", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1024); }, false));

			windowSizeMenu.add(this.window1280MenuItem = new KAGMenuItem(this, "1280x960", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1280); }, false));

			windowSizeMenu.add(this.window1440MenuItem = new KAGMenuItem(this, "1440x1080", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1440); }, false));

			windowSizeMenu.add(this.window640MenuItem = new KAGMenuItem(this, "640x480", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,640); }, false));
@endif
@if(HD_MODE)
			windowSizeMenu.add(this.window1024MenuItem = new KAGMenuItem(this, "1.28x", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1024); }, false));

			windowSizeMenu.add(this.window1280MenuItem = new KAGMenuItem(this, "1.60x", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1280); }, false));

			windowSizeMenu.add(this.window1440MenuItem = new KAGMenuItem(this, "1.80x", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,1440); }, false));

			windowSizeMenu.add(this.window640MenuItem = new KAGMenuItem(this, "0.80x", 1,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,640); }, false));
@endif
@endif

			windowSizeMenu.add(new MenuItem(this, "-"));

			windowSizeMenu.add(this.windowResizeableMenuItem = new KAGMenuItem(this, __t("サイズを固定する"), 0,
				function(sender) { sender.owner.onWindowSizeMenuItemClick(,0); }, false));
}

function addHdMenu(displayMenu) {
	var wideResolutions = %[ __t("ワイド(16:9)(&W)") => standardWideRatio];

	displayMenu.add(new MenuItem(this, "-"));

	displayMenu.add(this.qualityMenu = new KAGMenuItem(this, __t("画質(&Q)"), 0, void, false));
	this.qualityMenu.enabled = false;

		qualityMenu.add(this.lqMenuItem = new KAGMenuItem(this, __t("低い(&L)"), 1,
			function(sender) { onQualityMenuItemClick(sender,'low'); }, false));

		qualityMenu.add(this.hqMenuItem = new KAGMenuItem(this, __t("高い(&H)"), 1,
			function(sender) { onQualityMenuItemClick(sender,'high'); }, false));
		this.hqMenuItem.enabled = hdPatchExists;

	displayMenu.add(this.wideMenu = new KAGMenuItem(this, __t("アスペクト比(&A)"), 0, void, false));
	this.wideMenu.enabled = false;

		wideMenu.add(this.notWideMenuItem = new KAGMenuItem(this, __t("基準(4:3)(&S)"), 1,
			function(sender) { onWideMenuItemClick(sender,'standard'); }, false));

		wideMenu.add(this.wideMenuItem = new KAGMenuItem(this, __t("デスクトップと同じ(&M)"), 1,
			function(sender) { onWideMenuItemClick(sender,'wide'); }, false));

		var keys = Scripts.getObjectKeys(wideResolutions);
		for (var i=0; i<keys.count; i++) {
			var key = keys[i];
			var ratio = wideResolutions[key];
			var wideMenuItemName = "wideRatio"+key.replace(/[:&\() ]/g, "")+"MenuItem";
			this.wideMenu.add(this[wideMenuItemName] = new KAGMenuItem(this, key, 1, function(sender) { onWideMenuItemClick(sender, sender.ratio); }));
			this[wideMenuItemName].ratio = ratio;
			if (floatEquals(this.wideRatio, ratio)) {
				this[wideMenuItemName].checked = true;
			}
		}

@if(CROP_MODE)
		wideMenu.add(this.wideCroppedMenuItem = new KAGMenuItem(this, "Wide (&cropped)", 1,
			function(sender) { onWideMenuItemClick(sender,'standard',true); }, false));
@endif

	if (isHd) {
		this.hqMenuItem.checked = true;
	} else {
		this.lqMenuItem.checked = true;
	}
	if (wideScreen) {
		if (this.isAutoWide) {
			this.wideMenuItem.checked = true;
		}
	} else {
		this.notWideMenuItem.checked = true;
	}

@if(GAME_WOHN)
	var fpsLimitDefault = "60";
	var multiThreadDefault = 0;
@endif
@if(!GAME_WOHN)
	var fpsLimitDefault = "60";
	var multiThreadDefault = 1;
@endif

	var fpsLimitFlag = new GameFlag(this, this.sflags, "contfreq", fpsLimitDefault);
	var multiThreadDrawFlag = new GameFlag(this, this.sflags, "drawthread", multiThreadDefault);

	// Work around null pointer dereference when attempting to use Window.waitVSync on dev_multi_platform version of Kirikiri Z.
	var fpsLimitBeforeCallback = function(sender)
	{
		if (sender === sender.owner.fpsLimitVsyncMenuItem)
		{
			if (typeof(global.Canvas) === "Object")
			{
				return false;
			}
		}
		return true;
	};

	var fpsLimitCallback = function(sender)
	{
		if (sender.flag.value === "-1")
		{
			if (typeof(global.Canvas) !== "Object")
			{
				sender.owner.waitVSync = true;
			}
			global.System.setArgument("-contfreq", "0");
		}
		else
		{
			if (typeof(global.Canvas) !== "Object")
			{
				sender.owner.waitVSync = false;
			}
			global.System.setArgument("-contfreq", sender.flag.value);
		}
	};

	displayMenu.add(this.fpsLimitMenuItem = new KAGMenuItem(this, __t("最大フレームレート(&M)"), 0, void, false));
	this.fpsLimitMenuItem.add(this.fpsLimitVsyncMenuItem = new KAGFlagMenuItem(this, __t("垂直同期待ち(&V)"), 1, fpsLimitFlag, "-1"));
	this.fpsLimitMenuItem.add(this.fpsLimit00MenuItem = new KAGFlagMenuItem(this, __t("制限なし(&N)"), 1, fpsLimitFlag, "0"));
	this.fpsLimitMenuItem.add(this.fpsLimit60MenuItem = new KAGFlagMenuItem(this,   __t("&60フレーム/秒"),    1, fpsLimitFlag, "60"));
	this.fpsLimitMenuItem.add(this.fpsLimit30MenuItem = new KAGFlagMenuItem(this,   __t("&30フレーム/秒"),    1, fpsLimitFlag, "30"));
	this.fpsLimitMenuItem.add(this.fpsLimit15MenuItem = new KAGFlagMenuItem(this,   __t("&15フレーム/秒"),    1, fpsLimitFlag, "15"));
	this.fpsLimitVsyncMenuItem.afterCallback = fpsLimitCallback;
	this.fpsLimit00MenuItem.afterCallback = fpsLimitCallback;
	this.fpsLimit60MenuItem.afterCallback = fpsLimitCallback;
	this.fpsLimit30MenuItem.afterCallback = fpsLimitCallback;
	this.fpsLimit15MenuItem.afterCallback = fpsLimitCallback;
	this.fpsLimitVsyncMenuItem.beforeCallback = fpsLimitBeforeCallback;
	this.fpsLimit00MenuItem.beforeCallback = fpsLimitBeforeCallback;
	this.fpsLimit60MenuItem.beforeCallback = fpsLimitBeforeCallback;
	this.fpsLimit30MenuItem.beforeCallback = fpsLimitBeforeCallback;
	this.fpsLimit15MenuItem.beforeCallback = fpsLimitBeforeCallback;
	fpsLimitCallback(this.fpsLimitVsyncMenuItem);

	if (typeof(global.System.drawThreadNum) === "Integer")
	{
		var multiThreadDrawCallback = function(sender)
		{
			global.System.drawThreadNum = sender.flag.value;
		};

		displayMenu.add(this.multiThreadDrawMenuItem = new KAGMenuItem(this, __t("描画スレッド分割数(&N)"), 0, void, false));
		this.multiThreadDrawMenuItem.add(this.multiThreadDraw1MenuItem = new KAGFlagMenuItem(this, __t("無効：スレッド分割しない(&D)"), 1, multiThreadDrawFlag, 1));
		this.multiThreadDrawMenuItem.add(this.multiThreadDraw0MenuItem = new KAGFlagMenuItem(this, __t("自動：プロセッサ数で分割(&A)"), 1, multiThreadDrawFlag, 0));
		this.multiThreadDrawMenuItem.add(new MenuItem(this, "-"));
		this.multiThreadDrawMenuItem.add(this.multiThreadDraw2MenuItem = new KAGFlagMenuItem(this, __t("&2スレッド"), 1, multiThreadDrawFlag, 2));
		this.multiThreadDrawMenuItem.add(this.multiThreadDraw4MenuItem = new KAGFlagMenuItem(this, __t("&4スレッド"), 1, multiThreadDrawFlag, 4));
		this.multiThreadDrawMenuItem.add(this.multiThreadDraw8MenuItem = new KAGFlagMenuItem(this, __t("&8スレッド"), 1, multiThreadDrawFlag, 8));
		this.multiThreadDraw1MenuItem.afterCallback = multiThreadDrawCallback;
		this.multiThreadDraw0MenuItem.afterCallback = multiThreadDrawCallback;
		this.multiThreadDraw2MenuItem.afterCallback = multiThreadDrawCallback;
		this.multiThreadDraw4MenuItem.afterCallback = multiThreadDrawCallback;
		this.multiThreadDraw8MenuItem.afterCallback = multiThreadDrawCallback;
		multiThreadDrawCallback(this.multiThreadDraw1MenuItem);
	}
}

function addMessageWindowMenu(patchMenu)
{
	patchMenu.add(this.messageWindowMenuItem = new KAGMenuItem(this, __t("メッセージウィンドウ(&M)"), 0, void, false));
@if(GAME_FATE)
	var mobileWindowFlag = new GameFlag(this, this.sflags, "mobileWindow", false);
	messageWindowMenuItem.add(this.mobileMessageWindowMenuItem = new KAGFlagMenuItem(this, "&Mobile message window",, mobileWindowFlag,,true));
	this.mobileMessageWindowMenuItem.restartCondition = this.mobileMessageWindowMenuItem.onlyScenarioRestartCondition;
	var mobileBreakGlyphsFlag = new GameFlag(this, this.sflags, "mobileBreakGlyphs", false);
	messageWindowMenuItem.add(this.mobileBreakGlyphsMenuItem = new KAGFlagMenuItem(this, "Mobile text &break glyphs",, mobileBreakGlyphsFlag,,true));
	this.mobileBreakGlyphsMenuItem.restartCondition = this.mobileBreakGlyphsMenuItem.onlyScenarioRestartCondition;
@endif
	var wideStrechWindowFlag = new GameFlag(this, this.sflags, "wideStrechWindow", true);
	messageWindowMenuItem.add(this.wideMessageStretchMenuItem = new KAGFlagMenuItem(this, __t("ワイドモードで4:3のメッセージウィンドウ(&W)"),, inverseFlag(wideStrechWindowFlag),,true));
	this.wideMessageStretchMenuItem.restartCondition = this.wideMessageStretchMenuItem.onlyScenarioRestartCondition;
}
