
global.Window_hint_original = global.Window;
class Window_hint_override extends global.Window_hint_original
{
	function Window_hint_override()
	{
		super.Window(...);
	}

	function Window()
	{
		this.Window_hint_override(...);
	}

	var hintlayer = void;

	function initHintLayer()
	{
		this.hintlayer = new global.Layer(this, this.primaryLayer);
		{
			var l = this.hintlayer;
			l.visible = false;
			l.ignoreHintSensing = true;
			l.hitThreshold = 256;
			if (["Integer", "Real"].find(typeof(this.innerHeightScale)) !== -1) {
				l.font.height = global.Math.ceil(9 / global.Math.min(1, this.innerHeightScale)); // upscale font when using window size < x1.0
			} else {
				l.font.height = 9;
			}
			l.font.face = global.__s("MS UI Gothic", "hint_font_face");
		}

		// hintDelay = 500; // default
		// hintDelay = 0; // immediate
		// hintDelay = -1; // never
		// hintDelay = 1000; // slow
	}

	var hintHorizontalPadding = 4;
	var hintVerticalPadding = 6;
	var hintLineSpacing = 6;
	var tooltipBorderColor = 0xffffe1;
	var mouseCursorSize = 20;

	function onHintChanged(text, x, y, isshow)
	{
		if (this.hintlayer === void) {
			this.initHintLayer();
		}
		if (isshow) {
			var lines = text.split("\n");
			var longestLineIndex = 0;
			for (var i = 1, internal_forloop_count = lines.count; i < internal_forloop_count; i += 1) {
				if (lines[i].length > lines[longestLineIndex].length) {
					longestLineIndex = i;
				}
			}

			var fontHeight = this.hintlayer.font.height;
			var w = this.hintlayer.font.getTextWidth(lines[longestLineIndex]) + this.hintHorizontalPadding * 2;
			var h = fontHeight * lines.count + this.hintLineSpacing * (lines.count-1) + this.hintVerticalPadding * 2;
			this.hintlayer.setImageSize(w, h);
			this.hintlayer.setSizeToImageSize();

@if(HD_MODE)
			if (typeof this.fullScreened === "Integer" && fullScreened) {
				var windowToScreenRatio = (this.innerHeight*scaleFactor) / System.screenHeight;
				x -= (System.screenWidth - (this.innerWidth*global.get_wideScaleFactor() / windowToScreenRatio)) / 2;
				x *= windowToScreenRatio;
				y *= windowToScreenRatio;
			}

			x /= global.get_wideScaleFactor();
			y /= scaleFactor;
@endif
@if(ZOOM_WINDOW)
			if (["Integer", "Real"].find(typeof(this.innerHeightScale)) !== -1)
			{
				x /= this.innerWidthScale;
				y /= this.innerHeightScale;
				if ((x+w) > this.innerWidth/this.innerWidthScale) { x = this.innerWidth/this.innerWidthScale - w; }
				if ((y+this.mouseCursorSize+h) > this.innerHeight/this.innerHeightScale) { y = this.innerHeight/this.innerHeightScale - h - this.mouseCursorSize/this.innerHeightScale; }
				this.hintlayer.setPos(x, y + this.mouseCursorSize/this.innerHeightScale);
			}
			else
@endif
			{
				if ((x+w) > this.innerWidth) { x = this.innerWidth - w; }
				if ((y+this.mouseCursorSize+h) > this.innerHeight) { y = this.innerHeight - h - this.mouseCursorSize; }
				this.hintlayer.setPos(x, y + this.mouseCursorSize);
			}

			this.hintlayer.fillRect(0, 0, w, h, 0);
			this.hintlayer.colorRect(0, 0, w, h, global.clInfoBk, 196);

			this.hintlayer.colorRect(0,   0,   1, h, this.tooltipBorderColor);
			this.hintlayer.colorRect(0,   0,   w, 1, this.tooltipBorderColor);
			this.hintlayer.colorRect(w-1, 0,   1, h, this.tooltipBorderColor);
			this.hintlayer.colorRect(0,   h-1, w, 1, this.tooltipBorderColor);

			var lineY = this.hintVerticalPadding;
			for (var i = 0, internal_forloop_count = lines.count; i < internal_forloop_count; i += 1) {
				this.hintlayer.drawText(this.hintHorizontalPadding, lineY, lines[i], global.clInfoText, 220);
				lineY += fontHeight + this.hintLineSpacing;
			}
			this.hintlayer.visible = true;
			this.hintlayer.bringToFront();
		} else {
			this.hintlayer.visible = false;
		}
	}
}
global.Window = global.Window_hint_override;
