
global.Window_hint_original = global.Window;
class Window_hint_override extends global.Window_hint_original
{
	function Window_hint_override()
	{
		super.Window(...);
	}

	function Window()
	{
		this.Window_hint_override(...);
	}

	var hintlayer = void;

	function initHintLayer()
	{
		this.hintlayer = new global.Layer(this, this.primaryLayer);
		{
			var l = this.hintlayer;
			l.visible = false;
			l.ignoreHintSensing = true;
			l.hitThreshold = 256;
			l.font.height = 9;
			l.font.face = global.__s("MS UI Gothic", "hint_font_face");
		}

		// hintDelay = 500; // default
		// hintDelay = 0; // immediate
		// hintDelay = -1; // never
		// hintDelay = 1000; // slow
	}

	var hintHorizontalPadding = 4;
	var hintVerticalPadding = 6;
	var hintLineSpacing = 6;
	var tooltipBorderColor = 0xffffe1;
	var mouseCursorSize = 20;

	function onHintChanged(text, x, y, isshow)
	{
		if (this.hintlayer === void) {
			this.initHintLayer();
		}
		if (isshow) {
			var lines = text.split("\n");
			var longestLineIndex = 0;
			for (var i = 1, internal_forloop_count = lines.count; i < internal_forloop_count; i += 1) {
				if (lines[i].length > lines[longestLineIndex].length) {
					longestLineIndex = i;
				}
			}

			// -----------------------------------------------------------------------------------------------
			// Convert from screen space to base layer coordinates

			var clientRect = this.getClientRect();
			if (typeof this.fullScreened === "Integer" && this.fullScreened)
				clientRect.h = global.System.screenHeight;	// clientRect.h can be bigger than screenHeight when fullScreened, with some black border at the bottom, for unknown reasons.

			// Calculate the actually used (absolute) width/height the game content uses (so without black borders in fullscreen/maximized)
			var pxWidth_abs = global.Math.floor(clientRect.h * this.pxWidth * this.wideFactor / this.pxHeight) | 0;
			var pxHeight_abs = clientRect.h;
			//var z = clientRect.h / this.pxHeight;
			
			// If neccessary, recalculate to fit from inside
			if (pxWidth_abs > clientRect.w)
				{
				pxWidth_abs = clientRect.w;
				pxHeight_abs = global.Math.floor(clientRect.w * this.pxHeight / (this.pxWidth * this.wideFactor)) | 0;
				//z = clientRect.w / global.Math.floor(this.pxWidth * this.wideFactor);
				}
			
			// Calculate the offset introduced by the black borders in fullScreened/maximized mode. In windowed mode, these will be 0, of course.
			var widthOffsetAbs = (clientRect.w  - pxWidth_abs) / 2;
			var heightOffsetAbs = (clientRect.h - pxHeight_abs) / 2;

			var x = (x - widthOffsetAbs)  * this.pxWidth  / pxWidth_abs;
			var y = (y - heightOffsetAbs) * this.pxHeight / pxHeight_abs;

			// -----------------------------------------------------------------------------------------------
			// Recalculate size of font and tip box

			var fontSizeRatio = 1.0;

			fontSizeRatio /= global.Math.min(1, pxHeight_abs/this.pxHeight);	// If the absolute window size on screen gets small, the fontSizeRatio will increase, leading to a bigger font

			this.hintlayer.font.height = global.Math.ceil(9 * fontSizeRatio);	// "Ceil" because erring on the side of a bigger font is preferable

			var fontHeight = this.hintlayer.font.height;						// Retrieve it again - it might have been modified while setting!

			var w = this.hintlayer.font.getTextWidth(lines[longestLineIndex]) + this.hintHorizontalPadding * 2;
			var h = fontHeight * lines.count + this.hintLineSpacing * (lines.count-1) + this.hintVerticalPadding * 2;
			this.hintlayer.setImageSize(w, h);
			this.hintlayer.setSizeToImageSize();

			// -----------------------------------------------------------------------------------------------
			// Position tip layer

			var mouseCursorSizeAdjusted = this.mouseCursorSize * this.pxHeight / pxHeight_abs;
			
			if ((x + w) > this.pxWidth)
				x = this.pxWidth - w;

			var yTest = y + mouseCursorSizeAdjusted + h;

			if ((y + mouseCursorSizeAdjusted + h) > this.pxHeight)
				y = this.pxHeight - h - mouseCursorSizeAdjusted;

			x = (x*this.wideFactor) * (this.pxWidth - w) / ((this.pxWidth * this.wideFactor) - w);	// Inverse discrete transform to compensate from offset that will be introduced during setPos()

			this.hintlayer.setPos(x, y + mouseCursorSizeAdjusted);

			// -----------------------------------------------------------------------------------------------

			this.hintlayer.fillRect(0, 0, w, h, 0);
			this.hintlayer.colorRect(0, 0, w, h, global.clInfoBk, 196);

			this.hintlayer.colorRect(0,   0,   1, h, this.tooltipBorderColor);
			this.hintlayer.colorRect(0,   0,   w, 1, this.tooltipBorderColor);
			this.hintlayer.colorRect(w-1, 0,   1, h, this.tooltipBorderColor);
			this.hintlayer.colorRect(0,   h-1, w, 1, this.tooltipBorderColor);

			var lineY = this.hintVerticalPadding;
			for (var i = 0, internal_forloop_count = lines.count; i < internal_forloop_count; i += 1) {
				this.hintlayer.drawText(this.hintHorizontalPadding, lineY, lines[i], global.clInfoText, 220);
				lineY += fontHeight + this.hintLineSpacing;
			}
			this.hintlayer.visible = true;
			this.hintlayer.bringToFront();
		} else {
			this.hintlayer.visible = false;
		}
	}
}
global.Window = global.Window_hint_override;
