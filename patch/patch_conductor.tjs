
global.BaseConductor_patch_conductor_original = BaseConductor;
class BaseConductor_patch_conductor_override extends BaseConductor_patch_conductor_original
{
	function BaseConductor_patch_conductor_override()
	{
		super.BaseConductor(...);
	}
	function BaseConductor()
	{
		BaseConductor_patch_conductor_override(...);
	}

	var lines = [];
	function onScenarioLoad(name)
	{
		// Use Array.load for loading scenario
		this.lines.clear();
		this.lines.load(name);
		return this.lines.join("\n");
	}
}
global.BaseConductor = BaseConductor_patch_conductor_override;

global.patch_conductor_regex_1 = /\[line(?: len=)?([0-9]*?)\]/g;
global.patch_conductor_regex_2 = /\[block(?: len=)?([0-9]*?)\]/g;
global.patch_conductor_regex_3 = /(?:\[ruby char="(.*?)" text="(?:.*?)"]|\[ruby char=(.*?) text="(?:.*?)"]|\[ruby char="(.*?)" text=(?:.*?)]|\[ruby char=(.*?) text=(?:.*?)]|\[ruby text="(?:.*?)" char="(.*?)"]|\[ruby text="(?:.*?)" char=(.*?)]|\[ruby text=(?:.*?) char="(.*?)"]|\[ruby text=(?:.*?) char=(.*?)])/g;
global.patch_conductor_regex_4 = /(?:\["[a-zA-Z0-9_-]*"]|\['[a-zA-Z0-9_-]*']|\[[0-9]*]|\[\+?\w+\.\w+]|\[[^]]*])/g;

global.patch_conductor_regex_5 = /(?:(?<=^)|(?<=\n))(?:@|;|\*).*?(?=$|\n)/g;
global.patch_conductor_regex_6 = /(?s)(?:(?:^|\n)\[iscript\]|(?:^|\n)\[iscript\]\\(?:\n)|(?:^|\n)@iscript(?:\n)).*?(?:(?:^|\n)\[endscript\]|(?:^|\n)\[endscript\]\\(?:\n)|(?:^|\n)@endscript(?:\n))/g;

global.Conductor_patch_conductor_original = Conductor;

class Conductor_patch_conductor_override extends Conductor_patch_conductor_original
{
	function Conductor_patch_conductor_override()
	{
		super.Conductor(...);
	}

	// 覆盖Layer
	function Conductor()
	{
		Conductor_patch_conductor_override(...);
	}

	var dash_character = "―";
	var block_character = "■";
	var lines = [];
	var cleaned_lines = [];

	function replaceLine(text, reg, character=dash_character)
	{
		var results = reg.match(text);
		while(results.count == 2) {
			var count;
			if (results[1] == "") {
				count = 1;
			} else {
				count = results[1];
			}
			text = text.replace(reg, character.repeat(count));
			results = reg.match(text);
		}
		return text;
	}

	function replaceRubyChar(matcharr)
	{
		matcharr.erase(0);
		var x = matcharr.join("");
		if (+x != x)
		{
			return x;
		}
		return "";
	}

	function cleanLine(line=curLineStr)
	{
		if (isInQuiz())
		{
			return quizdata.question;
		}
		if (line.length === 0)
		{
			return "";
		}
		if (line[0] === "@" || line[0] === ";")
		{
			return "";
		}

		line = this.replaceLine(line, global.patch_conductor_regex_1);
		// Replace line-tags with dashes
		// Replace slightly-different-line-tags with dashes
		line = this.replaceLine(line, global.patch_conductor_regex_2, block_character);
		line = line.replace(global.patch_conductor_regex_3, this.replaceRubyChar);
		// Replace ruby tag containing text in char argument
		line = line.replace(global.patch_conductor_regex_4, "");
		// Remove arrays with string quotes indexes (not sure if possible but just in case)
		// Remove arrays with string apostrophes indexes (not sure if possible but just in case)
		// Remove arrays with number indexes (required or it will break when there is nested []s)
		// Remove arrays with variable index (i.e. [+mp.pos])
		// Remove tags
		return line;
	}

	function iscriptReplace(matcharr)
	{
		var newline_arrtmp = [];
		var matchstr = matcharr[0];
		var old_length = matchstr.length;
		matchstr = matchstr.replace(/\n/g, "");
		var diff_length = old_length - matchstr.length;
		newline_arrtmp.count = diff_length + 1;
		return newline_arrtmp.join("\n");
	}

	function cleanMultiLine(line)
	{
		line = line.replace(global.patch_conductor_regex_6, this.iscriptReplace);
		// Replace iscript/endscript tags
		line = line.replace(global.patch_conductor_regex_5, "");
		// Replace comments, labels, and command lines
		line = this.replaceLine(line, global.patch_conductor_regex_1);
		// Replace line-tags with dashes
		// Replace slightly-different-line-tags with dashes
		line = this.replaceLine(line, global.patch_conductor_regex_2, block_character);
		line = line.replace(global.patch_conductor_regex_3, this.replaceRubyChar);
		// Replace ruby tag containing text in char argument
		line = line.replace(global.patch_conductor_regex_4, "");
		// Remove arrays with string quotes indexes (not sure if possible but just in case)
		// Remove arrays with string apostrophes indexes (not sure if possible but just in case)
		// Remove arrays with number indexes (required or it will break when there is nested []s)
		// Remove arrays with variable index (i.e. [+mp.pos])
		// Remove tags
		return line;
	}

	function isInQuiz()
	{
		return curStorage == 'QuizSystem.ks' && owner.currentLabel == '*quiz_question';
	}

	var conductorPrevStorage;
	var conductorPrevLine;
	var lastQuizdataQuestion;
	var hasNewLineSinceLastCall = false;
	function isNewLine()
	{
		if (hasNewLineSinceLastCall)
		{
			hasNewLineSinceLastCall = false;
			return true;
		}

		return false;
	}

	var patch_conductor_temp_array = [];
	var patch_conductor_temp_array2 = [];
	function getNextTag()
	{
		var ret = super.getNextTag(...);
		if (this.processSpecialTags)
		{
			var temp_text = this.patch_conductor_temp_array2;
			temp_text.clear();
			var save_curStorage = this.curStorage;
			var save_curLine = this.curLine;
			while (ret !== void && ret.tagname === "ch")
			{
				patch_conductor_temp_array.assign(ret);
				if (patch_conductor_temp_array.count === 4)
				{
					temp_text.add(ret.text);
					ret = super.getNextTag(...);
					continue;
				}
				break;
			}
			if (temp_text.count > 0)
			{
				var ret2 = %[];
				ret2.__patch_conductor_storage = save_curStorage;
				ret2.__patch_conductor_line = save_curLine;
				ret2.tagname = "ch_patch_conductor_split";
				ret2.text = temp_text.join("");
				this.pendings.insert(0, ret2);
			}
		}
		if (typeof(ret) === "Object")
		{
			ret.__patch_conductor_storage = this.curStorage;
			ret.__patch_conductor_line = this.curLine;
		}
		return ret;
	}

	function onTag(elm)
	{
		if (elm.tagname === "ch_patch_conductor_split")
		{
			var text = elm.text;
			if (typeof(this.owner.onConductorPreprocessCh) === "Object")
			{
				text = this.owner.onConductorPreprocessCh(text, this);
			}
			var text_sz = 0;
			if (typeof(text) === "Object")
			{
				text_sz = text.count;
			}
			else
			{
				text_sz = text.length;
			}
			for (var i = text_sz - 1; i >= 0; i -= 1)
			{
				var ret2 = %[];
				ret2.__patch_conductor_storage = elm.__patch_conductor_storage;
				ret2.__patch_conductor_line = elm.__patch_conductor_line;
				ret2.tagname = "ch";
				ret2.text = text[i];
				this.pendings.insert(0, ret2);
			}
			return 0;
		}
		if (elm.tagname === "ch" && elm.__patch_conductor_storage !== void && elm.__patch_conductor_line !== void)
		{
			if (elm.__patch_conductor_storage != conductorPrevStorage || elm.__patch_conductor_line != conductorPrevLine || (isInQuiz() && lastQuizdataQuestion != quizdata.question))
			{
				{
					hasNewLineSinceLastCall = true;
					conductorPrevStorage = elm.__patch_conductor_storage;
					conductorPrevLine = elm.__patch_conductor_line;
					if (isInQuiz() && lastQuizdataQuestion != quizdata.question) {
						lastQuizdataQuestion = quizdata.question;
					}
				}
			}
		}
		return super.onTag(...);
	}

	function onScenarioLoad(name)
	{
		conductorPrevStorage = void;
		conductorPrevLine = void;
		lastQuizdataQuestion = void;
		super.onScenarioLoad(...);
		// Use Array.load for loading scenario
		this.lines.clear();
		this.lines.load(name);
		var joined_lines = this.lines.join("\n");
		var joined_cleaned_lines = this.cleanMultiLine(joined_lines);
		if (typeof(this.owner.replace_characters_regex) === "Object")
		{
			joined_cleaned_lines = this.owner.replace_characters_regex(joined_cleaned_lines);
		}
		this.cleaned_lines = joined_cleaned_lines.split("\n");
		if (typeof(this.owner.onConductorScenarioPreLoad) === "Object")
		{
			this.owner.onConductorScenarioPreLoad(joined_cleaned_lines, this);
		}
		return joined_lines;
	}
}

global.Conductor = Conductor_patch_conductor_override;
