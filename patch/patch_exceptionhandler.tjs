
global.get_exception_message = function(e)
{
	var exception_message = "Unknown error";
	if (typeof(e) === "Object" && isvalid(e))
	{
		if (typeof(e.message) === "String")
		{
			exception_message = e.message;
		}
	}
	return exception_message;
};
global.get_trace_string = function(e)
{
	var trace_string = "";
	if (typeof(e) === "Object" && isvalid(e))
	{
		if (typeof(e.trace) === "String")
		{
			trace_string = e.trace;
		}
	}
	return trace_string;
};
global.print_exception = function(e, interim_trace)
{
	var exception_message = global.get_exception_message(e);
	var trace_string = global.get_trace_string(e);
	dm("Exception: " + exception_message);
	if (trace_string !== "")
	{
		dm("Trace: " + trace_string);
	}
	if (typeof(interim_trace) === "String")
	{
		dm(("The above exception is only for %s.").sprintf(interim_trace));
		dm("The correct exception you need to submit is located further back.");
	}
};

global.patch_exception_exception_files = [];
global.get_exception_files = function()
{
	var exception_files = global.patch_exception_exception_files;
	exception_files.clear();

	// Determine where the log is placed
	var logpath = "";
	var logname = "krkr.console.log";
	var hwexceptpath = "";
	var hwexceptname = "hwexcept.log";
	if (typeof(global.Debug) === "Object" && typeof(global.Debug.logLocation) === "String")
	{
		logpath = global.Debug.logLocation;
	}
	else
	{
		logpath = System.exePath;
		logname = Storages.extractStorageName(System.exeName) + ".console.log";
	}
	if (typeof(global.System) === "Object" && typeof(global.System.dataPath) === "String")
	{
		hwexceptpath = global.System.dataPath;
	}
	else
	{
		hwexceptpath = System.exePath;
	}
	if (logpath !== "")
	{
		logpath += "/";
		logpath = Storages.getFullPath(logpath);
	}
	if (hwexceptpath !== "")
	{
		hwexceptpath += "/";
		hwexceptpath = Storages.getFullPath(hwexceptpath);
	}

	// Move the old log to another location
	try
	{
		if (logpath !== "")
		{
			if (typeof(Storages.isExistentStorageNoSearchNoNormalize) === "Object")
			{
				if (Storages.isExistentStorageNoSearchNoNormalize(logpath + logname))
				{
					if (typeof(Storages.getTime) === "Object")
					{
						var logtime = Storages.getTime(logpath + logname);
						if (typeof(logtime) === "Object")
						{
							var date = logtime.mtime;
							if (typeof(Storages.moveFile) === "Object")
							{
								Storages.moveFile(logpath + logname, logpath + ("krkr-%04d%02d%02d%02d%02d%02d.console.log").sprintf(date.getYear(), date.getMonth(), date.getDay(), date.getHours(), date.getMinutes(), date.getSeconds()));
							}
						}
					}
				}
			}
		}
	}
	catch (e)
	{
		print_exception(e, "moving the log file");
	}

	//	時刻取得
	var date = new Date();
	var now;
	with(date)
		now = "%04d%02d%02d%02d%02d%02d".sprintf(.getYear(), .getMonth(), .getDay(), .getHours(), .getMinutes(), .getSeconds());

	//	セーブデータディレクトリの存在チェックと作成
	var dir;
	var dir_unarchived;
	var saveDataLocation;
	try
	{
		if (typeof(global.kag) === "Object" && isvalid(global.kag) && typeof(global.kag.saveDataLocation) === "String")
		{
			saveDataLocation = global.kag.saveDataLocation;
		}
	}
	catch (e)
	{
		print_exception(e, "retrieving the savedata location");
	}
	if (typeof(saveDataLocation) === "String")
	{
		var success = true;
		dir	= saveDataLocation;
		if (!endsWith("/", dir)) {
			dir += "/";
		}
		if (success) try
		{
			Storages.createDirectory(dir) if !Storages.isExistentDirectory(dir);
		}
		catch (e)
		{
			success = false;
			print_exception(e, "creating the log directory");
		}

		//	exceptedディレクトリの存在チェックと作成
		dir	+= "excepted/";
		if (success) try
		{
			Storages.createDirectory(dir) if !Storages.isExistentDirectory(dir);
		}
		catch (e)
		{
			success = false;	//	致命的エラー
			print_exception(e, "creating the log directory");
		}

		//	今回のディレクトリ名決定して、作成する
		dir	+= now + "/";
		if (success) try
		{
			Storages.createDirectory(dir) if !Storages.isExistentDirectory(dir);
		}
		catch (e)
		{
			success = false;
			print_exception(e, "creating the log directory");
		}
		dir_unarchived = dir + "unarchived/";
		if (success) try
		{
			Storages.createDirectory(dir_unarchived) if !Storages.isExistentDirectory(dir_unarchived);
		}
		catch (e)
		{
			success = false;
			print_exception(e, "creating the unarchived log directory");
		}

		if (success) try
		{
@if(!KIRIKIROID)
			if (typeof(global.Debug) === "Object" && typeof(global.Debug.logLocation) === "String")
			{
				if (typeof(global.System.setArgument) === "Object")
				{
					global.System.setArgument("-forcelog", "yes");
				}
				global.Debug.logLocation = dir_unarchived;
				Debug.startLogToFile(true);
				if (Storages.isExistentStorage(dir_unarchived + logname))
				{
					exception_files.add(dir_unarchived + logname);
				}
				if (!global.forceLog)
				{
					var arcdelim = System.getArgument("-arcdelim");
					if (!arcdelim)
					{
						arcdelim = ">";
					}
					// global.Debug.logLocation will be cleared if there is an archive delimiter in the path
					global.Debug.logLocation = "__this_path_should_be_fake__" + arcdelim;
				}
			}
			else if (logpath !== "" && Storages.isExistentStorage(logpath + logname))
			{
				if (typeof(Storages.exportFile) === "Object")
				{
					Debug.startLogToFile(true);
					var log_file = dir_unarchived + "krkr.console.log";
					Storages.exportFile(logpath + logname, log_file);
					exception_files.add(log_file);
				}
			}
@endif
@if(KIRIKIROID)
			Debug.startLogToFile();
@endif
		}
		catch (e)
		{
			print_exception(e, "copying the log file");
		}

		if (success) try
		{
			if (Storages.isExistentStorage(hwexceptpath + hwexceptname))
			{
				if (typeof(Storages.moveFile) === "Object")
				{
					var hwexcept_file = dir_unarchived + "hwexcept.log";
					Storages.moveFile(hwexceptpath + hwexceptname, hwexcept_file);
					exception_files.add(hwexcept_file);
				}
			}
		}
		catch (e)
		{
			print_exception(e, "moving the log file");
		}

		if (success) try
		{
			if (typeof(Debug.getLastLog) === "Object")
			{
				var last_log_file = dir_unarchived + "last_log.console.log";
				var arr = [Debug.getLastLog()];
				arr.save(last_log_file, "z");
				exception_files.add(last_log_file);
			}
		}
		catch (e)
		{
			print_exception(e, "saving the last lines of the log file");
		}

		if (success && typeof(global.kag.dataName) === "String")
		{
@if(0)
			// XXX: File handles leak in GCC compiled Kirikiri in "b" mode
			var last_savedata_mode;
			if (typeof(global.kag.saveDataMode) === "String")
			{
				last_savedata_mode = global.kag.saveDataMode;
				// Should be more efficient in terms of compression
				global.kag.saveDataMode = "b";
			}
@endif
			var lastdataname = global.kag.dataName;
			global.kag.dataName = dir_unarchived.substring(saveDataLocation.length, dir_unarchived.length - saveDataLocation.length) + "excepteddata";
			try
			{
				var ticketfile;
				if (typeof(global.TicketFileName) === "String")
				{
					ticketfile = TicketFileName + CurrentTicketNo + ".bmp";
				}
				if (typeof(global.makeTicketFile) === "String")
				{
					var ticket_file = dir_unarchived + ticketfile;
					global.makeTicketFile(ticket_file);
					if (Storages.isExistentStorage(ticket_file))
					{
						exception_files.add(ticket_file);
					}
				}
			}
			catch (e)
			{
				print_exception(e, "creating the ticket file");
			}
			try
			{
				if (global.kag.storeEnabled)
				{
					var save_file = dir_unarchived + "data.kdt";
					global.kag.saveBookMarkToFile(save_file);
					if (Storages.isExistentStorage(save_file))
					{
						exception_files.add(save_file);
					}
				}
			}
			catch (e)
			{
				print_exception(e, "saving the bookmark file");
			}
			try
			{
				global.kag.saveSystemVariables();
				var excepted_data_sc = dir_unarchived + "excepteddata" + "sc.ksd";
				if (Storages.isExistentStorage(excepted_data_sc))
				{
					exception_files.add(excepted_data_sc);
				}
				var excepted_data_su = dir_unarchived + "excepteddata" + "su.ksd";
				if (Storages.isExistentStorage(excepted_data_su))
				{
					exception_files.add(excepted_data_su);
				}
			}
			catch (e)
			{
				print_exception(e, "saving the system variable file");
			}
@if(0)
			if (typeof(last_savedata_mode) === "String")
			{
				global.kag.saveDataMode = last_savedata_mode;
			}
@endif
			global.kag.dataName = lastdataname;
		}

		if (success) try
		{
			if (typeof(global.paths_base_dirlist) === "Object")
			{
				var structure = global.paths_base_dirlist;
				var filename = dir_unarchived + "paths_base_dirlist.ksc";
				(Dictionary.saveStruct incontextof structure)(filename, "z");
				exception_files.add(filename);
			}
		}
		catch (e)
		{
			print_exception(e, "saving the directory listing");
		}

		if (success) try
		{
			if (typeof(global.paths_base_dirlistex) === "Object")
			{
				var structure = global.paths_base_dirlistex;
				var filename = dir_unarchived + "paths_base_dirlistex.ksc";
				(Dictionary.saveStruct incontextof structure)(filename, "z");
				exception_files.add(filename);
			}
		}
		catch (e)
		{
			print_exception(e, "saving the extended directory listing");
		}

		if (success) try
		{
			if (typeof(global.System.getDxDiag) === "Object")
			{
				var structure = global.System.getDxDiag();
				var filename = dir_unarchived + "dxdiag.ksc";
				(Dictionary.saveStruct incontextof structure)(filename, "z");
				exception_files.add(filename);
			}
		}
		catch (e)
		{
			print_exception(e, "saving the DxDiag information");
		}
	}

	if (exception_files.count > 0 && typeof(global.Zip) === "Object") try
	{
		var exception_archive = dir + "exception.zip";
		// 1: overwrite
		var zip = new Zip();
		var success = true;
		zip.open(exception_archive, 1);
		for (var i = 0, internal_forloop_count = exception_files.count; i < internal_forloop_count; i += 1)
		{
			var file = exception_files[i];
			if (!zip.add(file, file.substring(dir_unarchived.length, file.length - dir_unarchived.length), void, void, void))
			{
				success = false;
				break;
			}
		}
		zip.close();
		if (success)
		{
			var delete_unarchived_success = true;
			for (var i = 0, internal_forloop_count = exception_files.count; i < internal_forloop_count; i += 1)
			{
				var file = exception_files[i];
				// Deletion may not succeed because file handles are leaking
				if (!Storages.deleteFile(file))
				{
					delete_unarchived_success = false;
				}
			}
			if (delete_unarchived_success)
			{
				Storages.removeDirectory(dir_unarchived);
			}
			exception_files.clear();
			exception_files.add(exception_archive);
		}
	}
	catch (e)
	{
		print_exception(e, "archiving the exception files");
	}

	return exception_files;
};

global.save_troubleshooting_data_and_open_folder_location = function()
{
	var exception_files = global.get_exception_files();
	if (exception_files.count > 0)
	{
		var dir = Storages.extractStoragePath(exception_files[0]);
		if (typeof(dir) === "String" && dir !== "")
		{
			var localpath = Storages.getLocalName(dir);
			if (localpath !== "")
			{
				System.shellExecute(("\"%s\"").sprintf(localpath));
			}
		}
	}
};

/*----------------------------------------------------------------------------/
/	例外の最終受付
/		例外が発生したら、セーブデータ下に"excepted/YYMMDDhhmmss/"ディレクトリを
/		作成して、状態を保存する
/----------------------------------------------------------------------------*/
global.exceptionOccured	= false;	//	例外が発生したか？
System.exceptionHandler = function(e)
{
	var print_exception = global.print_exception;
	print_exception(e);

	var exception_files = global.get_exception_files();
	var exception_information_in_clipboard = false;

	//	フルスクリーンモードで実行中だったら、ウィンドウモードに切り替える

	if (typeof(global.kag) === "Object" && isvalid(global.kag) && typeof(global.kag.fullScreened) === "Integer" && global.kag.fullScreened && typeof(global.kag.onWindowedMenuItemClick) === "Object" && isvalid(global.kag.onWindowedMenuItemClick))
	{
		global.kag.onWindowedMenuItemClick();
	}

	//	"script exception"が発生したら、処理しない
	var exception_message = global.get_exception_message(e);
	var trace_string = global.get_trace_string(e);

@if(0)
	if (e instanceof "ConductorException" && typeof(global.kag) === "Object" && isvalid(global.kag) && typeof(global.kag.mainWindow) === "Object" && isvalid(global.kag.mainWindow) && global.kag === global.kag.mainWindow)
		return false;
@endif

	//	イベント停止
	var ed	= System.eventDisabled;
	System.eventDisabled	= true;
	var msg_components = [];

	if (exception_files.count > 0)
	{
		msg_components.add(__("このダイアログボックスのスクリーンショットは送信しないでください。"));
		msg_components.add(__("次のファイルには、保存データと例外情報が含まれています："));
		for (var i = 0, internal_forloop_count = exception_files.count; i < internal_forloop_count; i += 1)
		{
			msg_components.add(__("     ・%s").sprintf(exception_files[i]));
		}
		msg_components.add(__("※情報が不十分ですと回答できませんので、必ずファイル・情報をご提供ください。"));
		if (exception_information_in_clipboard)
		{
			msg_components.add(__("上記のファイルの内容はクリップボードに配置されているので、サポートフォーラムのスレッドに貼り付けてください。"));
		}
	}
	if (!(e instanceof "ConductorException"))
	{
		msg_components.add(__("アンチウィルスソフトその他の常駐アプリケーションを終了してゲームを再起動することでエラーを回避できる可能性があります。"));
	}
	msg_components.add(__("上記のファイルを添えて、いつどのようにエラーが発生したかを説明したサポート掲示板にご連絡ください。"));
	msg_components.add(__("サポート掲示板: %s").sprintf(global.PatchInfoURL));
	msg_components.add("--------------------------------------------------------------------------------");
	if (e instanceof "ConductorException")
	{
		msg_components.add(__("下記のスクリプトエラーが発生しました。"));
	}
	else
	{
		msg_components.add(__("下記の例外が発生しました。"));
	}
	msg_components.add("--------------------------------------------------------------------------------");
	msg_components.add(exception_message);
	msg_components.add("--------------------------------------------------------------------------------");
	if (trace_string !== "")
	{
		msg_components.add(__("-- trace --"));
		msg_components.add(trace_string);
	}

@if(GAME_FATE)
	//	ゲーム本編中なら、セーブしておく
	if (typeof(global.kag) === "Object" && isvalid(global.kag) && typeof(global.kag.pcflags) === "Object" && isvalid(global.kag.pcflags) && global.kag.pcflags.currentPageName !== "タイトル")
	{
		try {
			//	空いているセーブ領域を探して、セーブする
			msg_components.add("--------------------------------------------------------------------------------");
			var win = global.kag;
			var saved	= false;
			var quickcount	= 10;
			var normalcount	= 300;
			var no;
			var key	= "(例外からの復帰用データ)";
			for (var i = 0; i < quickcount; i += 1)
			{
				no = win.numBookMarks - 1 - i;
				if(win.getBookMarkDate(no)=="" || win.getBookMarkPageName(no).substr(0, key.length)==key)
				{
					//	クイックセーブに保存
					win.bookMarkNames[no]	= key+win.getBookMarkPageName(no);
					win.saveBookMark(no);
					saved	= true;
					msg_components.add(__("現在の状況をクイックセーブの%s番目に保存しました。").sprintf(i));
					msg_components.add(__("セーブデータのファイル名は、\n「%s」\nとなります。").sprintf(Storages.getLocalName(Storages.getFullPath(win.getBookMarkFileNameAtNum(no)))));
					break;
				}
			}
			if(!saved)
			{
				for (var i = 0; i < normalcount; i += 1)
				{
					no	= i;
					if(win.getBookMarkDate(no)=="")
					{
						//	通常のセーブ領域に保存
						win.scflags.bookMarkComments[no]	= __("例外からの復帰用データ");
						win.saveBookMark(no);
						var pos = global.kag.sflags.convertSaveNoToFileNo[no];
						saved	= true;
						msg_components.add(__("現在の状況をセーブメニューの「%sページ %s行 %s列目」に保存しました。").sprintf(pos\20+1, pos%20\5+1, pos%5+1));
						msg_components.add(__("セーブデータのファイル名は、\n「%s」\nとなります。").sprintf(Storages.getLocalName(Storages.getFullPath(win.getBookMarkFileNameAtNum(no)))));
						break;
					}
				}
				if(!saved)
				{
					//	セーブデータが一杯なので、保存先を選んでもらう
					msg_components.add(__("セーブデータに空きがありません。"));
					msg_components.add(__("セーブメニューを開きますので、適当な場所に保存してください。"));
					global.shortcut_object.show("save");	//	セーブメニューを開く
				}
			}
		}
		catch (e)
		{
			print_exception(e, "auto-saving the current state");
		}
	}
@endif
	if (e instanceof "ConductorException")
	{
		msg_components.add("--------------------------------------------------------------------------------");
		msg_components.add(__("Pキーでタイトルへ戻るか、通常の手順で終了してください。"));
	}

	if (System.getArgument('-noshowexceptiondialog') === void)
	{
		System.inform(msg_components.join("\n"));
	}

	//	イベント再開
	System.eventDisabled	= ed;
	exceptionOccured	= true;	//	例外が発生しているので、終了時点での確認→データ保存を行わない

@if(!KIRIKIROID)
	if (!global.devMode && !global.devMode2 || (System.getArgument('-openlogdironerror') !== void || System.getArgument('-openpatchinfourlonerror') !== void))
	{
		if (System.getArgument('-openlogdironerror') !== "no" && !exception_information_in_clipboard)
		{
			if (exception_files.count > 0)
			{
				var dir = Storages.extractStoragePath(exception_files[0]);
				if (typeof(dir) === "String" && dir !== "")
				{
					var localpath = Storages.getLocalName(dir);
					if (localpath !== "")
					{
						System.shellExecute(("\"%s\"").sprintf(localpath));
					}
				}
			}
		}

		if (System.getArgument('-openpatchinfourlonerror') !== "no" && typeof(global.PatchInfoURL) === "String")
		{
			System.shellExecute(global.PatchInfoURL);
		}
	}

	if ((typeof(global.kag) !== "Object") || (typeof(global.kag) === "Object" && !isvalid(global.kag)) || (typeof(global.kag) === "Object" && isvalid(global.kag) && typeof(global.kag.visible) !== "Integer") || (typeof(global.kag) === "Object" && isvalid(global.kag) && typeof(global.kag.visible) === "Integer" && global.kag.visible === false) || System.getArgument('-quitonexception') !== void)
	{
		System.exit(127);
	}
@endif

	return true;	//	停止
};
