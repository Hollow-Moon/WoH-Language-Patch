
var hdExtension = ".webp";
@if(GAME_FATE)
var upscaledFactor = 1.6;
@endif
@if(GAME_FHAT||GAME_WOHN)
var upscaledFactor = 2;
@endif

var originalToHdName = %[
	"01空・雨(夜)" => "01空・雨（夜）", // Different parentheses
	"fate" => "fate2",
	"el_タイガー0段階" => "30_tiger_00a",
	"el_タイガー1段階" => "30_tiger_01a",
	"el_タイガー2段階" => "30_tiger_02a",
	"el_タイガー3段階" => "30_tiger_03a",
	"el_タイガー4段階" => "30_tiger_04a",
];
var messageLayerImages = ["tw_ノーマル(薄い)", "tw_ノーマル(通常)", "tw_ノーマル(濃い)", "tw_たいがー(通常)", "tw_たいがー(模様)"];
var messageBreakImages = ["linebreak_a", "pagebreak_a"];

var imageNameToNumberOfImages = %[
	"pt_number" => 10,
@if(GAME_FATE||GAME_FHAT)
	"linebreak_a" => 21,
@endif
@if(GAME_WOHN)
	"linebreak_a" => 40,
@endif
	"pagebreak_a" => 16,
	"pagebreak_a.png" => 21, // 21 in low res

	// scrollbar
	"scroll_basetop" => 4,
	"scroll_base" => 4,
	"scroll_basebottom" => 4,
	"scroll_slidertop" => 4,
	"scroll_slidertop4fnt" => 4,
	"scroll_slider" => 4,
	"scroll_slider4fnt" => 4,
	"scroll_sliderbottom" => 4,
	"scroll_sliderbottom4fnt" => 4,

	"voicescroll_basetop" => 4,
	"voicescroll_base" => 4,
	"voicescroll_basebottom" => 4,
	"voicescroll_slidertop" => 4,
	"voicescroll_slider" => 4,
	"voicescroll_sliderbottom" => 4,

	// horizontal scrollbar
	"scroll_top_horizontal" => 4,
	"scroll_base_horizontal" => 4,
	"scroll_bottom_horizontal" => 4,

	// music menu scrollbar
	"music_tab_t" => 4,
	"music_tab_c" => 4,
	"music_tab_b" => 4,

	"qs_f1" => 2,
	"qs_f2" => 2,
	"qs_f3" => 2,
	"qs_f4" => 2,
	"qs_f5" => 2,
	"qs_f6" => 2,
	"qs_f7" => 2,
	"qs_f8" => 2,
	"qs_f9" => 2,
	"qs_f10" => 2,
	"qs_f11" => 2,
	"qs_f12" => 2,

	"wp_選択バー" => 2,

	"fnt_opacnum" => 10,
	"scroll_slidertop4fnt" => 4,
	"scroll_slider4fnt" => 4,
	"scroll_sliderbottom4fnt" => 4,

	"scroll_slidertop4opac" => 4,
	"scroll_sliderbottom4opac" => 4,
	"scroll_slider4opac" => 4
];

var fixedBgImages = [
	"black" // Sometimes used for letter-boxing, in which case it needs a special treatment.
];
var movingBgImages = [
	"c_cs16(03落石)", "cs29アンリマユ崩壊(01落石大)",
	"csラストep04(雲01)", "csラストep04(雲02)", "csラストep04(雲03)", "csラストep04(雲04)"
];
var bottomImages = [
	"cs29アンリマユ崩壊(04手前岩盤・右)" // A bottom aligned image moving from negative to positive top position, in which case it needs a special treatment.
];

function round(v)
{
	return int(v + (v<0 ? -0.5 : 0.5));
}

function transformDiscrete(v, scale)
{
@if(SCALE_USING_FLOATING_POINT)
	// To avoids rounding errors when summing, rounding should occur only after scaling.
	// Using "round" is probably better than "int" but it causes tearing in the yes/no button when you hover over it.
	return int(v * scale) / scale;
@endif
@if(!SCALE_USING_FLOATING_POINT)
	return v | 0;
@endif
}

global.Layer_patch_hd_layer_original	= Layer;
class Layer_patch_hd_layer_override extends Layer_patch_hd_layer_original
{
	var imageStorage = void;
	var isHd = false;

	var originalLeft = 0;
	var originalTop = 0;
	var originalImageLeft = 0;
	var originalImageTop = 0;
	var originalWidth = 32;
	var originalHeight = 32;
	var originalImageWidth = 32;
	var originalImageHeight = 32;
	var originalClipLeft = 0;
	var originalClipTop = 0;
	var originalClipWidth = void;
	var originalClipHeight = void;
	var originalAttentionLeft = 0;
	var originalAttentionTop = 0;

	var isbg = false;
	var fullScreenBg = false; // For bg images that occupy the whole screen.
	var fixedbg = false; // Used for bg images that are fixed.
	var movingbg = false; // Used for fixed bg images that move.
	var bottomImage = false; // Used for images that are bottom aligned (most cases are handled automatically - this is for exceptions).
	var stretch = void;
	var isMask = false; // Set to true to suppress automatic determination of isbg.
	var isThumbnail = false;
	var isTicketThumbnail = false;

	var _isFixedPosition = void;
	var _horizontalAlignment = 0.5;
	var _verticalAlignment = 0;

	var numberOfImages = 1;

	var absoluteMode = false;

	function onClick_patch_hd_layer_override(x, y)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
@endif
		this.onClick_patch_hd_layer_original(x, y);
	}

	property onClick_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onClick_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onClick_patch_hd_layer_original = v;
		}
	}

	function onDoubleClick_patch_hd_layer_override(x, y)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
@endif
		this.onDoubleClick_patch_hd_layer_original(x, y);
	}

	property onDoubleClick_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onDoubleClick_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onDoubleClick_patch_hd_layer_original = v;
		}
	}

	function onMouseDown_patch_hd_layer_override(x, y, button, shift)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
@endif
		this.onMouseDown_patch_hd_layer_original(x, y, button, shift);
	}

	property onMouseDown_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onMouseDown_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onMouseDown_patch_hd_layer_original = v;
		}
	}

	function onMouseUp_patch_hd_layer_override(x, y, button, shift)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
@endif
		this.onMouseUp_patch_hd_layer_original(x, y, button, shift);
	}

	property onMouseUp_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onMouseUp_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onMouseUp_patch_hd_layer_original = v;
		}
	}

	function onMouseMove_patch_hd_layer_override(x, y, shift)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
@endif
		this.onMouseMove_patch_hd_layer_original(x, y, shift);
	}

	property onMouseMove_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onMouseMove_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onMouseMove_patch_hd_layer_original = v;
		}
	}

	function onMouseWheel_patch_hd_layer_override(shift, delta, x, y)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
@endif
		this.onMouseWheel_patch_hd_layer_original(shift, delta, x, y);
	}

	property onMouseWheel_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onMouseWheel_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onMouseWheel_patch_hd_layer_original = v;
		}
	}

	function onHitTest_patch_hd_layer_override(x, y, hit)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
@endif
		this.onHitTest_patch_hd_layer_original(x, y, hit);
	}

	property onHitTest_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onHitTest_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onHitTest_patch_hd_layer_original = v;
		}
	}

	function onTouchDown_patch_hd_layer_override(x, y, cx, cy, id)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
		cx /= wideScaleFactor;
		cy /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
		cx \= wideScaleFactor;
		cy \= scaleFactor;
@endif
		this.onTouchDown_patch_hd_layer_original(x, y, cx, cy, id);
	}

	property onTouchDown_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onTouchDown_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onTouchDown_patch_hd_layer_original = v;
		}
	}

	function onTouchUp_patch_hd_layer_override(x, y, cx, cy, id)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
		cx /= wideScaleFactor;
		cy /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
		cx \= wideScaleFactor;
		cy \= scaleFactor;
@endif
		this.onTouchUp_patch_hd_layer_original(x, y, cx, cy, id);
	}

	property onTouchUp_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onTouchUp_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onTouchUp_patch_hd_layer_original = v;
		}
	}

	function onTouchMove_patch_hd_layer_override(x, y, cx, cy, id)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
		cx /= wideScaleFactor;
		cy /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
		cx \= wideScaleFactor;
		cy \= scaleFactor;
@endif
		this.onTouchMove_patch_hd_layer_original(x, y, cx, cy, id);
	}

	property onTouchMove_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onTouchMove_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onTouchMove_patch_hd_layer_original = v;
		}
	}

	function onTouchScaling_patch_hd_layer_override(startdistance, currentdistance, cx, cy, flag)
	{
		// XXX: startdistance and currentdistance need to be interpolated
@if(SCALE_USING_FLOATING_POINT)
		cx /= wideScaleFactor;
		cy /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		cx \= wideScaleFactor;
		cy \= scaleFactor;
@endif
		this.onTouchScaling_patch_hd_layer_original(startdistance, currentdistance, cx, cy, flag);
	}

	property onTouchScaling_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onTouchScaling_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onTouchScaling_patch_hd_layer_original = v;
		}
	}

	function onTouchRotate_patch_hd_layer_override(startangle, currentangle, distance, cx, cy, flag)
	{
		// XXX: distance need to be interpolated
@if(SCALE_USING_FLOATING_POINT)
		cx /= wideScaleFactor;
		cy /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		cx \= wideScaleFactor;
		cy \= scaleFactor;
@endif
		this.onTouchRotate_patch_hd_layer_original(startangle, currentangle, distance, cx, cy, flag);
	}

	property onTouchRotate_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onTouchRotate_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onTouchRotate_patch_hd_layer_original = v;
		}
	}

	function patch_hd_layer_setup_event_shims()
	{
		if (typeof(this.onClick) === "Object")
		{
			this.onClick_patch_hd_layer_original = this.onClick;
		}
		else
		{
			this.onClick_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onDoubleClick) === "Object")
		{
			this.onDoubleClick_patch_hd_layer_original = this.onDoubleClick;
		}
		else
		{
			this.onDoubleClick_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onMouseDown) === "Object")
		{
			this.onMouseDown_patch_hd_layer_original = this.onMouseDown;
		}
		else
		{
			this.onMouseDown_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onMouseUp) === "Object")
		{
			this.onMouseUp_patch_hd_layer_original = this.onMouseUp;
		}
		else
		{
			this.onMouseUp_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onMouseMove) === "Object")
		{
			this.onMouseMove_patch_hd_layer_original = this.onMouseMove;
		}
		else
		{
			this.onMouseMove_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onMouseWheel) === "Object")
		{
			this.onMouseWheel_patch_hd_layer_original = this.onMouseWheel;
		}
		else
		{
			this.onMouseWheel_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onHitTest) === "Object")
		{
			this.onHitTest_patch_hd_layer_original = this.onHitTest;
		}
		else
		{
			this.onHitTest_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onTouchDown) === "Object")
		{
			this.onTouchDown_patch_hd_layer_original = this.onTouchDown;
		}
		else
		{
			this.onTouchDown_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onTouchUp) === "Object")
		{
			this.onTouchUp_patch_hd_layer_original = this.onTouchUp;
		}
		else
		{
			this.onTouchUp_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onTouchMove) === "Object")
		{
			this.onTouchMove_patch_hd_layer_original = this.onTouchMove;
		}
		else
		{
			this.onTouchMove_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onTouchScaling) === "Object")
		{
			this.onTouchScaling_patch_hd_layer_original = this.onTouchScaling;
		}
		else
		{
			this.onTouchScaling_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onTouchRotate) === "Object")
		{
			this.onTouchRotate_patch_hd_layer_original = this.onTouchRotate;
		}
		else
		{
			this.onTouchRotate_patch_hd_layer_original = function() {};
		}
		&this.onClick = &this.onClick_patch_hd_layer_property_shim;
		&this.onDoubleClick = &this.onDoubleClick_patch_hd_layer_property_shim;
		&this.onMouseDown = &this.onMouseDown_patch_hd_layer_property_shim;
		&this.onMouseUp = &this.onMouseUp_patch_hd_layer_property_shim;
		&this.onMouseMove = &this.onMouseMove_patch_hd_layer_property_shim;
		&this.onMouseWheel = &this.onMouseWheel_patch_hd_layer_property_shim;
		&this.onHitTest = &this.onHitTest_patch_hd_layer_property_shim;
		&this.onTouchDown = &this.onTouchDown_patch_hd_layer_property_shim;
		&this.onTouchUp = &this.onTouchUp_patch_hd_layer_property_shim;
		&this.onTouchMove = &this.onTouchMove_patch_hd_layer_property_shim;
		&this.onTouchScaling = &this.onTouchScaling_patch_hd_layer_property_shim;
		&this.onTouchRotate = &this.onTouchRotate_patch_hd_layer_property_shim;
	}

	property horizontalAlignment
	{
		getter
		{
			return _horizontalAlignment;
		}
		setter(v)
		{
			_horizontalAlignment = v;
			left = left;
		}
	}

	property verticalAlignment
	{
		getter
		{
			return _verticalAlignment;
		}
		setter(v)
		{
			_verticalAlignment = v;
			top = top;
		}
	}

	property leftOriginal { getter {return super.left; } }
	property topOriginal { getter {return super.top; } }
	property widthOriginal { getter {return super.width; } }
	property heightOriginal { getter {return super.height; } }
	property imageWidthOriginal { getter { return super.imageWidth; } }
	property imageHeightOriginal { getter { return super.imageHeight; } }

	property left
	{
		getter
		{
			return originalLeft;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			originalLeft = transformDiscrete(v, leftScale());
			super.left = transformLeft(originalLeft);
		}
	}

	property top
	{
		getter
		{
			return originalTop;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			originalTop = transformDiscrete(v, topScale());
			super.top = transformTop(originalTop);
		}
	}

	property imageLeft
	{
		getter
		{
			return originalImageLeft;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			originalImageLeft = transformDiscrete(v, widthScale);
			super.imageLeft = v*widthScale;
		}
	}

	property imageTop
	{
		getter
		{
			return originalImageTop;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			originalImageTop = transformDiscrete(v, heightScale);
			super.imageTop = v*heightScale;
		}
	}

	property clipLeft
	{
		getter
		{
			return originalClipLeft;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			(global.Layer.setClip incontextof this)(v, originalClipTop, originalClipWidth, originalClipHeight);
		}
	}

	property clipTop
	{
		getter
		{
			return originalClipTop;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			(global.Layer.setClip incontextof this)(originalClipLeft, v, originalClipWidth, originalClipHeight);
		}
	}


	property clipWidth
	{
		getter
		{
			return originalClipWidth;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			(global.Layer.setClip incontextof this)(originalClipLeft, originalClipTop, v, originalClipHeight);
		}
	}

	property clipHeight
	{
		getter
		{
			return originalClipHeight;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			(global.Layer.setClip incontextof this)(originalClipLeft, originalClipTop, originalClipWidth, v);
		}
	}

	property attentionLeft
	{
		getter
		{
			return originalAttentionLeft;
		}
		setter(v)
		{
			originalAttentionLeft = transformDiscrete(v, widthScale);
			super.attentionLeft = v*widthScale;
		}
	}

	property attentionTop
	{
		getter
		{
			return originalAttentionTop;
		}
		setter(v)
		{
			originalAttentionTop = transformDiscrete(v, heightScale);
			super.attentionTop = v*heightScale;
		}
	}

	property cursorX
	{
		getter
		{
@if(SCALE_USING_FLOATING_POINT)
			return super.cursorX / cursorXScale;
@endif
@if(!SCALE_USING_FLOATING_POINT)
			return super.cursorX \ cursorXScale;
@endif
		}
		setter(v)
		{
			var originalCursorX = transformDiscrete(v, cursorXScale);
			super.cursorX = transformCursorX(originalCursorX);
		}
	}

	property cursorY
	{
		getter
		{
@if(SCALE_USING_FLOATING_POINT)
			return (super.cursorY - cursorYOffset() * wideScaleFactor) / cursorYScale;
@endif
@if(!SCALE_USING_FLOATING_POINT)
			return (super.cursorY - cursorYOffset() * wideScaleFactor) \ cursorYScale;
@endif
		}
		setter(v)
		{
			var originalCursorY = transformDiscrete(v, cursorYScale);
			super.cursorY = transformCursorY(originalCursorY);
		}
	}

	property width
	{
		getter
		{
			if (absoluteMode) {
				return super.width;
			}
			return originalWidth;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			if (v < 0)
			{
				v = -v;
			}
			v &= 0xffffffff;
@endif
			originalWidth = transformDiscrete(v, widthScale);
			super.width = v * widthScale;
			updateImageSize();
		}
	}

	property height
	{
		getter
		{
			if (absoluteMode) {
				return super.height;
			}
			return originalHeight;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			if (v < 0)
			{
				v = -v;
			}
			v &= 0xffffffff;
@endif
			originalHeight = transformDiscrete(v, heightScale);
			super.height = v * heightScale;
			updateImageSize();
		}
	}

	property imageWidth
	{
		getter
		{
@if(0)
			if (widthScale == 1)
			{
				if (super.imageWidth != originalImageWidth)
				{
					dm("warning: image width " + super.imageWidth + " does not match orig " + originalImageWidth);
				}
			}
@endif
			if (absoluteMode) {
				return super.imageWidth;
			}
			return originalImageWidth;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			if (v < 0)
			{
				v = -v;
			}
			v &= 0xffffffff;
@endif
			originalImageWidth = transformDiscrete(v, widthScale);
			if (originalImageWidth < originalWidth)
			{
				originalImageLeft = 0;
				originalWidth = originalImageWidth;
			}
			if (originalImageWidth + originalImageLeft < originalWidth)
			{
				originalImageLeft = originalWidth - originalImageWidth;
			}
			resetClip();
			super.imageWidth = v * widthScale;
		}
	}

	property imageHeight
	{
		getter
		{
@if(0)
			if (heightScale == 1)
			{
				if (super.imageHeight != originalImageHeight)
				{
					dm("warning: image height " + super.imageHeight + " does not match orig " + originalImageHeight);
				}
			}
@endif
			if (absoluteMode) {
				return super.imageHeight;
			}
			return originalImageHeight;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			if (v < 0)
			{
				v = -v;
			}
			v &= 0xffffffff;
@endif
			originalImageHeight = transformDiscrete(v, heightScale);
			if (originalImageHeight < originalHeight)
			{
				originalImageTop = 0;
				originalHeight = originalImageHeight;
			}
			if (originalImageHeight + originalImageTop < originalHeight)
			{
				originalImageTop = originalHeight - originalImageHeight;
			}
			resetClip();
			super.imageHeight = v * heightScale;
		}
	}

	function resetClip()
	{
		originalClipLeft = 0;
		originalClipTop = 0;
		originalClipWidth = originalImageWidth;
		originalClipHeight = originalImageHeight;
	}

	function setInitialImageProperties()
	{
		if (!super.hasImage)
		{
			originalImageLeft = 0;
			originalImageTop = 0;
			originalImageWidth = originalWidth;
			originalImageHeight = originalHeight;
		}
		resetClip();
	}

	property hasImage
	{
		getter
		{
			return super.hasImage;
		}
		setter(v)
		{
			if (v)
			{
				setInitialImageProperties();
			}
			super.hasImage = v;
		}
	}

	property type
	{
		getter
		{
			return super.type;
		}
		setter(v)
		{
			if (super.type != v)
			{
				switch (super.type)
				{
					case ltOpaque:
					case ltAlpha:
					case ltAdditive:
					case ltSubtractive:
					case ltMultiplicative:
					case ltDodge:
					case ltDarken:
					case ltLighten:
					case ltScreen:
					case ltAddAlpha:
					case ltPsNormal:
					case ltPsAdditive:
					case ltPsSubtractive:
					case ltPsMultiplicative:
					case ltPsScreen:
					case ltPsOverlay:
					case ltPsHardLight:
					case ltPsSoftLight:
					case ltPsColorDodge:
					case ltPsColorDodge5:
					case ltPsColorBurn:
					case ltPsLighten:
					case ltPsDarken:
					case ltPsDifference:
					case ltPsDifference5:
					case ltPsExclusion:
						setInitialImageProperties();
						break;
					default:
						break;
				}
			}
			super.type = v;
		}
	}

	function leftScale(parent=this.parent)
	{
		if (parent === null) {
			return 1;
		}
		return parent.widthScale;
	}

	function topScale(parent=this.parent)
	{
		if (parent === null) {
			return 1;
		}
		if (isbg) {
			if (fixedbg || fullScreenBg) {
				return scaleFactor;
			}
			return parent.heightScale;
		}
		return scaleFactor;
	}

	property cursorXScale { getter { return wideScaleFactor; } }
	property cursorYScale { getter { return scaleFactor; } }

	property widthScale
	{
		getter
		{
			if (absoluteMode)
			{
				return 1;
			}
			if (isbg || shouldStretch) {
				return wideScaleFactor;
			}
			return scaleFactor;
		}
	}

	property heightScale
	{
		getter
		{
			if (absoluteMode)
			{
				return 1;
			}
			if (isbg) {
				return wideScaleFactor;
			}
			if (isMessageLayer && isCropped) {
				return scaleFactor*cropFactor;
			}
			return scaleFactor;
		}
	}

	property leftOffset
	{
		getter
		{
			if (!window.wideScreen) return 0;
			if (isSysBase) {
				return -window.transformedScrollXOffset;
			}
			if ((!isbg || fixedbg) && isFixedPosition) {
				return window.transformedScrollXOffset;
			}
			return 0;
		}
	}

	function topOffset(parent=this.parent)
	{
		if (!window.wideScreen) return 0;
		if (isSysBase) {
			return -window.transformedScrollYOffset;
		}
		if ((!isbg || fixedbg) && isFixedPosition && (parent != null && parent.isbg)) {
			return window.transformedScrollYOffset;
		}
		return 0;
	}

	function cursorYOffset(parent=this.parent)
	{
		var offset = 0;
		if (isPrimary) {
			offset = window.transformedScrollYOffset;
		}
		return offset;
	}

	function leftPivot(parent=this.parent)
	{
		var result = 0;
		if (!shouldStretch && !isbg && (parent !== null && (parent.isbg || parent.shouldStretch) && !parent.isLineLayer ))
		{
@if(SCALE_USING_FLOATING_POINT)
			result = width * (wideFactor - 1) * horizontalAlignment / wideFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
			result = width * (wideFactor - 1) * horizontalAlignment \ wideFactor;
			result |= 0;
@endif

			// Applying the correction only to sprites, otherwise the blur function is buggy (I'm pretty sure it's only applied to sprites anyway...)
			if (typeof this.correctleft !== "undefined") {
@if(SCALE_USING_FLOATING_POINT)
				result += this.correctleft / wideFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
				result += this.correctleft \ wideFactor;
@endif
			}
		}
		return result;
	}

	function topPivot(top, parent=this.parent)
	{
		// TODO fix left pivot for negative values (use effective value like here).
		// For BG Images used as regular images
		if (isbg && fixedbg) {
			var effectiveVerticalAlignment = verticalAlignment;
			if (bottomImage) {
				effectiveVerticalAlignment = verticalAlignment-1;
			}
			else if (!movingbg) {
				effectiveVerticalAlignment = top>=0? verticalAlignment : verticalAlignment-1;
			}
			//var effectiveVerticalAlignment = Math.atan(top)/Math.PI-0.5; // Smoothing function
			return height*(wideFactor-1)*effectiveVerticalAlignment;
		}
		return 0;
	}

	property scaleAlgorithm
	{
		getter
		{
			if (isExButtonLayer) {
				return stLinear;
			}
			return stCubic;
		}
	}

	property shouldStretch { getter {
		if (stretch !== void) {
			return stretch;
		}
		if (typeof window.sflags !== "undefined" && !window.sflags.wideStrechWindow && (isMessageLayer || isLineLayer)) {
			return false;
		}
		return isMessageLayer || isLineLayer || isHistoryLayer || isCinescoLayer || isYesNoBackground || isGameMenuLayer || isShortcutBaseLayer;
	} }

	property isHistoryLayer { getter {
		return this instanceof "HistoryLayer";
	} }

	property isMessageLayer { getter {
		return this instanceof "MessageLayer";
	} }

	property isLineLayer { getter {
		return parent instanceof "MessageLayer" && !isClickGlyphLayer;
	} }

	property isGameMenuLayer { getter {
		return this instanceof "GameMenuLayer";
	} }

	property isShortcutBaseLayer { getter {
		return this instanceof "ShortcutBaseLayer";
	} }

	property isCharacterLayer { getter {
		return this instanceof "CharacterLayer";
	} }

	property isBaseLayer { getter {
		return this instanceof "BaseLayer" || parent === null;
	} }

	property isExButtonLayer { getter {
		return this instanceof "ExButtonLayer";
	} }

	property isPopupLayer { getter {
		return this instanceof "PopUpLayer";
	} }

	property isClickGlyphLayer { getter {
		return this instanceof "ClickGlyphLayer";
	} }

	property isCinescoLayer { getter {
		return name !== void && name.substr(0,7) == "Cinesco";
	} }

	property isDateTitleLayer { getter {
		return name == "DateTitle用テンポラリ";
	} }

	property isYesNoLayer { getter {
		return this instanceof "YesNoLayer";
	} }

	property isYesNoBackground { getter {
		return imageStorage !== void && ["汎用左", "汎用中", "汎用右"].contains(imageStorage);
	} }

	property isFlowChartLayer { getter {
		return this instanceof "FlowChartLayer";
	} }

	property isFlagListLayer { getter {
		return this instanceof "FlagListLayer";
	} }

	property isSceneDetailLayer { getter {
		return this instanceof "SceneDetailLayer";
	} }

	property isPushButtonLayer { getter {
		return this instanceof "PushButtonLayer";
	} }

	property isFixedPosition {
		getter {
			if (this._isFixedPosition !== void) {
				return this._isFixedPosition;
			}
			// Only message layer and not its children.
			return isCharacterLayer || this instanceof "MessageLayer" || isHistoryLayer || isGameMenuLayer || isShortcutBaseLayer || isPopupLayer || isCinescoLayer || isDateTitleLayer || isFlowChartLayer || isFlagListLayer || isYesNoLayer || isSceneDetailLayer || isPushButtonLayer;
		}
		setter(v) {
			this._isFixedPosition = v;
		}
	}

	property isSysBase {
		getter {
			return name == "トップレイヤ";
		}
	}

	function Layer_patch_hd_layer_override()
	{
		super.Layer(...);
		isbg = isBaseLayer;
		resetClip();
		patch_hd_layer_setup_event_shims();
	}

	function Layer()
	{
		Layer_patch_hd_layer_override(...);
	}

	function transformLeft(left, parent=this.parent)
	{
		return (left + leftOffset + leftPivot(parent))*leftScale(parent);
	}

	function transformTop(top, parent=this.parent)
	{
		return (top + topPivot(top))*topScale(parent) + topOffset(parent)*wideScaleFactor;
	}

	function transformCursorX(cursorX, parent=this.parent)
	{
		return cursorX * cursorXScale;
	}

	function transformCursorY(cursorY, parent=this.parent)
	{
		return cursorY * cursorYScale + cursorYOffset(parent) * wideScaleFactor;
	}

	function updateBg(width, height, fromloadImages=false)
	{
		if (isBaseLayer) {
			// Used for dialogs.
			isbg = !shouldStretch;
			fullScreenBg = isbg;
			fixedbg = false;
			movingbg = false;
			bottomImage = false;
		} else if (!shouldStretch && !isMask && !isMessageLayer) {
			fullScreenBg = (width == originalResWidth && height == originalResHeight);
			fullScreenBg |= (width == transformDiscrete(originalResWidth, wideScaleFactor) && height == transformDiscrete(originalResHeight, wideScaleFactor));

			fixedbg = !fullScreenBg;
			movingbg = false;
			bottomImage = false;

			if (fromloadImages) {
				// When loading an image, a bg can have many sizes - this check is only for bg that are not in the bgimage folder.
				isbg |= fullScreenBg;
				fixedbg |= fixedBgImages.contains(imageStorage);
				movingbg = movingBgImages.contains(imageStorage);
				bottomImage = bottomImages.contains(imageStorage);
			} else {
				// When manually setting the size (setSize or setImageSize) it's a bg only when the dimensions match.
				isbg = fullScreenBg;
			}
		}
		// background settings affect position.
		(global.Layer.setPos incontextof this)(originalLeft, originalTop);
	}

	function updateMessageLayerMobile() {
		if (isMessageLayer && messageLayerImages.contains(imageStorage) && window.sflags !== "undefined") {
			if (window.sflags.mobileWindow) {
				type = ltAlpha;
				lineLayer.type = ltTransparent;
			} else {
				type = ltAddAlpha;
				lineLayer.type = ltAddAlpha;
			}
		}
	}

	function loadImages(storage, key)
	{
		storage = storage.toLowerCase();
		var storageName = Storages.chopStorageExt(storage);
		var storageExt = Storages.extractStorageExt(storage);

		imageStorage = storageName;
		if (window.isHd) {
			// Some HD assets have slightly different names (but the images are the same).
			imageStorage = originalToHdName[imageStorage] if originalToHdName[imageStorage] !== void;
		}

		if (messageLayerImages.contains(imageStorage) && typeof window.sflags !== "undefined" && !window.sflags.mobileWindow) {
			storageExt = ".png";
		} else if (messageBreakImages.contains(imageStorage) && typeof window.sflags !== "undefined" && !window.sflags.mobileWindow) {
			storageExt = ".png";
		}

		updateMessageLayerMobile();

@if(GAME_FATE)
		// Check to see if an HD version exists.
		isHd = Storages.isExistentStorage(imageStorage + hdExtension) || imageStorage != storageName;
@endif
@if(GAME_FHAT)
		isHd = true;
@endif

		var chosenExt = storageExt;
		if (storageExt == "") {
			for (var i=0; i < global.image_extensions.count; i++) {
				var currentExtension = global.image_extensions[i];
				if (currentExtension === hdExtension)
				{
					continue;
				}
				var currentStorage = storageName + currentExtension;

				var currentPath = Storages.getPlacedPath(currentStorage);
				if (currentPath === "")
				{
					continue;
				}

				if (!isBaseLayer && !isMessageLayer && !isMask) {
					isbg = /bgimage/.test(currentPath); // TODO only works in dev mode
				}

				if (/hd/.test(currentPath)) {
					// TODO the /hd/.test is being used twice in this method, find a way to optimize...
					isHd = true;
				}

				if (isHd) {
					var tmp = new global.Layer(window, this);
					(Layer_patch_hd_layer_original.loadImages incontextof tmp)(currentStorage);
					originalImageWidth = tmp.imageWidthOriginal;
					originalImageHeight = tmp.imageHeightOriginal;
					invalidate tmp;

					if (imageStorage == "pagebreak_a") {
						// low resolution image has 21 images, but HD has 16.
						originalImageWidth = originalImageWidth / 21 * 16;
					} else if (imageStorage == "c31") {
						// 2 HD versions: png and webp - the png has a higher resolution.
						isbg = true;
						originalImageWidth = originalImageWidth / (window.isHd? upscaledFactor : 1);
						originalImageHeight = originalImageHeight / (window.isHd? upscaledFactor : 1);
					} else if (/hd/.test(currentPath)) {
						// HD versions of patch assets (mostly the HD masks for the status menu).
@if(SCALE_USING_FLOATING_POINT)
						originalImageWidth = originalImageWidth / (window.isHd? upscaledFactor : 1);
						originalImageHeight = originalImageHeight / (window.isHd? upscaledFactor : 1);
@endif
@if(!SCALE_USING_FLOATING_POINT)
						originalImageWidth = originalImageWidth \ (window.isHd? upscaledFactor : 1);
						originalImageHeight = originalImageHeight \ (window.isHd? upscaledFactor : 1);
@endif
					}
				} else {
					// Load images based on file extension priority (according to global.image_extensions).
					chosenExt = currentExtension;
				}
				break;
			}
		}

		var taginfo = super.loadImages(imageStorage+chosenExt, key);

		// Mainly used for 藤02a腕b(中) and 藤02g腕b(中) since the HD version's width is larger than expected because of redundant transparent padding, but there might be other cases so the condition is generic.
		if (isHd && isCharacterLayer && !isbg) {
			var w = originalImageWidth*widthScale;
			var h = originalImageHeight*heightScale;
			var leftDiff = (super.imageWidth - w) \ 2;
			if (leftDiff > 0) {
				var tmp = new global.Layer(window, this);
				(Layer_patch_hd_layer_original.loadImages incontextof tmp)(imageStorage+chosenExt, key);

				super.fillRect(0, 0, w, h, 0x00000000);
				(Layer_patch_hd_layer_original.operateRect)(0, 0, tmp, leftDiff, 0, w, h);
				(Layer_patch_hd_layer_original.setImageSize)(w, h);

				invalidate tmp;
			}
		}

		if (isThumbnail) {
			originalImageWidth = 120;
			originalImageHeight = 90;
		} else if (isTicketThumbnail) {
			originalImageWidth = 128;
			originalImageHeight = 96;
		} else if (!isHd || storageExt != "") {
			originalImageWidth = super.imageWidth;
			originalImageHeight = super.imageHeight;

			if (imageStorage == "csラストep08b") {
				isbg = true;
			}
		}

		updateBg(originalImageWidth, originalImageHeight, true);

		if (isExButtonLayer) {
			numberOfImages = septByMode[mode];
		} else if (imageStorage == "pagebreak_a" && storageExt == ".png") {
			numberOfImages = imageNameToNumberOfImages[imageStorage + storageExt];
		} else {
			if (imageNameToNumberOfImages[imageStorage] !== void)
			{
				numberOfImages = imageNameToNumberOfImages[imageStorage];
			}
			else
			{
				numberOfImages = 1;
			}
		}

		upscale();

		if (numberOfImages == 1) {
			originalImageWidth = transformDiscrete(originalImageWidth, widthScale);
			originalImageHeight = transformDiscrete(originalImageHeight, heightScale);
		}

		internalSetImageSize(originalImageWidth, originalImageHeight);

		return taginfo;
	}

	function loadProvinceImage(image)
	{
		throw new Exception("Function loadProvinceImage not implemented");
	}

	function getMainPixel(x, y)
	{
@if(!SCALE_USING_FLOATING_POINT)
		x = ((x < 0 ? -x : x) & 0x7fffffff) * (x < 0 ? -1 : 1);
		y = ((y < 0 ? -y : y) & 0x7fffffff) * (y < 0 ? -1 : 1);
@endif
		x *= widthScale;
		y *= heightScale;
		return super.getMainPixel(x, y);
	}

	function setMainPixel(x, y, color)
	{
@if(!SCALE_USING_FLOATING_POINT)
		x = ((x < 0 ? -x : x) & 0x7fffffff) * (x < 0 ? -1 : 1);
		y = ((y < 0 ? -y : y) & 0x7fffffff) * (y < 0 ? -1 : 1);
		color &= 0xffffffff;
@endif
		x *= widthScale;
		y *= heightScale;
		super.setMainPixel(x, y, color);
	}

	function getMaskPixel(x, y)
	{
@if(!SCALE_USING_FLOATING_POINT)
		x = ((x < 0 ? -x : x) & 0x7fffffff) * (x < 0 ? -1 : 1);
		y = ((y < 0 ? -y : y) & 0x7fffffff) * (y < 0 ? -1 : 1);
@endif
		x *= widthScale;
		y *= heightScale;
		return super.getMaskPixel(x, y);
	}

	function setMaskPixel(x, y, value)
	{
@if(!SCALE_USING_FLOATING_POINT)
		x = ((x < 0 ? -x : x) & 0x7fffffff) * (x < 0 ? -1 : 1);
		y = ((y < 0 ? -y : y) & 0x7fffffff) * (y < 0 ? -1 : 1);
		value &= 0xffffffff;
@endif
		x *= widthScale;
		y *= heightScale;
		super.setMaskPixel(x, y, value);
	}

	function getProvincePixel(x, y)
	{
@if(!SCALE_USING_FLOATING_POINT)
		x = ((x < 0 ? -x : x) & 0x7fffffff) * (x < 0 ? -1 : 1);
		y = ((y < 0 ? -y : y) & 0x7fffffff) * (y < 0 ? -1 : 1);
@endif
		x *= widthScale;
		y *= heightScale;
		return super.getProvincePixel(x, y);
	}

	function setProvincePixel(x, y, value)
	{
@if(!SCALE_USING_FLOATING_POINT)
		x = ((x < 0 ? -x : x) & 0x7fffffff) * (x < 0 ? -1 : 1);
		y = ((y < 0 ? -y : y) & 0x7fffffff) * (y < 0 ? -1 : 1);
		value &= 0xffffffff;
@endif
		x *= widthScale;
		y *= heightScale;
		super.setProvincePixel(x, y, value);
	}

	function getLayerAt(x, y, exclude_self, get_disabled)
	{
@if(!SCALE_USING_FLOATING_POINT)
		x = ((x < 0 ? -x : x) & 0x7fffffff) * (x < 0 ? -1 : 1);
		y = ((y < 0 ? -y : y) & 0x7fffffff) * (y < 0 ? -1 : 1);
@endif
		x *= widthScale;
		y *= heightScale;
		return super.getLayerAt(x, y, exclude_self, get_disabled);
	}

	function setSize(width, height)
	{
@if(!SCALE_USING_FLOATING_POINT)
		width = ((width < 0 ? -width : width) & 0x7fffffff) * (width < 0 ? -1 : 1);
		height = ((height < 0 ? -height : height) & 0x7fffffff) * (height < 0 ? -1 : 1);
@endif

		updateBg(width, height);

		originalWidth = transformDiscrete(width, widthScale);
		originalHeight = transformDiscrete(height, heightScale);

		super.setSize(width * widthScale, height * heightScale);

		updateImageSize();
	}

	function setImageSize(imageWidth, imageHeight)
	{
@if(!SCALE_USING_FLOATING_POINT)
		imageWidth = ((imageWidth < 0 ? -imageWidth : imageWidth) & 0x7fffffff) * (imageWidth < 0 ? -1 : 1);
		imageHeight = ((imageHeight < 0 ? -imageHeight : imageHeight) & 0x7fffffff) * (imageHeight < 0 ? -1 : 1);
@endif

		updateBg(imageWidth, imageHeight);

		originalImageWidth = transformDiscrete(imageWidth, widthScale);
		originalImageHeight = transformDiscrete(imageHeight, heightScale);
		internalSetImageSize(originalImageWidth, originalImageHeight);

		super.setImageSize(imageWidth * widthScale, imageHeight * heightScale);
	}

	function updateImageSize()
	{
		if (hasImage) {
			if (originalImageWidth < originalWidth) {
				originalImageWidth = originalWidth;
			}
			if (originalImageWidth + originalImageLeft < originalWidth) {
				originalImageLeft = originalWidth - originalImageWidth;
			}
			if (originalImageHeight < originalHeight) {
				originalImageHeight = originalHeight;
			}
			if (originalImageHeight + originalImageTop < originalHeight) {
				originalImageTop = originalHeight - originalImageHeight;
			}
			resetClip();
		}
	}

	function internalSetImageSize(width, height)
	{
		if (width < originalWidth)
		{
			originalImageLeft = 0;
			originalWidth = width;
		}
		if (width + originalImageLeft < originalWidth)
		{
			originalImageLeft = originalWidth - width;
		}

		if (height < originalHeight)
		{
			originalImageTop = 0;
			originalHeight = height;
		}
		if (height + originalImageTop < originalHeight)
		{
			originalImageTop = originalHeight - height;
		}

		if (hasImage)
		{
			resetClip();
		}
	}

	function setSizeToImageSize()
	{
		originalWidth = originalImageWidth;
		originalHeight = originalImageHeight;
		super.setSizeToImageSize();
		updateImageSize();
	}

	function upscale()
	{
		var scaleWidth = originalImageWidth * widthScale;
		var scaleHeight = originalImageHeight * heightScale;
		if (super.imageWidth == scaleWidth && super.imageHeight == scaleHeight) return;

@if(SCALE_USING_FLOATING_POINT)
		var scale = scaleWidth / super.imageWidth;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		var scale = scaleWidth \ super.imageWidth;
@endif
		var singleWidth = super.imageWidth \ numberOfImages;
		var roundedUpscaledSingleWidth = int(singleWidth * scale);
		scaleWidth = roundedUpscaledSingleWidth * numberOfImages;

		var tmp = new global.Layer(window, this);
		(global.Layer_patch_hd_layer_original.setImageSize incontextof tmp)(scaleWidth, scaleHeight);

		for (var i = 0; i < numberOfImages; i++) {
			(global.Layer_patch_hd_layer_original.stretchCopy incontextof tmp)(roundedUpscaledSingleWidth*i, 0, roundedUpscaledSingleWidth, scaleHeight, this, singleWidth*i, 0, singleWidth, super.imageHeight, scaleAlgorithm);
		}

		super.setImageSize(scaleWidth, scaleHeight);

		super.fillRect(0, 0, super.imageWidth, super.imageHeight, 0x00000000);

		if (face == dfProvince) {
			super.operateRect(0, 0, tmp, 0, 0, scaleWidth, scaleHeight, face);
		} else {
			super.operateRect(0, 0, tmp, 0, 0, scaleWidth, scaleHeight);
		}

		invalidate tmp;
	}

	function setPos(left, top, width, height)
	{
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
@endif
		originalLeft = left;
		originalTop = top;

		if (width !== void)
		{
@if(!SCALE_USING_FLOATING_POINT)
			width = ((width < 0 ? -width : width) & 0x7fffffff) * (width < 0 ? -1 : 1);
@endif
			originalWidth = width;
			width = width * widthScale;
		}
		if (height !== void)
		{
@if(!SCALE_USING_FLOATING_POINT)
			height = ((height < 0 ? -height : height) & 0x7fffffff) * (height < 0 ? -1 : 1);
@endif
			originalHeight = height;
			height = height * heightScale;
		}

		super.setPos(transformLeft(left), transformTop(top), width, height);

		if (width !== void || height !== void)
		{
			updateImageSize();
		}
	}

	function setImagePos(left, top)
	{
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
@endif
		originalImageLeft = left;
		originalImageTop = top;
		super.setImagePos(left*widthScale, top*heightScale);
	}

	function setCursorPos(cursorX, cursorY)
	{
@if(!SCALE_USING_FLOATING_POINT)
		cursorX = ((cursorX < 0 ? -cursorX : cursorX) & 0x7fffffff) * (cursorX < 0 ? -1 : 1);
		cursorY = ((cursorY < 0 ? -cursorY : cursorY) & 0x7fffffff) * (cursorY < 0 ? -1 : 1);
@endif
		var originalCursorX = transformDiscrete(cursorX, cursorXScale);
		var originalCursorY = transformDiscrete(cursorY, cursorYScale);
		super.setCursorPos(transformCursorX(originalCursorX), transformCursorY(originalCursorY));
	}

	function updateBgFromSource(src, swidth, sheight)
	{
		// When copying a background image, set this layer to be background as well
		if (src.isbg && src.imageWidthOriginal == swidth && src.imageHeightOriginal == sheight) {
			isbg = src.isbg;
			fullScreenBg = src.fullScreenBg;
			fixedbg = src.fixedbg;
			movingbg = src.movingbg;

			isMask = true;
			(global.Layer.setSize incontextof this)(src.imageWidthOriginal, src.imageHeightOriginal);
			isMask = false;
		}
	}

	function operateRect(left, top, src, sleft, stop, swidth, sheight, mode, opacity)
	{
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		sleft = ((sleft < 0 ? -sleft : sleft) & 0x7fffffff) * (sleft < 0 ? -1 : 1);
		stop = ((stop < 0 ? -stop : stop) & 0x7fffffff) * (stop < 0 ? -1 : 1);
		swidth = ((swidth < 0 ? -swidth : swidth) & 0x7fffffff) * (swidth < 0 ? -1 : 1);
		sheight = ((sheight < 0 ? -sheight : sheight) & 0x7fffffff) * (sheight < 0 ? -1 : 1);
		if (mode !== void)
		{
			mode = ((mode < 0 ? -mode : mode) & 0x7fffffff) * (mode < 0 ? -1 : 1);
		}
		if (opacity !== void)
		{
			opacity = ((opacity < 0 ? -opacity : opacity) & 0x7fffffff) * (opacity < 0 ? -1 : 1);
		}
@endif
		super.operateRect(src.transformLeft(left, this), src.transformTop(top, this), src, sleft*src.widthScale, stop*src.heightScale, swidth*src.widthScale, sheight*src.heightScale, mode, opacity);
	}

	function copyRect(left, top, src, sleft, stop, swidth, sheight)
	{
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		sleft = ((sleft < 0 ? -sleft : sleft) & 0x7fffffff) * (sleft < 0 ? -1 : 1);
		stop = ((stop < 0 ? -stop : stop) & 0x7fffffff) * (stop < 0 ? -1 : 1);
		swidth = ((swidth < 0 ? -swidth : swidth) & 0x7fffffff) * (swidth < 0 ? -1 : 1);
		sheight = ((sheight < 0 ? -sheight : sheight) & 0x7fffffff) * (sheight < 0 ? -1 : 1);
@endif
		updateBgFromSource(src, swidth, sheight);
		super.copyRect(src.transformLeft(left, this), src.transformTop(top, this), src, sleft*src.widthScale, stop*src.heightScale, swidth*src.widthScale, sheight*src.heightScale);
	}

	function copy9Patch(src)
	{
		throw new Exception("copy9Patch is not implemented");
	}

	function operateStretch(left, top, width, height, src, sleft, stop, swidth, sheight, mode, opacity, type, option)
	{
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		width = ((width < 0 ? -width : width) & 0x7fffffff) * (width < 0 ? -1 : 1);
		height = ((height < 0 ? -height : height) & 0x7fffffff) * (height < 0 ? -1 : 1);
		var sleft_orig = sleft;
		var stop_orig = stop;
		var swidth_orig = swidth;
		var sheight_orig = sheight;
		sleft = ((sleft < 0 ? -sleft : sleft) & 0x7fffffff) * (sleft < 0 ? -1 : 1);
		stop = ((stop < 0 ? -stop : stop) & 0x7fffffff) * (stop < 0 ? -1 : 1);
		swidth = ((swidth < 0 ? -swidth : swidth) & 0x7fffffff) * (swidth < 0 ? -1 : 1);
		sheight = ((sheight < 0 ? -sheight : sheight) & 0x7fffffff) * (sheight < 0 ? -1 : 1);
		if (mode !== void)
		{
			mode = ((mode < 0 ? -mode : mode) & 0x7fffffff) * (mode < 0 ? -1 : 1);
		}
		if (opacity !== void)
		{
			opacity = ((opacity < 0 ? -opacity : opacity) & 0x7fffffff) * (opacity < 0 ? -1 : 1);
		}
		if (type !== void)
		{
			type = ((type < 0 ? -type : type) & 0x7fffffff) * (type < 0 ? -1 : 1);
		}
		if (option !== void)
		{
			option *= 1.0;
		}
@endif
		super.operateStretch(src.transformLeft(left, this), src.transformTop(top, this), width*widthScale, height*heightScale, src, sleft*src.widthScale, stop*src.heightScale, swidth*src.widthScale, sheight*src.heightScale, mode, opacity, type, option);
	}

	function transformSLeft(src, sleft, swidth)
	{
		if (src.numberOfImages > 1) {
@if(SCALE_USING_FLOATING_POINT)
			var imageIndex = sleft / swidth;
@endif
@if(!SCALE_USING_FLOATING_POINT)
			var imageIndex = sleft \ swidth;
@endif
			return imageIndex * int(swidth * src.widthScale);
		}
		return sleft*src.widthScale;
	}

	function stretchCopy(left, top, width, height, src, sleft, stop, swidth, sheight, type, option)
	{
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		width = ((width < 0 ? -width : width) & 0x7fffffff) * (width < 0 ? -1 : 1);
		height = ((height < 0 ? -height : height) & 0x7fffffff) * (height < 0 ? -1 : 1);
		sleft = ((sleft < 0 ? -sleft : sleft) & 0x7fffffff) * (sleft < 0 ? -1 : 1);
		stop = ((stop < 0 ? -stop : stop) & 0x7fffffff) * (stop < 0 ? -1 : 1);
		swidth = ((swidth < 0 ? -swidth : swidth) & 0x7fffffff) * (swidth < 0 ? -1 : 1);
		sheight = ((sheight < 0 ? -sheight : sheight) & 0x7fffffff) * (sheight < 0 ? -1 : 1);
		if (type !== void)
		{
			type = ((type < 0 ? -type : type) & 0x7fffffff) * (type < 0 ? -1 : 1);
		}
		if (option !== void)
		{
			option *= 1.0;
		}
@endif
		sleft = transformSLeft(src, sleft, swidth);

		super.stretchCopy(src.transformLeft(left, this), src.transformTop(top, this), width*widthScale, height*heightScale, src, sleft, stop*src.heightScale, swidth*src.widthScale, sheight*src.heightScale, type, option);
	}

	function stretchCopyAA(left, top, width, height, src, sleft, stop, swidth, sheight, type)
	{
		sleft = transformSLeft(src, sleft, swidth);

		super.stretchCopyAA(src.transformLeft(left, this), src.transformTop(top, this), width*widthScale, height*heightScale, src, sleft, stop*src.heightScale, swidth*src.widthScale, sheight*src.heightScale, type);
	}

	function shrinkCopy(left, top, width, height, src, sleft, stop, swidth, sheight)
	{
		left = src.transformLeft(left, this);
		top = src.transformTop(top, this);
		width = width*widthScale;
		height = height*heightScale;
		sleft = sleft*src.widthScale;
		stop = stop*src.heightScale;
		swidth = swidth*src.widthScale;
		sheight = sheight*src.heightScale;

		absoluteMode = true;
		src.absoluteMode = true;
		super.shrinkCopy(left, top, width, height, src, sleft, stop, swidth, sheight);
		absoluteMode = false;
		src.absoluteMode = false;
	}

	function piledCopy(left, top, src, sleft, stop, swidth, sheight)
	{
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		sleft = ((sleft < 0 ? -sleft : sleft) & 0x7fffffff) * (sleft < 0 ? -1 : 1);
		stop = ((stop < 0 ? -stop : stop) & 0x7fffffff) * (stop < 0 ? -1 : 1);
		swidth = ((swidth < 0 ? -swidth : swidth) & 0x7fffffff) * (swidth < 0 ? -1 : 1);
		sheight = ((sheight < 0 ? -sheight : sheight) & 0x7fffffff) * (sheight < 0 ? -1 : 1);
@endif
		updateBgFromSource(src, swidth, sheight);
		super.piledCopy(src.transformLeft(left, this), src.transformTop(top, this), src, sleft*src.widthScale, stop*src.heightScale, swidth*src.widthScale, sheight*src.heightScale);
	}

	function affineCopy(src, sx, sy, sw, sh, affine, a, b, c, d, tx, ty, type, clear)
	{
@if(!SCALE_USING_FLOATING_POINT)
		sx = ((sx < 0 ? -sx : sx) & 0x7fffffff) * (sx < 0 ? -1 : 1);
		sy = ((sy < 0 ? -sy : sy) & 0x7fffffff) * (sy < 0 ? -1 : 1);
		sw = ((sw < 0 ? -sw : sw) & 0x7fffffff) * (sw < 0 ? -1 : 1);
		sh = ((sh < 0 ? -sh : sh) & 0x7fffffff) * (sh < 0 ? -1 : 1);
		affine = !!affine;
		a *= 1.0;
		b *= 1.0;
		c *= 1.0;
		d *= 1.0;
		tx *= 1.0;
		ty *= 1.0;
		if (type !== void)
		{
			type = ((type < 0 ? -type : type) & 0x7fffffff) * (type < 0 ? -1 : 1);
		}
		if (clear !== void)
		{
			clear = ((clear < 0 ? -clear : clear) & 0x7fffffff) * (clear < 0 ? -1 : 1);
		}
@endif
		super.affineCopy(src, sx*src.widthScale, sy*src.heightScale, sw*src.widthScale, sh*src.heightScale, affine, a, b, c, d, tx*widthScale, ty*heightScale, type, clear);
	}

	function operateAffine(src, sx, sy, sw, sh, affine, a, b, c, d, tx, ty, mode, opa, type)
	{
@if(!SCALE_USING_FLOATING_POINT)
		sx = ((sx < 0 ? -sx : sx) & 0x7fffffff) * (sx < 0 ? -1 : 1);
		sy = ((sy < 0 ? -sy : sy) & 0x7fffffff) * (sy < 0 ? -1 : 1);
		sw = ((sw < 0 ? -sw : sw) & 0x7fffffff) * (sw < 0 ? -1 : 1);
		sh = ((sh < 0 ? -sh : sh) & 0x7fffffff) * (sh < 0 ? -1 : 1);
		affine = !!affine;
		a *= 1.0;
		b *= 1.0;
		c *= 1.0;
		d *= 1.0;
		tx *= 1.0;
		ty *= 1.0;
		if (mode !== void)
		{
			mode = ((mode < 0 ? -mode : mode) & 0x7fffffff) * (mode < 0 ? -1 : 1);
		}
		if (opa !== void)
		{
			opa = ((opa < 0 ? -opa : opa) & 0x7fffffff) * (opa < 0 ? -1 : 1);
		}
		if (type !== void)
		{
			type = ((type < 0 ? -type : type) & 0x7fffffff) * (type < 0 ? -1 : 1);
		}
@endif
		super.operateAffine(src, sx*src.widthScale, sy*src.heightScale, sw*src.widthScale, sh*src.heightScale, affine, a, b, c, d, tx*widthScale, ty*heightScale, mode, opa, type);
	}

	function doBoxBlur(xblur=1, yblur=1)
	{
@if(!SCALE_USING_FLOATING_POINT)
		xblur = ((xblur < 0 ? -xblur : xblur) & 0x7fffffff) * (xblur < 0 ? -1 : 1);
		yblur = ((yblur < 0 ? -yblur : yblur) & 0x7fffffff) * (yblur < 0 ? -1 : 1);
@endif
		super.doBoxBlur(xblur*widthScale, yblur*heightScale);
	}

	function fillRect(left, top, width, height, color)
	{
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		width = ((width < 0 ? -width : width) & 0x7fffffff) * (width < 0 ? -1 : 1);
		height = ((height < 0 ? -height : height) & 0x7fffffff) * (height < 0 ? -1 : 1);
		color &= 0xffffffff;
@endif
		super.fillRect(left*widthScale, top*heightScale, width*widthScale, height*heightScale, color);
	}

	function colorRect(left, top, width, height, color, opacity)
	{
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		width = ((width < 0 ? -width : width) & 0x7fffffff) * (width < 0 ? -1 : 1);
		height = ((height < 0 ? -height : height) & 0x7fffffff) * (height < 0 ? -1 : 1);
		color &= 0xffffffff;
		if (opacity !== void)
		{
			opacity = ((opacity < 0 ? -opacity : opacity) & 0x7fffffff) * (opacity < 0 ? -1 : 1);
		}
@endif
		super.colorRect(left*widthScale, top*heightScale, width*widthScale, height*heightScale, color, opacity);
	}

	function setClip(args*)
	{
		if (args.count === 0)
		{
			super.setClip(0, 0, super.imageWidth, super.imageHeight);
			resetClip();
			return;
		}
		var clipLeft = args.count >= 1 ? args[0] : 0;
		var clipTop = args.count >= 2 ? args[1] : 0;
		var clipWidth = args.count >= 3 ? args[2] : 0;
		var clipHeight = args.count >= 4 ? args[3] : 0;
@if(!SCALE_USING_FLOATING_POINT)
		clipLeft = ((clipLeft < 0 ? -clipLeft : clipLeft) & 0x7fffffff) * (clipLeft < 0 ? -1 : 1);
		clipTop = ((clipTop < 0 ? -clipTop : clipTop) & 0x7fffffff) * (clipTop < 0 ? -1 : 1);
		clipWidth = ((clipWidth < 0 ? -clipWidth : clipWidth) & 0x7fffffff) * (clipWidth < 0 ? -1 : 1);
		clipHeight = ((clipHeight < 0 ? -clipHeight : clipHeight) & 0x7fffffff) * (clipHeight < 0 ? -1 : 1);
@endif
		var clipRight = originalImageWidth + clipLeft;
		var clipBottom = originalImageHeight + clipTop;
		clipLeft = clipLeft < 0 ? 0 : clipLeft;
		clipTop = clipTop < 0 ? 0 : clipTop;
		clipRight = originalImageWidth < clipRight ? originalImageWidth : clipRight;
		clipBottom = originalImageHeight < clipBottom ? originalImageHeight : clipBottom;
		if (clipRight < clipLeft)
		{
			clipRight = clipLeft;
		}
		if (clipBottom < clipTop)
		{
			clipBottom = clipTop;
		}
		originalClipLeft = transformDiscrete(clipLeft, widthScale);
		originalClipTop = transformDiscrete(clipTop, heightScale);
		originalClipWidth = transformDiscrete(clipWidth, widthScale);
		originalClipHeight = transformDiscrete(clipHeight, heightScale);

		super.setClip(clipLeft*widthScale, clipTop*heightScale, clipWidth*widthScale, clipHeight*heightScale);
	}

	function setAttentionPos(left, top)
	{
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
@endif
		originalAttentionLeft = transformDiscrete(left, widthScale);
		originalAttentionTop = transformDiscrete(top, heightScale);
		super.setAttentionPos(left*widthScale, top*heightScale);
	}

	function assignImages(src)
	{
		super.assignImages(src);
		originalImageWidth = src.originalImageWidth;
		originalImageHeight = src.originalImageHeight;
		imageStorage = src.imageStorage;
		isbg = src.isbg;
		internalSetImageSize(originalImageWidth, originalImageHeight);
	}

	function drawText(left, top, text, color, opacity, aa, slevel, scolor, swidth, sofsx, sofsy)
	{
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		color &= 0xffffffff;
		if (opacity !== void)
		{
			opacity = ((opacity < 0 ? -opacity : opacity) & 0x7fffffff) * (opacity < 0 ? -1 : 1);
		}
		if (aa !== void)
		{
			aa = !!aa;
		}
		if (slevel !== void)
		{
			slevel = ((slevel < 0 ? -slevel : slevel) & 0x7fffffff) * (slevel < 0 ? -1 : 1);
		}
		if (scolor !== void)
		{
			scolor &= 0xffffffff;
		}
		if (swidth !== void)
		{
			swidth = ((swidth < 0 ? -swidth : swidth) & 0x7fffffff) * (swidth < 0 ? -1 : 1);
		}
		if (sofsx !== void)
		{
			sofsx = ((sofsx < 0 ? -sofsx : sofsx) & 0x7fffffff) * (sofsx < 0 ? -1 : 1);
		}
		if (sofsy !== void)
		{
			sofsy = ((sofsy < 0 ? -sofsy : sofsy) & 0x7fffffff) * (sofsy < 0 ? -1 : 1);
		}
@endif
		super.drawText(left*widthScale, top*heightScale, text, color, opacity, aa, slevel, scolor, swidth, sofsx, sofsy);
	}

	function drawGlyph(left, top, glyph, color, opacity, aa, slevel, scolor, swidth, sofsx, sofsy)
	{
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		color &= 0xffffffff;
		if (opacity !== void)
		{
			opacity = ((opacity < 0 ? -opacity : opacity) & 0x7fffffff) * (opacity < 0 ? -1 : 1);
		}
		if (aa !== void)
		{
			aa = !!aa;
		}
		if (slevel !== void)
		{
			slevel = ((slevel < 0 ? -slevel : slevel) & 0x7fffffff) * (slevel < 0 ? -1 : 1);
		}
		if (scolor !== void)
		{
			scolor &= 0xffffffff;
		}
		if (swidth !== void)
		{
			swidth = ((swidth < 0 ? -swidth : swidth) & 0x7fffffff) * (swidth < 0 ? -1 : 1);
		}
		if (sofsx !== void)
		{
			sofsx = ((sofsx < 0 ? -sofsx : sofsx) & 0x7fffffff) * (sofsx < 0 ? -1 : 1);
		}
		if (sofsy !== void)
		{
			sofsy = ((sofsy < 0 ? -sofsy : sofsy) & 0x7fffffff) * (sofsy < 0 ? -1 : 1);
		}
@endif
		super.drawGlyph(left*widthScale, top*heightScale, glyph, color, opacity, aa, slevel, scolor, swidth, sofsx, sofsy);
	}

@if(0)
	property mainImageBuffer
	{
		getter
		{
			if (!absoluteMode)
			{
				dm("trace: " + Scripts.getTraceString());
				throw new Exception("Attempted to get mainImageBuffer while not in absoluteMode");
			}
			return super.mainImageBuffer;
		}
	}

	property mainImageBufferForWrite
	{
		getter
		{
			if (!absoluteMode)
			{
				dm("trace: " + Scripts.getTraceString());
				throw new Exception("Attempted to get mainImageBufferForWrite while not in absoluteMode");
			}
			return super.mainImageBufferForWrite;
		}
	}

	property mainImageBufferPitch
	{
		getter
		{
			if (!absoluteMode)
			{
				dm("trace: " + Scripts.getTraceString());
				throw new Exception("Attempted to get mainImageBufferPitch while not in absoluteMode");
			}
			return super.mainImageBufferPitch;
		}
	}

	property provinceImageBuffer
	{
		getter
		{
			if (!absoluteMode)
			{
				dm("trace: " + Scripts.getTraceString());
				throw new Exception("Attempted to get provinceImageBuffer while not in absoluteMode");
			}
			return super.provinceImageBuffer;
		}
	}

	property provinceImageBufferForWrite
	{
		getter
		{
			if (!absoluteMode)
			{
				dm("trace: " + Scripts.getTraceString());
				throw new Exception("Attempted to get provinceImageBufferForWrite while not in absoluteMode");
			}
			return super.provinceImageBufferForWrite;
		}
	}

	property provinceImageBufferPitch
	{
		getter
		{
			if (!absoluteMode)
			{
				dm("trace: " + Scripts.getTraceString());
				throw new Exception("Attempted to get provinceImageBufferPitch while not in absoluteMode");
			}
			return super.provinceImageBufferPitch;
		}
	}
@endif

	function update(args*)
	{
		if (args.count < 1)
		{
			super.update();
			return;
		}
		if (args.count < 4)
		{
			throw new Exception("expected 4 args");
		}
		var left = args[0];
		var top = args[1];
		var width = args[2];
		var height = args[3];
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		width = ((width < 0 ? -width : width) & 0x7fffffff) * (width < 0 ? -1 : 1);
		height = ((height < 0 ? -height : height) & 0x7fffffff) * (height < 0 ? -1 : 1);
@endif
		super.update(left*widthScale, top*heightScale, width*widthScale, height*heightScale);
	}

	/*
	function redraw(left, top)
	{
		super.redraw(left*widthScale, top*heightScale);
	}*/
}
global.Layer = Layer_patch_hd_layer_override;


global.Window_patch_hd_layer_original = Window;
class Window_patch_hd_layer_override extends Window_patch_hd_layer_original
{
	var originalLeft;
	var originalTop;
	var originalWidth;
	var originalHeight;
	var originalInnerWidth;
	var originalInnerHeight;

	var scrollXOffset = 0;
	var scrollYOffset = 0;

	property transformedScrollXOffset { getter { return scrollXOffset; } }

	// Under normal conditions result=-scrollYOffset, but this transformation considers different scale/wide factors.
	property transformedScrollYOffset { getter {
		var scale = scrollYOffset / 150; // 0: image unchanged, 150: image scrolled all the way to the bottom.
		var factor = wideScreen? wideFactor : cropFactor;
@if(SCALE_USING_FLOATING_POINT)
		var result = originalResHeight * (Math.abs(1 - factor)    ) * scale / wideFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		var result = originalResHeight * (Math.abs(1 - factor) | 0) * scale \ wideFactor;
@endif
		return result;
	} }

	property widthScale { getter { return wideScaleFactor; } }
	property heightScale { getter { return scaleFactor * (isMainWindow? cropFactor : 1); } }
	property isMainWindow { getter { return this === global.Window.mainWindow; } }
	property body { getter() { return fore; } }

@if(ZOOM_WINDOW)
@if(SCALE_USING_FLOATING_POINT)
	property innerWidthScale { getter { return innerWidth / exWidth; } }
	property innerHeightScale { getter { return innerHeight / exHeight; } }
@endif
@if(!SCALE_USING_FLOATING_POINT)
	property innerWidthScale { getter { return innerWidth \ exWidth; } }
	property innerHeightScale { getter { return innerHeight \ exHeight; } }
@endif
@endif

	property isHd
	{
		getter
		{
			if (!hdPatchExists) {
				return false;
			}
			if (!isMainWindow) {
				return mainWindow.scflags[hdFlagName];
			}
			if (this.scflags[hdFlagName] === void) {
				this.scflags[hdFlagName] = hdPatchExists && System.desktopWidth >= highResWidth && System.desktopHeight >= highResHeight;
			}
			return this.scflags[hdFlagName];
		}
		setter(v)
		{
			this.scflags[hdFlagName] = v;
		}
	}

	property wideScreen
	{
		getter
		{
			if (!hdPatchExists) {
				return false;
			}
			if (!isMainWindow) {
				// return mainWindow.scflags[wideScreenFlagName];
				return false;
			}
			if (this.scflags[wideScreenFlagName] === void) {
				this.scflags[wideScreenFlagName] = false;
			}
			return this.scflags[wideScreenFlagName];
		}
		setter(v)
		{
			this.scflags[wideScreenFlagName] = v;
		}
	}

	property wideRatio
	{
		getter
		{
			var retvalue;
			if (!wideScreen)
			{
				retvalue = cubicRatio;
			}
			else if (this.scflags[autoWideRatioFlagName])
			{
				retvalue = systemRatio;
			}
			else
			{
				retvalue = this.scflags[wideRatioFlagName] != void? this.scflags[wideRatioFlagName] : systemRatio;
			}
@if(!SCALE_USING_FLOATING_POINT)
			retvalue |= 0;
@endif
			return retvalue;
		}
	}

	property left
	{
		getter
		{
			if (isMainWindow) {
				return super.left;
			} else {
				return originalLeft;
			}
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			if (isMainWindow) {
				super.left = v;
			} else {
				originalLeft = v;
				super.left = (v-mainWindow.left) * widthScale + mainWindow.left;
			}
		}
	}

	property top
	{
		getter
		{
			if (isMainWindow) {
				return super.top;
			} else {
				return originalTop;
			}
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			if (isMainWindow) {
				super.top = v;
			} else {
				originalTop = v;
				super.top = (v-mainWindow.top) * heightScale + mainWindow.top;
			}
		}
	}

	property width
	{
		getter
		{
			return originalWidth;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			originalWidth = v;
			super.width = v * widthScale;
		}
	}

	property height
	{
		getter
		{
			return originalHeight;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			originalHeight = v;
			super.height = v * heightScale;
		}
	}

	property innerWidth
	{
		getter
		{
			return originalInnerWidth;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			originalInnerWidth = v;
			super.innerWidth = v * widthScale;
		}
	}

	property innerHeight
	{
		getter
		{
			return originalInnerHeight;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			originalInnerHeight = v;
			super.innerHeight = v * heightScale;
		}
	}

	function Window_patch_hd_layer_override()
	{
		super.Window(...);
		originalLeft = super.left;
		originalTop = super.top;
		originalWidth = super.width;
		originalHeight = super.height;
		originalInnerWidth = super.innerWidth;
		originalInnerHeight = super.innerHeight;
	}

	function Window()
	{
		Window_patch_hd_layer_override(...);
	}

	function setPos(left, top)
	{
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
@endif
		if (isMainWindow) {
			super.setPos(left, top);
		} else {
			originalLeft = left;
			originalTop = top;
			super.setPos((left-mainWindow.left) * widthScale + mainWindow.left, (top-mainWindow.top) * heightScale + mainWindow.top);
		}
	}

	function setInnerSize(innerWidth, innerHeight)
	{
@if(!SCALE_USING_FLOATING_POINT)
		innerWidth = ((innerWidth < 0 ? -innerWidth : innerWidth) & 0x7fffffff) * (innerWidth < 0 ? -1 : 1);
		innerHeight = ((innerHeight < 0 ? -innerHeight : innerHeight) & 0x7fffffff) * (innerHeight < 0 ? -1 : 1);
@endif
		originalInnerWidth = innerWidth;
		originalInnerHeight = innerHeight;
		super.setInnerSize(innerWidth * widthScale, innerHeight * heightScale);

@if(SCALE_USING_FLOATING_POINT)
		originalWidth = super.width / widthScale;
		originalHeight = super.height / heightScale;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		originalWidth = super.width \ widthScale;
		originalHeight = super.height \ heightScale;
@endif
	}

	function setSize(width, height)
	{
@if(!SCALE_USING_FLOATING_POINT)
		width = ((width < 0 ? -width : width) & 0x7fffffff) * (width < 0 ? -1 : 1);
		height = ((height < 0 ? -height : height) & 0x7fffffff) * (height < 0 ? -1 : 1);
@endif
		originalWidth = width;
		originalHeight = height;
		super.setSize(width * widthScale, height * heightScale);

@if(SCALE_USING_FLOATING_POINT)
		originalInnerWidth = super.innerWidth / widthScale;
		originalInnerHeight = super.innerHeight / heightScale;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		originalInnerWidth = super.innerWidth \ widthScale;
		originalInnerHeight = super.innerHeight \ heightScale;
@endif
	}
}
global.Window = Window_patch_hd_layer_override;

global.VideoOverlay_patch_hd_layer_original = VideoOverlay;
class VideoOverlay_patch_hd_layer_override extends VideoOverlay_patch_hd_layer_original
{
	function VideoOverlay_patch_hd_layer_override()
	{
		super.VideoOverlay(...);
	}

	function VideoOverlay()
	{
		VideoOverlay_patch_hd_layer_override(...);
	}

	property originalWidth
	{
		getter
		{
@if(SCALE_USING_FLOATING_POINT)
			return super.originalWidth / wideScaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
			return super.originalWidth \ wideScaleFactor;
@endif
		}
	}

	property originalHeight
	{
		getter
		{
@if(SCALE_USING_FLOATING_POINT)
			return super.originalHeight / scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
			return super.originalHeight \ scaleFactor;
@endif
		}
	}

	function setBounds(left, top, width, height)
	{
		return super.setBounds(left*wideScaleFactor, top*scaleFactor, width*wideScaleFactor, height*scaleFactor);
	}
}
global.VideoOverlay = VideoOverlay_patch_hd_layer_override;
