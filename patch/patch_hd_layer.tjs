
global.hdExtension = ".webp";
@if(GAME_FATE)
global.upscaledFactor = 1.6;
@endif
@if(GAME_FHAT||GAME_WOHN)
global.upscaledFactor = 2;
@endif

global.originalToHdName = %[
@if(GAME_FATE)
	"01空・雨(夜)" => "01空・雨（夜）", // Different parentheses (only in RN - in HA ht eparentheses are ascii)
@endif
	"fate" => "fate2",
	"el_タイガー0段階" => "30_tiger_00a",
	"el_タイガー1段階" => "30_tiger_01a",
	"el_タイガー2段階" => "30_tiger_02a",
	"el_タイガー3段階" => "30_tiger_03a",
	"el_タイガー4段階" => "30_tiger_04a",
];
global.messageLayerImages = ["tw_ノーマル(薄い)", "tw_ノーマル(通常)", "tw_ノーマル(濃い)", "tw_たいがー(通常)", "tw_たいがー(模様)"];
global.messageBreakImages = ["linebreak_a", "pagebreak_a"];

global.imageNameToNumberOfImages = %[
	"pt_number" => 10,
@if(GAME_FATE||GAME_FHAT)
	"linebreak_a" => 21,
@endif
@if(GAME_WOHN)
	"linebreak_a" => 40,
@endif
	"pagebreak_a" => 16,
	"pagebreak_a.png" => 21, // 21 in low res

	// scrollbar
	"scroll_basetop" => 4,
	"scroll_base" => 4,
	"scroll_basebottom" => 4,
	"scroll_slidertop" => 4,
	"scroll_slidertop4fnt" => 4,
	"scroll_slider" => 4,
	"scroll_slider4fnt" => 4,
	"scroll_sliderbottom" => 4,
	"scroll_sliderbottom4fnt" => 4,

	"voicescroll_basetop" => 4,
	"voicescroll_base" => 4,
	"voicescroll_basebottom" => 4,
	"voicescroll_slidertop" => 4,
	"voicescroll_slider" => 4,
	"voicescroll_sliderbottom" => 4,

	// horizontal scrollbar
	"scroll_top_horizontal" => 4,
	"scroll_base_horizontal" => 4,
	"scroll_bottom_horizontal" => 4,

	// music menu scrollbar
	"music_tab_t" => 4,
	"music_tab_c" => 4,
	"music_tab_b" => 4,

	"qs_f1" => 2,
	"qs_f2" => 2,
	"qs_f3" => 2,
	"qs_f4" => 2,
	"qs_f5" => 2,
	"qs_f6" => 2,
	"qs_f7" => 2,
	"qs_f8" => 2,
	"qs_f9" => 2,
	"qs_f10" => 2,
	"qs_f11" => 2,
	"qs_f12" => 2,

	"wp_選択バー" => 2,

	"fnt_opacnum" => 10,
	"scroll_slidertop4fnt" => 4,
	"scroll_slider4fnt" => 4,
	"scroll_sliderbottom4fnt" => 4,

	"scroll_slidertop4opac" => 4,
	"scroll_sliderbottom4opac" => 4,
	"scroll_slider4opac" => 4
];

global.fixedBgImages = [
	"black" // Sometimes used for letter-boxing, in which case it needs a special treatment.
];
global.movingBgImages = [
	"c_cs16(03落石)", "cs29アンリマユ崩壊(01落石大)",
	"csラストep04(雲01)", "csラストep04(雲02)", "csラストep04(雲03)", "csラストep04(雲04)"
];
global.bottomImages = [ // A bottom aligned image moving from negative to positive top position, in which case it needs a special treatment.
	"rogo_ai",
	"rogo_bi2",
	"cs29アンリマユ崩壊(04手前岩盤・右)"
];
global.ps2BgImages = ["c_cs03", "csラストep07b", "csラストep08b"];

function transformDiscrete(v, scale)
{
@if(SCALE_USING_FLOATING_POINT)
	// To avoids rounding errors when summing, rounding should occur only after scaling.
	// Using "round" is probably better than "int" but it causes tearing in the yes/no button when you hover over it.
@if(SCALE_ROUND_TOWARDS_NEAREST)
	return global.Math.round(v * scale) / scale;
@endif
@if(!SCALE_ROUND_TOWARDS_NEAREST)
	return ((v * scale) | 0) / scale;
@endif
@endif
@if(!SCALE_USING_FLOATING_POINT)
	return v | 0;
@endif
}

global.Layer_patch_hd_layer_original	= Layer;
class Layer_patch_hd_layer_override extends Layer_patch_hd_layer_original
{
	var imageStorage = void;
	var isHd = false;

	var _originalLeft = 0;
	var originalTop = 0;
	var originalImageLeft = 0;
	var originalImageTop = 0;
	var originalWidth = 32;
	var originalHeight = 32;
	var originalImageWidth = 32;
	var originalImageHeight = 32;
	var originalClipLeft = 0;
	var originalClipTop = 0;
	var originalClipWidth = void;
	var originalClipHeight = void;
	var originalAttentionLeft = 0;
	var originalAttentionTop = 0;

	var isbg = false;
	var fullScreenBg = false; // For bg images that occupy the whole screen.
	var fixedbg = false; // Used for bg images that are fixed.
	var movingbg = false; // Used for fixed bg images that move.
	var bottomImage = false; // Used for images that are bottom aligned (most cases are handled automatically - this is for exceptions).
	var stretch = void;
	var isMask = false; // Set to true to suppress automatic determination of isbg.
	var isThumbnail = false;
	var isTicketThumbnail = false;

	var _isFixedPosition = void;
	var _horizontalAlignment = 0.5;
	var _verticalAlignment = 0;

	var numberOfImages = 1;

	var absoluteMode = 0;

	function transformDiscreteLeft(v) {
@if(SCALE_USING_FLOATING_POINT)
		var scale = this.leftScale();
		// To avoids rounding errors when summing, rounding should occur only after scaling.
		// Using "round" is probably better than "int" but it causes tearing in the yes/no button when you hover over it.
@if(SCALE_ROUND_TOWARDS_NEAREST)
		return global.Math.round(v * scale) / scale;
@endif
@if(!SCALE_ROUND_TOWARDS_NEAREST)
		return ((v * scale) | 0) / scale;
@endif
@endif
@if(!SCALE_USING_FLOATING_POINT)
		return v | 0;
@endif
	}

	function transformDiscreteTop(v) {
@if(SCALE_USING_FLOATING_POINT)
		var scale = this.topScale();
		// To avoids rounding errors when summing, rounding should occur only after scaling.
		// Using "round" is probably better than "int" but it causes tearing in the yes/no button when you hover over it.
@if(SCALE_ROUND_TOWARDS_NEAREST)
		return global.Math.round(v * scale) / scale;
@endif
@if(!SCALE_ROUND_TOWARDS_NEAREST)
		return ((v * scale) | 0) / scale;
@endif
@endif
@if(!SCALE_USING_FLOATING_POINT)
		return v | 0;
@endif
	}

	function onClick_patch_hd_layer_override(x, y)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
@endif
		this.onClick_patch_hd_layer_original(x, y);
	}

	property onClick_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onClick_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onClick_patch_hd_layer_original = v;
		}
	}

	function onDoubleClick_patch_hd_layer_override(x, y)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
@endif
@if(SCALE_ROUND_TOWARDS_NEAREST)
		x = global.Math.round(x) | 0;
		y = global.Math.round(y) | 0;
@endif
		this.onDoubleClick_patch_hd_layer_original(x, y);
	}

	property onDoubleClick_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onDoubleClick_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onDoubleClick_patch_hd_layer_original = v;
		}
	}

	function onMouseDown_patch_hd_layer_override(x, y, button, shift)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
@endif
@if(SCALE_ROUND_TOWARDS_NEAREST)
		x = global.Math.round(x) | 0;
		y = global.Math.round(y) | 0;
@endif
		this.onMouseDown_patch_hd_layer_original(x, y, button, shift);
	}

	property onMouseDown_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onMouseDown_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onMouseDown_patch_hd_layer_original = v;
		}
	}

	function onMouseUp_patch_hd_layer_override(x, y, button, shift)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
@endif
@if(SCALE_ROUND_TOWARDS_NEAREST)
		x = global.Math.round(x) | 0;
		y = global.Math.round(y) | 0;
@endif
		this.onMouseUp_patch_hd_layer_original(x, y, button, shift);
	}

	property onMouseUp_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onMouseUp_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onMouseUp_patch_hd_layer_original = v;
		}
	}

	function onMouseMove_patch_hd_layer_override(x, y, shift)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
@endif
@if(SCALE_ROUND_TOWARDS_NEAREST)
		x = global.Math.round(x) | 0;
		y = global.Math.round(y) | 0;
@endif
		this.onMouseMove_patch_hd_layer_original(x, y, shift);
	}

	property onMouseMove_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onMouseMove_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onMouseMove_patch_hd_layer_original = v;
		}
	}

	function onMouseWheel_patch_hd_layer_override(shift, delta, x, y)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
@endif
@if(SCALE_ROUND_TOWARDS_NEAREST)
		x = global.Math.round(x) | 0;
		y = global.Math.round(y) | 0;
@endif
		this.onMouseWheel_patch_hd_layer_original(shift, delta, x, y);
	}

	property onMouseWheel_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onMouseWheel_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onMouseWheel_patch_hd_layer_original = v;
		}
	}

	function onHitTest_patch_hd_layer_override(x, y, hit)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
@endif
@if(SCALE_ROUND_TOWARDS_NEAREST)
		x = global.Math.round(x) | 0;
		y = global.Math.round(y) | 0;
@endif
		this.onHitTest_patch_hd_layer_original(x, y, hit);
	}

	property onHitTest_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onHitTest_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onHitTest_patch_hd_layer_original = v;
		}
	}

	function onTouchDown_patch_hd_layer_override(x, y, cx, cy, id)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
		cx /= wideScaleFactor;
		cy /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
		cx \= wideScaleFactor;
		cy \= scaleFactor;
@endif
@if(SCALE_ROUND_TOWARDS_NEAREST)
		x = global.Math.round(x) | 0;
		y = global.Math.round(y) | 0;
		cx = global.Math.round(cx) | 0;
		cy = global.Math.round(cy) | 0;
@endif
		this.onTouchDown_patch_hd_layer_original(x, y, cx, cy, id);
	}

	property onTouchDown_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onTouchDown_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onTouchDown_patch_hd_layer_original = v;
		}
	}

	function onTouchUp_patch_hd_layer_override(x, y, cx, cy, id)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
		cx /= wideScaleFactor;
		cy /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
		cx \= wideScaleFactor;
		cy \= scaleFactor;
@endif
@if(SCALE_ROUND_TOWARDS_NEAREST)
		x = global.Math.round(x) | 0;
		y = global.Math.round(y) | 0;
		cx = global.Math.round(cx) | 0;
		cy = global.Math.round(cy) | 0;
@endif
		this.onTouchUp_patch_hd_layer_original(x, y, cx, cy, id);
	}

	property onTouchUp_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onTouchUp_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onTouchUp_patch_hd_layer_original = v;
		}
	}

	function onTouchMove_patch_hd_layer_override(x, y, cx, cy, id)
	{
@if(SCALE_USING_FLOATING_POINT)
		x /= wideScaleFactor;
		y /= scaleFactor;
		cx /= wideScaleFactor;
		cy /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		x \= wideScaleFactor;
		y \= scaleFactor;
		cx \= wideScaleFactor;
		cy \= scaleFactor;
@endif
@if(SCALE_ROUND_TOWARDS_NEAREST)
		x = global.Math.round(x) | 0;
		y = global.Math.round(y) | 0;
		cx = global.Math.round(cx) | 0;
		cy = global.Math.round(cy) | 0;
@endif
		this.onTouchMove_patch_hd_layer_original(x, y, cx, cy, id);
	}

	property onTouchMove_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onTouchMove_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onTouchMove_patch_hd_layer_original = v;
		}
	}

	function onTouchScaling_patch_hd_layer_override(startdistance, currentdistance, cx, cy, flag)
	{
		// XXX: startdistance and currentdistance need to be interpolated
@if(SCALE_USING_FLOATING_POINT)
		cx /= wideScaleFactor;
		cy /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		cx \= wideScaleFactor;
		cy \= scaleFactor;
@endif
@if(SCALE_ROUND_TOWARDS_NEAREST)
		cx = global.Math.round(cx) | 0;
		cy = global.Math.round(cy) | 0;
@endif
		this.onTouchScaling_patch_hd_layer_original(startdistance, currentdistance, cx, cy, flag);
	}

	property onTouchScaling_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onTouchScaling_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onTouchScaling_patch_hd_layer_original = v;
		}
	}

	function onTouchRotate_patch_hd_layer_override(startangle, currentangle, distance, cx, cy, flag)
	{
		// XXX: distance need to be interpolated
@if(SCALE_USING_FLOATING_POINT)
		cx /= wideScaleFactor;
		cy /= scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		cx \= wideScaleFactor;
		cy \= scaleFactor;
@endif
@if(SCALE_ROUND_TOWARDS_NEAREST)
		cx = global.Math.round(cx) | 0;
		cy = global.Math.round(cy) | 0;
@endif
		this.onTouchRotate_patch_hd_layer_original(startangle, currentangle, distance, cx, cy, flag);
	}

	property onTouchRotate_patch_hd_layer_property_shim
	{
		getter
		{
			return this.onTouchRotate_patch_hd_layer_override;
		}
		setter(v)
		{
			this.onTouchRotate_patch_hd_layer_original = v;
		}
	}

	function patch_hd_layer_setup_event_shims()
	{
		if (typeof(this.onClick) === "Object")
		{
			this.onClick_patch_hd_layer_original = this.onClick;
		}
		else
		{
			this.onClick_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onDoubleClick) === "Object")
		{
			this.onDoubleClick_patch_hd_layer_original = this.onDoubleClick;
		}
		else
		{
			this.onDoubleClick_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onMouseDown) === "Object")
		{
			this.onMouseDown_patch_hd_layer_original = this.onMouseDown;
		}
		else
		{
			this.onMouseDown_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onMouseUp) === "Object")
		{
			this.onMouseUp_patch_hd_layer_original = this.onMouseUp;
		}
		else
		{
			this.onMouseUp_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onMouseMove) === "Object")
		{
			this.onMouseMove_patch_hd_layer_original = this.onMouseMove;
		}
		else
		{
			this.onMouseMove_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onMouseWheel) === "Object")
		{
			this.onMouseWheel_patch_hd_layer_original = this.onMouseWheel;
		}
		else
		{
			this.onMouseWheel_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onHitTest) === "Object")
		{
			this.onHitTest_patch_hd_layer_original = this.onHitTest;
		}
		else
		{
			this.onHitTest_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onTouchDown) === "Object")
		{
			this.onTouchDown_patch_hd_layer_original = this.onTouchDown;
		}
		else
		{
			this.onTouchDown_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onTouchUp) === "Object")
		{
			this.onTouchUp_patch_hd_layer_original = this.onTouchUp;
		}
		else
		{
			this.onTouchUp_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onTouchMove) === "Object")
		{
			this.onTouchMove_patch_hd_layer_original = this.onTouchMove;
		}
		else
		{
			this.onTouchMove_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onTouchScaling) === "Object")
		{
			this.onTouchScaling_patch_hd_layer_original = this.onTouchScaling;
		}
		else
		{
			this.onTouchScaling_patch_hd_layer_original = function() {};
		}
		if (typeof(this.onTouchRotate) === "Object")
		{
			this.onTouchRotate_patch_hd_layer_original = this.onTouchRotate;
		}
		else
		{
			this.onTouchRotate_patch_hd_layer_original = function() {};
		}
		&this.onClick = &this.onClick_patch_hd_layer_property_shim;
		&this.onDoubleClick = &this.onDoubleClick_patch_hd_layer_property_shim;
		&this.onMouseDown = &this.onMouseDown_patch_hd_layer_property_shim;
		&this.onMouseUp = &this.onMouseUp_patch_hd_layer_property_shim;
		&this.onMouseMove = &this.onMouseMove_patch_hd_layer_property_shim;
		&this.onMouseWheel = &this.onMouseWheel_patch_hd_layer_property_shim;
		&this.onHitTest = &this.onHitTest_patch_hd_layer_property_shim;
		&this.onTouchDown = &this.onTouchDown_patch_hd_layer_property_shim;
		&this.onTouchUp = &this.onTouchUp_patch_hd_layer_property_shim;
		&this.onTouchMove = &this.onTouchMove_patch_hd_layer_property_shim;
		&this.onTouchScaling = &this.onTouchScaling_patch_hd_layer_property_shim;
		&this.onTouchRotate = &this.onTouchRotate_patch_hd_layer_property_shim;
	}

	property horizontalAlignment
	{
		getter
		{
			return this._horizontalAlignment;
		}
		setter(v)
		{
			this._horizontalAlignment = v;
			left = left;
		}
	}

	property verticalAlignment
	{
		getter
		{
			return this._verticalAlignment;
		}
		setter(v)
		{
			this._verticalAlignment = v;
			top = top;
		}
	}

	property leftOriginal { getter {return super.left; } }
	property topOriginal { getter {return super.top; } }
	property widthOriginal { getter {return super.width; } }
	property heightOriginal { getter {return super.height; } }
	property imageWidthOriginal { getter { return super.imageWidth; } }
	property imageHeightOriginal { getter { return super.imageHeight; } }

	property left
	{
		getter
		{
			if (this.absoluteMode) {
				return super.left;
			}
			return this._originalLeft;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			this._originalLeft = transformDiscreteLeft(v);
			super.left = this.transformLeft(this._originalLeft);
		}
	}

	property top
	{
		getter
		{
			if (this.absoluteMode) {
				return super.top;
			}
			return this.originalTop;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			this.originalTop = transformDiscreteTop(v);
			super.top = this.transformTop(this.originalTop);
		}
	}

	property imageLeft
	{
		getter
		{
			if (this.absoluteMode) {
				return super.imageLeft;
			}
			return this.originalImageLeft;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			this.originalImageLeft = transformDiscrete(v, this.widthScale);
			var val = v*this.widthScale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
			val = global.Math.round(val) | 0;
@endif
			super.imageLeft = val;
		}
	}

	property imageTop
	{
		getter
		{
			if (this.absoluteMode) {
				return super.imageTop;
			}
			return this.originalImageTop;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			this.originalImageTop = transformDiscrete(v, this.heightScale);
			var val = v*this.heightScale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
			val = global.Math.round(val) | 0;
@endif
			super.imageTop = val;
		}
	}

	property clipLeft
	{
		getter
		{
			if (this.absoluteMode) {
				return super.clipLeft;
			}
			return this.originalClipLeft;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			(global.Layer.setClip incontextof this)(v, this.originalClipTop, this.originalClipWidth, this.originalClipHeight);
		}
	}

	property clipTop
	{
		getter
		{
			if (this.absoluteMode) {
				return super.clipTop;
			}
			return this.originalClipTop;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			(global.Layer.setClip incontextof this)(this.originalClipLeft, v, this.originalClipWidth, this.originalClipHeight);
		}
	}


	property clipWidth
	{
		getter
		{
			if (this.absoluteMode) {
				return super.clipWidth;
			}
			return this.originalClipWidth;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			(global.Layer.setClip incontextof this)(this.originalClipLeft, this.originalClipTop, v, this.originalClipHeight);
		}
	}

	property clipHeight
	{
		getter
		{
			if (this.absoluteMode) {
				return super.clipHeight;
			}
			return this.originalClipHeight;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			(global.Layer.setClip incontextof this)(this.originalClipLeft, this.originalClipTop, this.originalClipWidth, v);
		}
	}

	property attentionLeft
	{
		getter
		{
			if (this.absoluteMode) {
				return super.attentionLeft;
			}
			return this.originalAttentionLeft;
		}
		setter(v)
		{
			this.originalAttentionLeft = transformDiscrete(v, this.widthScale);
			var val = v*this.widthScale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
			val = global.Math.round(val) | 0;
@endif
			super.attentionLeft = val;
		}
	}

	property attentionTop
	{
		getter
		{
			if (this.absoluteMode) {
				return super.attentionTop;
			}
			return this.originalAttentionTop;
		}
		setter(v)
		{
			this.originalAttentionTop = transformDiscrete(v, this.heightScale);
			var val = v*this.heightScale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
			val = global.Math.round(val) | 0;
@endif
			super.attentionTop = val;
		}
	}

	property cursorX
	{
		getter
		{
			if (this.absoluteMode) {
				return super.cursorX;
			}
@if(SCALE_USING_FLOATING_POINT)
			var val = super.cursorX / this.cursorXScale;
@endif
@if(!SCALE_USING_FLOATING_POINT)
			var val = super.cursorX \ this.cursorXScale;
@endif
@if(SCALE_ROUND_TOWARDS_NEAREST)
			val = global.Math.round(val) | 0;
@endif
			return val;
		}
		setter(v)
		{
			var originalCursorX = transformDiscrete(v, this.cursorXScale);
			super.cursorX = this.transformCursorX(originalCursorX);
		}
	}

	property cursorY
	{
		getter
		{
			if (this.absoluteMode) {
				return super.cursorY;
			}
@if(SCALE_USING_FLOATING_POINT)
			var val = (super.cursorY - this.cursorYOffset() * wideScaleFactor) / this.cursorYScale;
@endif
@if(!SCALE_USING_FLOATING_POINT)
			var val = (super.cursorY - this.cursorYOffset() * wideScaleFactor) \ this.cursorYScale;
@endif
@if(SCALE_ROUND_TOWARDS_NEAREST)
			val = global.Math.round(val) | 0;
@endif
			return val;
		}
		setter(v)
		{
			var originalCursorY = transformDiscrete(v, this.cursorYScale);
			super.cursorY = this.transformCursorY(originalCursorY);
		}
	}

	property width
	{
		getter
		{
			if (this.absoluteMode) {
				return super.width;
			}
			return this.originalWidth;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			if (v < 0)
			{
				v = -v;
			}
			v &= 0xffffffff;
@endif
			this.originalWidth = transformDiscrete(v, this.widthScale);
			var val = v * this.widthScale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
			val = global.Math.round(val) | 0;
@endif
			super.width = val;
			this.updateImageSize();
		}
	}

	property height
	{
		getter
		{
			if (this.absoluteMode) {
				return super.height;
			}
			return this.originalHeight;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			if (v < 0)
			{
				v = -v;
			}
			v &= 0xffffffff;
@endif
			this.originalHeight = transformDiscrete(v, this.heightScale);
			var val = v * this.heightScale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
			val = global.Math.round(val) | 0;
@endif
			super.height = val;
			this.updateImageSize();
		}
	}

	property imageWidth
	{
		getter
		{
@if(0)
			if (this.widthScale == 1)
			{
				if (super.imageWidth != this.originalImageWidth)
				{
					dm("warning: image width " + super.imageWidth + " does not match orig " + this.originalImageWidth);
				}
			}
@endif
			if (this.absoluteMode) {
				return super.imageWidth;
			}
			return this.originalImageWidth;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			if (v < 0)
			{
				v = -v;
			}
			v &= 0xffffffff;
@endif
			this.originalImageWidth = transformDiscrete(v, this.widthScale);
			if (this.originalImageWidth < this.originalWidth)
			{
				this.originalImageLeft = 0;
				this.originalWidth = this.originalImageWidth;
			}
			if (this.originalImageWidth + this.originalImageLeft < this.originalWidth)
			{
				this.originalImageLeft = this.originalWidth - this.originalImageWidth;
			}
			this.resetClip();
			var val = v * this.widthScale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
			val = global.Math.round(val) | 0;
@endif
			super.imageWidth = val;
		}
	}

	property imageHeight
	{
		getter
		{
@if(0)
			if (this.heightScale == 1)
			{
				if (super.imageHeight != this.originalImageHeight)
				{
					dm("warning: image height " + super.imageHeight + " does not match orig " + this.originalImageHeight);
				}
			}
@endif
			if (this.absoluteMode) {
				return super.imageHeight;
			}
			return this.originalImageHeight;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			if (v < 0)
			{
				v = -v;
			}
			v &= 0xffffffff;
@endif
			this.originalImageHeight = transformDiscrete(v, this.heightScale);
			if (this.originalImageHeight < this.originalHeight)
			{
				this.originalImageTop = 0;
				this.originalHeight = this.originalImageHeight;
			}
			if (this.originalImageHeight + this.originalImageTop < this.originalHeight)
			{
				this.originalImageTop = this.originalHeight - this.originalImageHeight;
			}
			this.resetClip();
			var val = v * this.heightScale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
			val = global.Math.round(val) | 0;
@endif
			super.imageHeight = val;
		}
	}

	function resetClip()
	{
		this.originalClipLeft = 0;
		this.originalClipTop = 0;
		this.originalClipWidth = this.originalImageWidth;
		this.originalClipHeight = this.originalImageHeight;
	}

	function setInitialImageProperties()
	{
		if (!super.hasImage)
		{
			this.originalImageLeft = 0;
			this.originalImageTop = 0;
			this.originalImageWidth = this.originalWidth;
			this.originalImageHeight = this.originalHeight;
		}
		this.resetClip();
	}

	property hasImage
	{
		getter
		{
			return super.hasImage;
		}
		setter(v)
		{
			if (v)
			{
				this.setInitialImageProperties();
			}
			super.hasImage = v;
		}
	}

	property type
	{
		getter
		{
			return super.type;
		}
		setter(v)
		{
			if (super.type != v)
			{
				switch (super.type)
				{
					case ltOpaque:
					case ltAlpha:
					case ltAdditive:
					case ltSubtractive:
					case ltMultiplicative:
					case ltDodge:
					case ltDarken:
					case ltLighten:
					case ltScreen:
					case ltAddAlpha:
					case ltPsNormal:
					case ltPsAdditive:
					case ltPsSubtractive:
					case ltPsMultiplicative:
					case ltPsScreen:
					case ltPsOverlay:
					case ltPsHardLight:
					case ltPsSoftLight:
					case ltPsColorDodge:
					case ltPsColorDodge5:
					case ltPsColorBurn:
					case ltPsLighten:
					case ltPsDarken:
					case ltPsDifference:
					case ltPsDifference5:
					case ltPsExclusion:
						this.setInitialImageProperties();
						break;
					default:
						break;
				}
			}
			super.type = v;
		}
	}

	function leftScale(parent=this.parent)
	{
		if (parent === null) {
			return 1;
		}
		return parent.widthScale;
	}

	function topScale(parent=this.parent)
	{
		if (parent === null) {
			return 1;
		}
		if (this.isbg) {
			if (this.fixedbg || this.fullScreenBg) {
				return scaleFactor;
			}
			return parent.heightScale;
		}
		return scaleFactor;
	}

	property cursorXScale { getter { return wideScaleFactor; } }
	property cursorYScale { getter { return scaleFactor; } }

	property widthScale
	{
		getter
		{
			if (this.absoluteMode)
			{
				return 1;
			}
			if (this.isbg || this.shouldStretch) {
				return wideScaleFactor;
			}
			return scaleFactor;
		}
	}

	property heightScale
	{
		getter
		{
			if (this.absoluteMode)
			{
				return 1;
			}
			if (this.isbg) {
				return wideScaleFactor;
			}
			if (this.isMessageLayer && isCropped) {
				return scaleFactor*cropFactor;
			}
			return scaleFactor;
		}
	}

	property leftOffset
	{
		getter
		{
			if (!this.window.wideScreen) return 0;
			if (this.isSysBase) {
				return -this.window.transformedScrollXOffset;
			}
			if ((!this.isbg || this.fixedbg) && this.isFixedPosition) {
				return this.window.transformedScrollXOffset;
			}
			return 0;
		}
	}

	function topOffset(parent=this.parent)
	{
		if (!this.window.wideScreen) return 0;
		if (this.isSysBase) {
			return -this.window.transformedScrollYOffset;
		}
		if ((!this.isbg || this.fixedbg) && this.isFixedPosition && (parent != null && parent.isbg)) {
			return this.window.transformedScrollYOffset;
		}
		return 0;
	}

	function cursorYOffset(parent=this.parent)
	{
		var offset = 0;
		if (isPrimary) {
			offset = this.window.transformedScrollYOffset;
		}
		return offset;
	}

	function leftPivot(parent=this.parent)
	{
		var result = 0;
		if (!this.shouldStretch && !this.isbg && (parent !== null && (parent.isbg || parent.shouldStretch) && !parent.isLineLayer ))
		{
@if(SCALE_USING_FLOATING_POINT)
			result = width * (wideFactor - 1) * this.horizontalAlignment / wideFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
			result = width * (wideFactor - 1) * this.horizontalAlignment \ wideFactor;
			result |= 0;
@endif

			// Applying the correction only to sprites, otherwise the blur function is buggy (I'm pretty sure it's only applied to sprites anyway...)
			if (["Integer", "Real"].find(typeof(this.correctleft)) !== -1) {
@if(SCALE_USING_FLOATING_POINT)
				result += this.correctleft / wideFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
				result += this.correctleft \ wideFactor;
@endif
			}
		}
		return result;
	}

	function topPivot(top, parent=this.parent)
	{
		// TODO fix left pivot for negative values (use effective value like here).
		// For BG Images used as regular images
		if (this.isbg && this.fixedbg) {
			var effectiveVerticalAlignment = this.verticalAlignment;
			if (this.bottomImage) {
				effectiveVerticalAlignment = this.verticalAlignment-1;
			}
			else if (!this.movingbg) {
				effectiveVerticalAlignment = top>=0? this.verticalAlignment : this.verticalAlignment-1;
			}
			//var effectiveVerticalAlignment = Math.atan(top)/Math.PI-0.5; // Smoothing function
			return height*(wideFactor-1)*effectiveVerticalAlignment;
		}
		return 0;
	}

	property scaleAlgorithm
	{
		getter
		{
			if (this.isExButtonLayer) {
				return stLinear;
			}
			return stCubic;
		}
	}

	property shouldStretch { getter {
		if (this.stretch !== void) {
			return this.stretch;
		}
		if (typeof this.window.sflags === "Object" && !this.window.sflags.wideStrechWindow && (this.isMessageLayer || this.isLineLayer)) {
			return false;
		}
		return this.isMessageLayer || this.isLineLayer || this.isHistoryLayer || this.isCinescoLayer || this.isYesNoBackground || this.isGameMenuLayer || this.isShortcutBaseLayer;
	} }

	property isHistoryLayer { getter {
		return this instanceof "HistoryLayer";
	} }

	property isMessageLayer { getter {
		return this instanceof "MessageLayer";
	} }

	property isLineLayer { getter {
		return parent instanceof "MessageLayer" && !this.isClickGlyphLayer;
	} }

	property isGameMenuLayer { getter {
		return this instanceof "GameMenuLayer";
	} }

	property isShortcutBaseLayer { getter {
		return this instanceof "ShortcutBaseLayer";
	} }

	property isCharacterLayer { getter {
		return this instanceof "CharacterLayer";
	} }

	property isBaseLayer { getter {
		return this instanceof "BaseLayer" || parent === null;
	} }

	property isExButtonLayer { getter {
		return this instanceof "ExButtonLayer";
	} }

	property isPopupLayer { getter {
		return this instanceof "PopUpLayer";
	} }

	property isClickGlyphLayer { getter {
		return this instanceof "ClickGlyphLayer";
	} }

	property isCinescoLayer { getter {
		return name !== void && name.substr(0,7) == "Cinesco";
	} }

	property isDateTitleLayer { getter {
		return name == "DateTitle用テンポラリ";
	} }

	property isYesNoLayer { getter {
		return this instanceof "YesNoLayer" || name == "Yes/No 問い合わせ(裏)";
	} }

	property isYesNoBackground { getter {
		return this.imageStorage !== void && ["汎用左", "汎用中", "汎用右"].contains(this.imageStorage);
	} }

	property isFlowChartLayer { getter {
		return this instanceof "FlowChartLayer";
	} }

	property isFlagListLayer { getter {
		return this instanceof "FlagListLayer";
	} }

	property isSceneDetailLayer { getter {
		return this instanceof "SceneDetailLayer";
	} }

	property isPushButtonLayer { getter {
		return this instanceof "PushButtonLayer";
	} }

	property isFixedPosition {
		getter {
			if (this._isFixedPosition !== void) {
				return this._isFixedPosition;
			}
			// Only message this.layer and not its children.
			return this.isCharacterLayer || this instanceof "MessageLayer" || this.isHistoryLayer || this.isGameMenuLayer || this.isShortcutBaseLayer || this.isPopupLayer || this.isCinescoLayer || this.isDateTitleLayer || this.isFlowChartLayer || this.isFlagListLayer || this.isYesNoLayer || this.isSceneDetailLayer || this.isPushButtonLayer;
		}
		setter(v) {
			this._isFixedPosition = v;
		}
	}

	property isSysBase {
		getter {
			return name == "トップレイヤ";
		}
	}

	function Layer_patch_hd_layer_override()
	{
		super.Layer(...);
@if(!GAME_WOHN)
		this.isbg = this.isBaseLayer;
@endif
		this.resetClip();
		this.patch_hd_layer_setup_event_shims();
	}

	function Layer()
	{
		Layer_patch_hd_layer_override(...);
	}

	function transformLeft(left, parent=this.parent)
	{
		var val = (left + this.leftOffset + this.leftPivot(parent))*this.leftScale(parent);
@if(SCALE_ROUND_TOWARDS_NEAREST)
		val = global.Math.round(val) | 0;
@endif
		return val;
	}

	function transformTop(top, parent=this.parent)
	{
		var val = (top + this.topPivot(top))*this.topScale(parent) + this.topOffset(parent)*wideScaleFactor;
@if(SCALE_ROUND_TOWARDS_NEAREST)
		val = global.Math.round(val) | 0;
@endif
		return val;
	}

	function transformCursorX(cursorX, parent=this.parent)
	{
		var val = cursorX * this.cursorXScale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
		val = global.Math.round(val) | 0;
@endif
		return val;
	}

	function transformCursorY(cursorY, parent=this.parent)
	{
		var val = cursorY * this.cursorYScale + this.cursorYOffset(parent) * wideScaleFactor;
@if(SCALE_ROUND_TOWARDS_NEAREST)
		val = global.Math.round(val) | 0;
@endif
		return val;
	}

	function updateBg(width, height, fromloadImages=false)
	{
@if(GAME_FATE||GAME_FHAT)
		if (this.isBaseLayer) {
			// Used for dialogs.
			this.isbg = !this.shouldStretch;
			this.fullScreenBg = this.isbg;
			this.fixedbg = false;
			this.movingbg = false;
			this.bottomImage = false;
		} else if (!this.shouldStretch && !this.isMask && !this.isMessageLayer) {
			this.fullScreenBg = (width == originalResWidth && height == originalResHeight);
			this.fullScreenBg |= (width == transformDiscrete(originalResWidth, wideScaleFactor) && height == transformDiscrete(originalResHeight, wideScaleFactor));

			this.fixedbg = !this.fullScreenBg;
			this.movingbg = false;
			this.bottomImage = false;

			if (fromloadImages) {
				// When loading an image, a bg can have many sizes - this check is only for bg that are not in the bgimage folder.
				this.isbg |= this.fullScreenBg;
				this.fixedbg |= fixedBgImages.contains(this.imageStorage);
				this.movingbg = movingBgImages.contains(this.imageStorage);
				this.bottomImage = bottomImages.contains(this.imageStorage);
			} else {
				// When manually setting the size (this.setSize or this.setImageSize) it's a bg only when the dimensions match.
				this.isbg = this.fullScreenBg;
			}
		}
		// background settings affect position.
		(global.Layer.setPos incontextof this)(this._originalLeft, this.originalTop);
@endif
	}

	function updateMessageLayerMobile() {
		if (this.isMessageLayer && messageLayerImages.contains(this.imageStorage) && this.window.sflags === "Object") {
			if (this.window.sflags.mobileWindow) {
				type = ltAlpha;
				lineLayer.type = ltTransparent;
			} else {
				type = ltAddAlpha;
				lineLayer.type = ltAddAlpha;
			}
		}
	}

	function update_bounds_hd_layer()
	{
		var _originalLeft_tmp = this._originalLeft;
		var originalTop_tmp = this.originalTop;
		var originalWidth_tmp = this.originalWidth;
		var originalHeight_tmp = this.originalHeight;
		var originalImageLeft_tmp = this.originalImageLeft;
		var originalImageTop_tmp = this.originalImageTop;
		var originalImageWidth_tmp = this.originalImageWidth;
		var originalImageHeight_tmp = this.originalImageHeight;
		var originalClipLeft_tmp = this.originalClipLeft;
		var originalClipTop_tmp = this.originalClipTop;
		var originalClipWidth_tmp = this.originalClipWidth;
		var originalClipHeight_tmp = this.originalClipHeight;
		var originalAttentionLeft_tmp = this.originalAttentionLeft;
		var originalAttentionTop_tmp = this.originalAttentionTop;
@if(0)
		if (super.hasImage)
		{
			super.fillRect(0, 0, super.imageWidth, super.imageHeight, 0x000000);
		}
@endif
		this.setPos_patch_hd_layer(_originalLeft_tmp, originalTop_tmp, originalWidth_tmp, originalHeight_tmp);
		if (super.hasImage)
		{
			this.setImageSize_patch_hd_layer(originalImageWidth_tmp, originalImageHeight_tmp);
			this.setImagePos_patch_hd_layer(originalImageLeft_tmp, originalImageTop_tmp);
			this.setClip_patch_hd_layer(originalClipLeft_tmp, originalClipTop_tmp, originalClipWidth_tmp, originalClipHeight_tmp);
		}
		this.setAttentionPos_patch_hd_layer(originalAttentionLeft_tmp, originalAttentionTop_tmp);
		for (var i = 0, internal_forloop_count = this.children.count; i < internal_forloop_count; i += 1)
		{
			this.children[i].update_bounds_hd_layer();
		}
	}

	function get_all_image_list(arr)
	{
		if (!this.visible)
		{
			return;
		}
		if ((typeof(this.imageStorage) === "String") && (arr.find(this.imageStorage) === -1))
		{
			arr.add(this.imageStorage);
		}
		for (var i = 0, internal_forloop_count = this.children.count; i < internal_forloop_count; i += 1)
		{
			this.children[i].get_all_image_list(arr);
		}
	}

	function loadImages(storage, key)
	{
		storage = storage.toLowerCase();
		var storageName = Storages.chopStorageExt(storage);
		var storageExt = Storages.extractStorageExt(storage);

		this.imageStorage = storageName;
		if (this.window.isHd) {
			// Some HD assets have slightly different names (but the images are the same).
			this.imageStorage = originalToHdName[this.imageStorage] if originalToHdName[this.imageStorage] !== void;
		}

@if(GAME_FATE||GAME_FHAT)
		if (messageLayerImages.contains(this.imageStorage) && typeof(this.window.sflags) === "Object" && !this.window.sflags.mobileWindow) {
			storageExt = ".png";
		} else if (messageBreakImages.contains(this.imageStorage) && typeof(this.window.sflags) === "Object" && !this.window.sflags.mobileBreakGlyphs) {
			storageExt = ".png";
		}

		this.updateMessageLayerMobile();
@endif

@if(GAME_FATE)
		// Check to see if an HD version exists.
		this.isHd = Storages.isExistentStorage(this.imageStorage + hdExtension) || this.imageStorage != storageName;
@endif
@if(GAME_FHAT||GAME_WOHN)
		this.isHd = true;
@endif

		var chosenExt = storageExt;
		if (storageExt == "") {
			for (var i = 0, internal_forloop_count = global.image_extensions.count; i < internal_forloop_count; i += 1) {
				var currentExtension = global.image_extensions[i];
				if (
					currentExtension === hdExtension
@if(ENABLE_WEBP_ON_LOW_QUALITY)
					&& this.window.isHd
@endif
				)
				{
					continue;
				}
				var currentStorage = storageName + currentExtension;

				var currentPath = Storages.getPlacedPath(currentStorage);
				if (currentPath === "")
				{
					continue;
				}

@if(GAME_FATE||GAME_FHAT)
				if (!this.isBaseLayer && !this.isMessageLayer && !this.isMask) {
					this.isbg = currentPath.indexOf("bgimage") !== -1; // TODO only works in dev mode
				}
@endif

				if (currentPath.indexOf("hd") !== -1) {
					// TODO the /hd/.test is being used twice in this method, find a way to optimize...
					this.isHd = true;
				}

				if (this.isHd) {
					var tmp = new global.Layer(this.window, this);
					(Layer_patch_hd_layer_original.loadImages incontextof tmp)(currentStorage);
					this.originalImageWidth = tmp.imageWidthOriginal;
					this.originalImageHeight = tmp.imageHeightOriginal;
					invalidate tmp;

@if(GAME_FATE||GAME_FHAT)
					if (this.imageStorage == "pagebreak_a")
					{
						// low resolution image has 21 images, but HD has 16.
						this.originalImageWidth = this.originalImageWidth / 21 * 16;
					}
					else if (this.imageStorage == "c31")
					{
						// 2 HD versions: png and webp - the png has a higher resolution.
						this.isbg = true;
						this.originalImageWidth = this.originalImageWidth / (this.window.isHd? upscaledFactor : 1);
						this.originalImageHeight = this.originalImageHeight / (this.window.isHd? upscaledFactor : 1);
					}
					else
@endif
					if (currentPath.indexOf("hd") !== -1)
					{
						// HD versions of patch assets (mostly the HD masks for the status menu).
@if(SCALE_USING_FLOATING_POINT)
						this.originalImageWidth = this.originalImageWidth / (this.window.isHd? upscaledFactor : 1);
						this.originalImageHeight = this.originalImageHeight / (this.window.isHd? upscaledFactor : 1);
@endif
@if(!SCALE_USING_FLOATING_POINT)
						this.originalImageWidth = this.originalImageWidth \ (this.window.isHd? upscaledFactor : 1);
						this.originalImageHeight = this.originalImageHeight \ (this.window.isHd? upscaledFactor : 1);
@endif
					}
				} else {
					// Load images based on file extension priority (according to global.image_extensions).
					chosenExt = currentExtension;
				}
				break;
			}
		}

		var taginfo = (global.Layer_patch_hd_layer_original.loadImages incontextof this)(this.imageStorage+chosenExt, key);

@if(GAME_FATE||GAME_FHAT)
		// Mainly used for 藤02a腕b(中) and 藤02g腕b(中) since the HD version's width is larger than expected because of redundant transparent padding, but there might be other cases so the condition is generic.
		if (this.isHd && this.isCharacterLayer && !this.isbg) {
			var w = this.originalImageWidth*this.widthScale;
			var h = this.originalImageHeight*this.heightScale;
			var leftDiff = (super.imageWidth - w) \ 2;
			if (leftDiff > 0) {
				var tmp = new global.Layer(this.window, this);
				(global.Layer_patch_hd_layer_original.loadImages incontextof tmp)(this.imageStorage+chosenExt, key);

				(global.Layer_patch_hd_layer_original.fillRect incontextof this)(0, 0, w, h, 0x00000000);
				(global.Layer_patch_hd_layer_original.operateRect incontextof this)(0, 0, tmp, leftDiff, 0, w, h);
				(global.Layer_patch_hd_layer_original.setImageSize incontextof this)(w, h);

				invalidate tmp;
			}
		}
@endif

		if (this.isThumbnail)
		{
			this.originalImageWidth = 120;
			this.originalImageHeight = 90;
		}
		else if (this.isTicketThumbnail)
		{
			this.originalImageWidth = 128;
			this.originalImageHeight = 96;
		}
		else if (!this.isHd || storageExt != "")
		{
			this.originalImageWidth = super.imageWidth;
			this.originalImageHeight = super.imageHeight;
		}
@if(GAME_FATE||GAME_FHAT)
		if (global.ps2BgImages.find(this.imageStorage) !== -1) {
			this.isbg = true;
		}
@endif

		this.updateBg(this.originalImageWidth, this.originalImageHeight, true);

@if(GAME_FATE||GAME_FHAT)
		if (this.isExButtonLayer)
		{
			this.numberOfImages = septByMode[mode];
		}
		else if (this.imageStorage == "pagebreak_a" && storageExt == ".png")
		{
			this.numberOfImages = imageNameToNumberOfImages[this.imageStorage + storageExt];
		}
		else
@endif
		{
@if(GAME_FATE||GAME_FHAT)
			if (imageNameToNumberOfImages[this.imageStorage] !== void)
			{
				this.numberOfImages = imageNameToNumberOfImages[this.imageStorage];
			}
			else
@endif
			{
				this.numberOfImages = 1;
			}
		}

		this.upscale();

		if (this.numberOfImages == 1)
		{
			this.originalImageWidth = transformDiscrete(this.originalImageWidth, this.widthScale);
			this.originalImageHeight = transformDiscrete(this.originalImageHeight, this.heightScale);
		}

		this.internalSetImageSize(this.originalImageWidth, this.originalImageHeight);

		return taginfo;
	}

	function loadProvinceImage(image)
	{
		throw new Exception("Function loadProvinceImage not implemented");
	}

	function getMainPixel(x, y)
	{
@if(!SCALE_USING_FLOATING_POINT)
		x = ((x < 0 ? -x : x) & 0x7fffffff) * (x < 0 ? -1 : 1);
		y = ((y < 0 ? -y : y) & 0x7fffffff) * (y < 0 ? -1 : 1);
@endif
		x *= this.widthScale;
		y *= this.heightScale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
		x = global.Math.round(x) | 0;
		y = global.Math.round(y) | 0;
@endif
		return (global.Layer_patch_hd_layer_original.getMainPixel incontextof this)(x, y);
	}

	function setMainPixel(x, y, color)
	{
@if(!SCALE_USING_FLOATING_POINT)
		x = ((x < 0 ? -x : x) & 0x7fffffff) * (x < 0 ? -1 : 1);
		y = ((y < 0 ? -y : y) & 0x7fffffff) * (y < 0 ? -1 : 1);
		color &= 0xffffffff;
@endif
		x *= this.widthScale;
		y *= this.heightScale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
		x = global.Math.round(x) | 0;
		y = global.Math.round(y) | 0;
@endif
		(global.Layer_patch_hd_layer_original.setMainPixel incontextof this)(x, y, color);
	}

	function getMaskPixel(x, y)
	{
@if(!SCALE_USING_FLOATING_POINT)
		x = ((x < 0 ? -x : x) & 0x7fffffff) * (x < 0 ? -1 : 1);
		y = ((y < 0 ? -y : y) & 0x7fffffff) * (y < 0 ? -1 : 1);
@endif
		x *= this.widthScale;
		y *= this.heightScale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
		x = global.Math.round(x) | 0;
		y = global.Math.round(y) | 0;
@endif
		return (global.Layer_patch_hd_layer_original.getMaskPixel incontextof this)(x, y);
	}

	function setMaskPixel(x, y, value)
	{
@if(!SCALE_USING_FLOATING_POINT)
		x = ((x < 0 ? -x : x) & 0x7fffffff) * (x < 0 ? -1 : 1);
		y = ((y < 0 ? -y : y) & 0x7fffffff) * (y < 0 ? -1 : 1);
		value &= 0xffffffff;
@endif
		x *= this.widthScale;
		y *= this.heightScale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
		x = global.Math.round(x) | 0;
		y = global.Math.round(y) | 0;
@endif
		(global.Layer_patch_hd_layer_original.setMaskPixel incontextof this)(x, y, value);
	}

	function getProvincePixel(x, y)
	{
@if(!SCALE_USING_FLOATING_POINT)
		x = ((x < 0 ? -x : x) & 0x7fffffff) * (x < 0 ? -1 : 1);
		y = ((y < 0 ? -y : y) & 0x7fffffff) * (y < 0 ? -1 : 1);
@endif
		x *= this.widthScale;
		y *= this.heightScale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
		x = global.Math.round(x) | 0;
		y = global.Math.round(y) | 0;
@endif
		return (global.Layer_patch_hd_layer_original.getProvincePixel incontextof this)(x, y);
	}

	function setProvincePixel(x, y, value)
	{
@if(!SCALE_USING_FLOATING_POINT)
		x = ((x < 0 ? -x : x) & 0x7fffffff) * (x < 0 ? -1 : 1);
		y = ((y < 0 ? -y : y) & 0x7fffffff) * (y < 0 ? -1 : 1);
		value &= 0xffffffff;
@endif
		x *= this.widthScale;
		y *= this.heightScale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
		x = global.Math.round(x) | 0;
		y = global.Math.round(y) | 0;
@endif
		(global.Layer_patch_hd_layer_original.setProvincePixel incontextof this)(x, y, value);
	}

	function getLayerAt(x, y, exclude_self, get_disabled)
	{
@if(!SCALE_USING_FLOATING_POINT)
		x = ((x < 0 ? -x : x) & 0x7fffffff) * (x < 0 ? -1 : 1);
		y = ((y < 0 ? -y : y) & 0x7fffffff) * (y < 0 ? -1 : 1);
@endif
		x *= this.widthScale;
		y *= this.heightScale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
		x = global.Math.round(x) | 0;
		y = global.Math.round(y) | 0;
@endif
		return (global.Layer_patch_hd_layer_original.getLayerAt incontextof this)(x, y, exclude_self, get_disabled);
	}

	function setSize_patch_hd_layer(width, height, fromloadImages=false)
	{
@if(!SCALE_USING_FLOATING_POINT)
		width = ((width < 0 ? -width : width) & 0x7fffffff) * (width < 0 ? -1 : 1);
		height = ((height < 0 ? -height : height) & 0x7fffffff) * (height < 0 ? -1 : 1);
@endif

		this.updateBg(width, height, fromloadImages);

		this.originalWidth = transformDiscrete(width, this.widthScale);
		this.originalHeight = transformDiscrete(height, this.heightScale);

		width *= this.widthScale;
		height *= this.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		width = global.Math.round(width) | 0;
		height = global.Math.round(height) | 0;
@endif

		(global.Layer_patch_hd_layer_original.setSize incontextof this)(width, height);

		this.updateImageSize();
	}

	function setSize()
	{
		return this.setSize_patch_hd_layer(...);
	}

	function setImageSize_patch_hd_layer(imageWidth, imageHeight)
	{
@if(!SCALE_USING_FLOATING_POINT)
		imageWidth = ((imageWidth < 0 ? -imageWidth : imageWidth) & 0x7fffffff) * (imageWidth < 0 ? -1 : 1);
		imageHeight = ((imageHeight < 0 ? -imageHeight : imageHeight) & 0x7fffffff) * (imageHeight < 0 ? -1 : 1);
@endif

		this.updateBg(imageWidth, imageHeight);

		this.originalImageWidth = transformDiscrete(imageWidth, this.widthScale);
		this.originalImageHeight = transformDiscrete(imageHeight, this.heightScale);
		this.internalSetImageSize(this.originalImageWidth, this.originalImageHeight);

		imageWidth *= this.widthScale;
		imageHeight *= this.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		imageWidth = global.Math.round(imageWidth) | 0;
		imageHeight = global.Math.round(imageHeight) | 0;
@endif

		(global.Layer_patch_hd_layer_original.setImageSize incontextof this)(imageWidth, imageHeight);
	}

	function setImageSize()
	{
		return this.setImageSize_patch_hd_layer(...);
	}

	function updateImageSize()
	{
		if (this.hasImage) {
			if (this.originalImageWidth < this.originalWidth) {
				this.originalImageWidth = this.originalWidth;
			}
			if (this.originalImageWidth + this.originalImageLeft < this.originalWidth) {
				this.originalImageLeft = this.originalWidth - this.originalImageWidth;
			}
			if (this.originalImageHeight < this.originalHeight) {
				this.originalImageHeight = this.originalHeight;
			}
			if (this.originalImageHeight + this.originalImageTop < this.originalHeight) {
				this.originalImageTop = this.originalHeight - this.originalImageHeight;
			}
			this.resetClip();
		}
	}

	function internalSetImageSize(width, height)
	{
		if (width < this.originalWidth)
		{
			this.originalImageLeft = 0;
			this.originalWidth = width;
		}
		if (width + this.originalImageLeft < this.originalWidth)
		{
			this.originalImageLeft = this.originalWidth - width;
		}

		if (height < this.originalHeight)
		{
			this.originalImageTop = 0;
			this.originalHeight = height;
		}
		if (height + this.originalImageTop < this.originalHeight)
		{
			this.originalImageTop = this.originalHeight - height;
		}

		if (this.hasImage)
		{
			this.resetClip();
		}
	}

	function setSizeToImageSize()
	{
		this.setSize_patch_hd_layer(this.originalImageWidth, this.originalImageHeight, true);
	}

	function upscale()
	{
		var scaleWidth = this.originalImageWidth * this.widthScale;
		var scaleHeight = this.originalImageHeight * this.heightScale;
		if (super.imageWidth == scaleWidth && super.imageHeight == scaleHeight) return;

@if(SCALE_USING_FLOATING_POINT)
		var scale = scaleWidth / super.imageWidth;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		var scale = scaleWidth \ super.imageWidth;
@endif
		var singleWidth = super.imageWidth \ this.numberOfImages;
		var roundedUpscaledSingleWidth = (singleWidth * scale) | 0;
		scaleWidth = roundedUpscaledSingleWidth * this.numberOfImages;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		scaleWidth = global.Math.round(scaleWidth) | 0;
		scaleHeight = global.Math.round(scaleHeight) | 0;
		singleWidth = global.Math.round(singleWidth) | 0;
		roundedUpscaledSingleWidth = global.Math.round(roundedUpscaledSingleWidth) | 0;
@endif

		var tmp = new global.Layer(this.window, this);
		(global.Layer_patch_hd_layer_original.setImageSize incontextof tmp)(scaleWidth, scaleHeight);

		for (var i = 0, internal_forloop_count = this.numberOfImages; i < internal_forloop_count; i += 1) {
			(global.Layer_patch_hd_layer_original.stretchCopy incontextof tmp)(roundedUpscaledSingleWidth*i, 0, roundedUpscaledSingleWidth, scaleHeight, this, singleWidth*i, 0, singleWidth, super.imageHeight, this.scaleAlgorithm);
		}

		(global.Layer_patch_hd_layer_original.setImageSize incontextof this)(scaleWidth, scaleHeight);

		(global.Layer_patch_hd_layer_original.fillRect incontextof this)(0, 0, super.imageWidth, super.imageHeight, 0x00000000);

		if (face == dfProvince) {
			(global.Layer_patch_hd_layer_original.operateRect incontextof this)(0, 0, tmp, 0, 0, scaleWidth, scaleHeight, face);
		} else {
			(global.Layer_patch_hd_layer_original.operateRect incontextof this)(0, 0, tmp, 0, 0, scaleWidth, scaleHeight);
		}

		invalidate tmp;
	}

	function setPos_patch_hd_layer(left, top, width, height)
	{
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
@endif
		this._originalLeft = left;
		this.originalTop = top;

		if (width !== void)
		{
@if(!SCALE_USING_FLOATING_POINT)
			width = ((width < 0 ? -width : width) & 0x7fffffff) * (width < 0 ? -1 : 1);
@endif
			this.originalWidth = width;
			width *= this.widthScale;
		}
		if (height !== void)
		{
@if(!SCALE_USING_FLOATING_POINT)
			height = ((height < 0 ? -height : height) & 0x7fffffff) * (height < 0 ? -1 : 1);
@endif
			this.originalHeight = height;
			height *= this.heightScale;
		}

		left = this.transformLeft(left);
		top = this.transformTop(top);

@if(SCALE_ROUND_TOWARDS_NEAREST)
		left = global.Math.round(left) | 0;
		top = global.Math.round(top) | 0;
		width = global.Math.round(width) | 0;
		height = global.Math.round(height) | 0;
@endif

		(global.Layer_patch_hd_layer_original.setPos incontextof this)(left, top, width, height);

		if (width !== void || height !== void)
		{
			this.updateImageSize();
		}
	}

	function setPos()
	{
		return this.setPos_patch_hd_layer(...);
	}

	function setImagePos_patch_hd_layer(left, top)
	{
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
@endif
		this.originalImageLeft = left;
		this.originalImageTop = top;

		left *= this.widthScale;
		top *= this.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		left = global.Math.round(left) | 0;
		top = global.Math.round(top) | 0;
@endif

		(global.Layer_patch_hd_layer_original.setImagePos incontextof this)(left, top);
	}

	function setImagePos()
	{
		return this.setImagePos_patch_hd_layer(...);
	}

	function setCursorPos(cursorX, cursorY)
	{
@if(!SCALE_USING_FLOATING_POINT)
		cursorX = ((cursorX < 0 ? -cursorX : cursorX) & 0x7fffffff) * (cursorX < 0 ? -1 : 1);
		cursorY = ((cursorY < 0 ? -cursorY : cursorY) & 0x7fffffff) * (cursorY < 0 ? -1 : 1);
@endif
		var originalCursorX = transformDiscrete(cursorX, this.cursorXScale);
		var originalCursorY = transformDiscrete(cursorY, this.cursorYScale);

		cursorX = this.transformCursorX(originalCursorX);
		cursorY = this.transformCursorY(originalCursorY);

@if(SCALE_ROUND_TOWARDS_NEAREST)
		cursorX = global.Math.round(cursorX) | 0;
		cursorY = global.Math.round(cursorY) | 0;
@endif

		(global.Layer_patch_hd_layer_original.setCursorPos incontextof this)(cursorX, cursorY);
	}

	function updateBgFromSource(src, swidth, sheight)
	{
		// When copying a background image, set this this.layer to be background as well
		if (src.isbg && src.imageWidthOriginal == swidth && src.imageHeightOriginal == sheight) {
			this.isbg = src.isbg;
			this.fullScreenBg = src.fullScreenBg;
			this.fixedbg = src.fixedbg;
			this.movingbg = src.movingbg;

			this.isMask = true;
			(global.Layer.setSize incontextof this)(src.imageWidthOriginal, src.imageHeightOriginal);
			this.isMask = false;
		}
	}

	function transformSLeft(src, sleft, swidth)
	{
		if (src.numberOfImages > 1) {
@if(SCALE_USING_FLOATING_POINT)
			var imageIndex = sleft / swidth;
@endif
@if(!SCALE_USING_FLOATING_POINT)
			var imageIndex = sleft \ swidth;
@endif
			return imageIndex * ((swidth * src.widthScale) | 0);
		}
		return sleft*src.widthScale;
	}

	function setClip_patch_hd_layer(args*)
	{
		if (args.count === 0)
		{
			(global.Layer_patch_hd_layer_original.setClip incontextof this)(0, 0, super.imageWidth, super.imageHeight);
			this.resetClip();
			return;
		}
		var clipLeft = args.count >= 1 ? args[0] : 0;
		var clipTop = args.count >= 2 ? args[1] : 0;
		var clipWidth = args.count >= 3 ? args[2] : 0;
		var clipHeight = args.count >= 4 ? args[3] : 0;
@if(!SCALE_USING_FLOATING_POINT)
		clipLeft = ((clipLeft < 0 ? -clipLeft : clipLeft) & 0x7fffffff) * (clipLeft < 0 ? -1 : 1);
		clipTop = ((clipTop < 0 ? -clipTop : clipTop) & 0x7fffffff) * (clipTop < 0 ? -1 : 1);
		clipWidth = ((clipWidth < 0 ? -clipWidth : clipWidth) & 0x7fffffff) * (clipWidth < 0 ? -1 : 1);
		clipHeight = ((clipHeight < 0 ? -clipHeight : clipHeight) & 0x7fffffff) * (clipHeight < 0 ? -1 : 1);
@endif
		var clipRight = this.originalImageWidth + clipLeft;
		var clipBottom = this.originalImageHeight + clipTop;
		clipLeft = clipLeft < 0 ? 0 : clipLeft;
		clipTop = clipTop < 0 ? 0 : clipTop;
		clipRight = this.originalImageWidth < clipRight ? this.originalImageWidth : clipRight;
		clipBottom = this.originalImageHeight < clipBottom ? this.originalImageHeight : clipBottom;
		if (clipRight < clipLeft)
		{
			clipRight = clipLeft;
		}
		if (clipBottom < clipTop)
		{
			clipBottom = clipTop;
		}
		this.originalClipLeft = transformDiscrete(clipLeft, this.widthScale);
		this.originalClipTop = transformDiscrete(clipTop, this.heightScale);
		this.originalClipWidth = transformDiscrete(clipWidth, this.widthScale);
		this.originalClipHeight = transformDiscrete(clipHeight, this.heightScale);

		clipLeft *= this.widthScale;
		clipTop *= this.heightScale;
		clipWidth *= this.widthScale;
		clipHeight *= this.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		clipLeft = global.Math.round(clipLeft) | 0;
		clipTop = global.Math.round(clipTop) | 0;
		clipWidth = global.Math.round(clipWidth) | 0;
		clipHeight = global.Math.round(clipHeight) | 0;
@endif

		(global.Layer_patch_hd_layer_original.setClip incontextof this)(clipLeft, clipTop, clipWidth, clipHeight);
	}

	function setClip()
	{
		return this.setClip_patch_hd_layer(...);
	}

	function setAttentionPos_patch_hd_layer(left, top)
	{
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
@endif
		this.originalAttentionLeft = transformDiscrete(left, this.widthScale);
		this.originalAttentionTop = transformDiscrete(top, this.heightScale);

		left *= this.widthScale;
		top *= this.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		left = global.Math.round(left) | 0;
		top = global.Math.round(top) | 0;
@endif

		(global.Layer_patch_hd_layer_original.setAttentionPos incontextof this)(left, top);
	}

	function setAttentionPos()
	{
		return this.setAttentionPos_patch_hd_layer(...);
	}

	function assignImages(src)
	{
		(global.Layer_patch_hd_layer_original.assignImages incontextof this)(src);
		this.originalImageWidth = src.originalImageWidth;
		this.originalImageHeight = src.originalImageHeight;
		this.imageStorage = src.imageStorage;
		this.isbg = src.isbg;
		this.internalSetImageSize(this.originalImageWidth, this.originalImageHeight);
	}

	function beginTransition(name, withchildren=true, transsrc, options=%[])
	{
@if(0)
		this.update_bounds_hd_layer();
		if (typeof(transsrc) === "Object" && transsrc !== null && isvalid(transsrc) && transsrc instanceof "Layer")
		{
			transsrc.update_bounds_hd_layer();
		}
@endif
		var srcwidth = void;
		var srcheight = void;
		var destwidth = void;
		var destheight = void;
		if (withchildren)
		{
			destwidth = this.originalWidth;
			destheight = this.originalHeight;
		}
		else
		{
			destwidth = this.originalImageWidth;
			destheight = this.originalImageHeight;
		}
		destwidth = ((destwidth < 0 ? -destwidth : destwidth) & 0x7fffffff) * (destwidth < 0 ? -1 : 1);
		destheight = ((destheight < 0 ? -destheight : destheight) & 0x7fffffff) * (destheight < 0 ? -1 : 1);
		if (typeof(transsrc) === "Object" && transsrc !== null && isvalid(transsrc) && transsrc instanceof "Layer")
		{
			if (withchildren)
			{
				srcwidth = transsrc.originalWidth;
				srcheight = transsrc.originalHeight;
			}
			else
			{
				srcwidth = transsrc.originalImageWidth;
				srcheight = transsrc.originalImageHeight;
			}
			srcwidth = ((srcwidth < 0 ? -srcwidth : srcwidth) & 0x7fffffff) * (srcwidth < 0 ? -1 : 1);
			srcheight = ((srcheight < 0 ? -srcheight : srcheight) & 0x7fffffff) * (srcheight < 0 ? -1 : 1);
		}
		if ((name === "crossfade" || name === "scroll" || name === "universal") && (srcwidth !== destwidth || srcheight !== destheight))
		{
			Debug.message("Ignored transition start due to size mismatch");
			var trace_string = Scripts.getTraceString();
			if (trace_string !== "")
			{
				Debug.message("Trace: " + trace_string);
			}
			if (typeof(this.onTransitionCompleted) === "Object")
			{
				this.onTransitionCompleted(this, transsrc);
			}
			return;
		}
		try
		{
			return (global.Layer_patch_hd_layer_original.beginTransition incontextof this)(...);
		}
		catch (e)
		{
			var msg = "";
			if (typeof(e) === "Object" && isvalid(e) && typeof(e.message) === "String")
			{
				msg = e.message;
			}
			Debug.message("Couldn't start transition: " + e.message);
			var trace_string = Scripts.getTraceString();
			if (trace_string !== "")
			{
				Debug.message("Trace: " + trace_string);
			}
			try
			{
				if (typeof(this.onTransitionCompleted) === "Object")
				{
					this.onTransitionCompleted(this, transsrc);
				}
			}
			catch (ee)
			{
				var msg = "";
				if (typeof(e) === "Object" && isvalid(e) && typeof(e.message) === "String")
				{
					msg = e.message;
				}
				Debug.message("Couldn't call onTransitionCompleted: " + e.message);
				var trace_string = Scripts.getTraceString();
				if (trace_string !== "")
				{
					Debug.message("Trace: " + trace_string);
				}
			}
		}
	}

@if(0)
	property mainImageBuffer
	{
		getter
		{
			if (!this.absoluteMode)
			{
				dm("trace: " + Scripts.getTraceString());
				throw new Exception("Attempted to get this.mainImageBuffer while not in this.absoluteMode");
			}
			return super.mainImageBuffer;
		}
	}

	property mainImageBufferForWrite
	{
		getter
		{
			if (!this.absoluteMode)
			{
				dm("trace: " + Scripts.getTraceString());
				throw new Exception("Attempted to get this.mainImageBufferForWrite while not in this.absoluteMode");
			}
			return super.mainImageBufferForWrite;
		}
	}

	property mainImageBufferPitch
	{
		getter
		{
			if (!this.absoluteMode)
			{
				dm("trace: " + Scripts.getTraceString());
				throw new Exception("Attempted to get this.mainImageBufferPitch while not in this.absoluteMode");
			}
			return super.mainImageBufferPitch;
		}
	}

	property provinceImageBuffer
	{
		getter
		{
			if (!this.absoluteMode)
			{
				dm("trace: " + Scripts.getTraceString());
				throw new Exception("Attempted to get this.provinceImageBuffer while not in this.absoluteMode");
			}
			return super.provinceImageBuffer;
		}
	}

	property provinceImageBufferForWrite
	{
		getter
		{
			if (!this.absoluteMode)
			{
				dm("trace: " + Scripts.getTraceString());
				throw new Exception("Attempted to get this.provinceImageBufferForWrite while not in this.absoluteMode");
			}
			return super.provinceImageBufferForWrite;
		}
	}

	property provinceImageBufferPitch
	{
		getter
		{
			if (!this.absoluteMode)
			{
				dm("trace: " + Scripts.getTraceString());
				throw new Exception("Attempted to get this.provinceImageBufferPitch while not in this.absoluteMode");
			}
			return super.provinceImageBufferPitch;
		}
	}
@endif

	function update(args*)
	{
		if (args.count < 1)
		{
			(global.Layer_patch_hd_layer_original.update incontextof this)();
			return;
		}
		if (args.count < 4)
		{
			throw new Exception("expected 4 args");
		}
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale == 2)
		{
			return (global.Layer_patch_hd_layer_original.update incontextof this)(...);
		}
		var left = args[0];
		var top = args[1];
		var width = args[2];
		var height = args[3];
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		width = ((width < 0 ? -width : width) & 0x7fffffff) * (width < 0 ? -1 : 1);
		height = ((height < 0 ? -height : height) & 0x7fffffff) * (height < 0 ? -1 : 1);
@endif

		left *= this.widthScale;
		top *= this.heightScale;
		width *= this.widthScale;
		height *= this.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		left = global.Math.round(left) | 0;
		top = global.Math.round(top) | 0;
		width = global.Math.round(width) | 0;
		height = global.Math.round(height) | 0;
@endif

		(global.Layer_patch_hd_layer_original.update incontextof this)(left, top, width, height);
	}

	/*
	function redraw(left, top)
	{
		super.redraw(left*this.widthScale, top*this.heightScale);
	}*/

	// Image functions.
	function operateRect(left, top, src, sleft, stop, swidth, sheight, mode, opacity)
	{
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale + src.widthScale + src.heightScale == 4)
		{
			return (global.Layer_patch_hd_layer_original.operateRect incontextof this)(...);
		}
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		sleft = ((sleft < 0 ? -sleft : sleft) & 0x7fffffff) * (sleft < 0 ? -1 : 1);
		stop = ((stop < 0 ? -stop : stop) & 0x7fffffff) * (stop < 0 ? -1 : 1);
		swidth = ((swidth < 0 ? -swidth : swidth) & 0x7fffffff) * (swidth < 0 ? -1 : 1);
		sheight = ((sheight < 0 ? -sheight : sheight) & 0x7fffffff) * (sheight < 0 ? -1 : 1);
		if (mode !== void)
		{
			mode = ((mode < 0 ? -mode : mode) & 0x7fffffff) * (mode < 0 ? -1 : 1);
		}
		if (opacity !== void)
		{
			opacity = ((opacity < 0 ? -opacity : opacity) & 0x7fffffff) * (opacity < 0 ? -1 : 1);
		}
@endif
		left = src.transformLeft(left, this);
		top = src.transformTop(top, this);
		sleft *= src.widthScale;
		stop *= src.heightScale;
		swidth *= src.widthScale;
		sheight *= src.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		left = global.Math.round(left) | 0;
		top = global.Math.round(top) | 0;
		sleft = global.Math.round(sleft) | 0;
		stop = global.Math.round(stop) | 0;
		swidth = global.Math.round(swidth) | 0;
		sheight = global.Math.round(sheight) | 0;
@endif

		var ie;
		try
		{
			this.absoluteMode += 1;
			src.absoluteMode += 1;
			(global.Layer_patch_hd_layer_original.operateRect incontextof this)(left, top, src, sleft, stop, swidth, sheight, mode, opacity);
		}
		catch (e)
		{
			ie = e;
		}
		this.absoluteMode -= 1;
		src.absoluteMode -= 1;
		if (ie !== void)
		{
			throw ie;
		}
	}
	function copyRect(left, top, src, sleft, stop, swidth, sheight)
	{
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale + src.widthScale + src.heightScale == 4)
		{
			return (global.Layer_patch_hd_layer_original.copyRect incontextof this)(...);
		}
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		sleft = ((sleft < 0 ? -sleft : sleft) & 0x7fffffff) * (sleft < 0 ? -1 : 1);
		stop = ((stop < 0 ? -stop : stop) & 0x7fffffff) * (stop < 0 ? -1 : 1);
		swidth = ((swidth < 0 ? -swidth : swidth) & 0x7fffffff) * (swidth < 0 ? -1 : 1);
		sheight = ((sheight < 0 ? -sheight : sheight) & 0x7fffffff) * (sheight < 0 ? -1 : 1);
@endif
		this.updateBgFromSource(src, swidth, sheight);
		left = src.transformLeft(left, this);
		top = src.transformTop(top, this);
		sleft *= src.widthScale;
		stop *= src.heightScale;
		swidth *= src.widthScale;
		sheight *= src.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		left = global.Math.round(left) | 0;
		top = global.Math.round(top) | 0;
		sleft = global.Math.round(sleft) | 0;
		stop = global.Math.round(stop) | 0;
		swidth = global.Math.round(swidth) | 0;
		sheight = global.Math.round(sheight) | 0;
@endif

		var ie;
		try
		{
			this.absoluteMode += 1;
			src.absoluteMode += 1;
			(global.Layer_patch_hd_layer_original.copyRect incontextof this)(left, top, src, sleft, stop, swidth, sheight);
		}
		catch (e)
		{
			ie = e;
		}
		this.absoluteMode -= 1;
		src.absoluteMode -= 1;
		if (ie !== void)
		{
			throw ie;
		}
	}
	function copy9Patch(src)
	{
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale + src.widthScale + src.heightScale == 4)
		{
			return (global.Layer_patch_hd_layer_original.copy9Patch incontextof this)(...);
		}
		var ret;
		var ie;
		try
		{
			this.absoluteMode += 1;
			src.absoluteMode += 1;
			ret = (global.Layer_patch_hd_layer_original.copy9Patch incontextof this)(src);
		}
		catch (e)
		{
			ie = e;
		}
		this.absoluteMode -= 1;
		src.absoluteMode -= 1;
		if (ie !== void)
		{
			throw ie;
		}
		if (ret !== void)
		{
			ret.left *= this.widthScale;
			ret.top *= this.heightScale;
			ret.right *= this.widthScale;
			ret.bottom *= this.heightScale;
		}
		return ret;
	}
	function flipLR()
	{
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale == 2)
		{
			return (global.Layer_patch_hd_layer_original.flipLR incontextof this)(...);
		}
		var ie;
		try
		{
			this.absoluteMode += 1;
			(global.Layer_patch_hd_layer_original.flipLR incontextof this)(...);
		}
		catch (e)
		{
			ie = e;
		}
		this.absoluteMode -= 1;
		if (ie !== void)
		{
			throw ie;
		}
	}
	function flipUD()
	{
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale == 2)
		{
			return (global.Layer_patch_hd_layer_original.flipUD incontextof this)(...);
		}
		var ie;
		try
		{
			this.absoluteMode += 1;
			(global.Layer_patch_hd_layer_original.flipUD incontextof this)(...);
		}
		catch (e)
		{
			ie = e;
		}
		this.absoluteMode -= 1;
		if (ie !== void)
		{
			throw ie;
		}
	}
	function adjustGamma()
	{
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale == 2)
		{
			return (global.Layer_patch_hd_layer_original.adjustGamma incontextof this)(...);
		}
		var ie;
		try
		{
			this.absoluteMode += 1;
			(global.Layer_patch_hd_layer_original.adjustGamma incontextof this)(...);
		}
		catch (e)
		{
			ie = e;
		}
		this.absoluteMode -= 1;
		if (ie !== void)
		{
			throw ie;
		}
	}
	function doGrayScale()
	{
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale == 2)
		{
			return (global.Layer_patch_hd_layer_original.doGrayScale incontextof this)(...);
		}
		var ie;
		try
		{
			this.absoluteMode += 1;
			(global.Layer_patch_hd_layer_original.doGrayScale incontextof this)(...);
		}
		catch (e)
		{
			ie = e;
		}
		this.absoluteMode -= 1;
		if (ie !== void)
		{
			throw ie;
		}
	}
	function operateStretch(left, top, width, height, src, sleft, stop, swidth, sheight, mode, opacity, type, option)
	{
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale + src.widthScale + src.heightScale == 4)
		{
			return (global.Layer_patch_hd_layer_original.operateStretch incontextof this)(...);
		}
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		width = ((width < 0 ? -width : width) & 0x7fffffff) * (width < 0 ? -1 : 1);
		height = ((height < 0 ? -height : height) & 0x7fffffff) * (height < 0 ? -1 : 1);
		var sleft_orig = sleft;
		var stop_orig = stop;
		var swidth_orig = swidth;
		var sheight_orig = sheight;
		sleft = ((sleft < 0 ? -sleft : sleft) & 0x7fffffff) * (sleft < 0 ? -1 : 1);
		stop = ((stop < 0 ? -stop : stop) & 0x7fffffff) * (stop < 0 ? -1 : 1);
		swidth = ((swidth < 0 ? -swidth : swidth) & 0x7fffffff) * (swidth < 0 ? -1 : 1);
		sheight = ((sheight < 0 ? -sheight : sheight) & 0x7fffffff) * (sheight < 0 ? -1 : 1);
		if (mode !== void)
		{
			mode = ((mode < 0 ? -mode : mode) & 0x7fffffff) * (mode < 0 ? -1 : 1);
		}
		if (opacity !== void)
		{
			opacity = ((opacity < 0 ? -opacity : opacity) & 0x7fffffff) * (opacity < 0 ? -1 : 1);
		}
		if (type !== void)
		{
			type = ((type < 0 ? -type : type) & 0x7fffffff) * (type < 0 ? -1 : 1);
		}
		if (option !== void)
		{
			option *= 1.0;
		}
@endif
		left = src.transformLeft(left, this);
		top = src.transformTop(top, this);
		width *= this.widthScale;
		height *= this.heightScale;
		sleft *= src.widthScale;
		stop *= src.heightScale;
		swidth *= src.widthScale;
		sheight *= src.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		left = global.Math.round(left) | 0;
		top = global.Math.round(top) | 0;
		width = global.Math.round(width) | 0;
		height = global.Math.round(height) | 0;
		sleft = global.Math.round(sleft) | 0;
		stop = global.Math.round(stop) | 0;
		swidth = global.Math.round(swidth) | 0;
		sheight = global.Math.round(sheight) | 0;
@endif

@if(SCALE_USING_FLOATING_POINT)
		// XXX: workaround for transparent YesNoLayer
		if (sleft > 0 && sleft < 1)
		{
			sleft = 1;
		}
		if (stop > 0 && stop < 1)
		{
			stop = 1;
		}
		if (swidth > 0 && swidth < 1)
		{
			swidth = 1;
		}
		if (sheight > 0 && sheight < 1)
		{
			sheight = 1;
		}
@endif
		var ie;
		try
		{
			this.absoluteMode += 1;
			src.absoluteMode += 1;
			(global.Layer_patch_hd_layer_original.operateStretch incontextof this)(left, top, width, height, src, sleft, stop, swidth, sheight, mode, opacity, type, option);
		}
		catch (e)
		{
			ie = e;
		}
		this.absoluteMode -= 1;
		src.absoluteMode -= 1;
		if (ie !== void)
		{
			throw ie;
		}
	}
	function stretchCopy(left, top, width, height, src, sleft, stop, swidth, sheight, type, option)
	{
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale + src.widthScale + src.heightScale == 4)
		{
			return (global.Layer_patch_hd_layer_original.stretchCopy incontextof this)(...);
		}
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		width = ((width < 0 ? -width : width) & 0x7fffffff) * (width < 0 ? -1 : 1);
		height = ((height < 0 ? -height : height) & 0x7fffffff) * (height < 0 ? -1 : 1);
		sleft = ((sleft < 0 ? -sleft : sleft) & 0x7fffffff) * (sleft < 0 ? -1 : 1);
		stop = ((stop < 0 ? -stop : stop) & 0x7fffffff) * (stop < 0 ? -1 : 1);
		swidth = ((swidth < 0 ? -swidth : swidth) & 0x7fffffff) * (swidth < 0 ? -1 : 1);
		sheight = ((sheight < 0 ? -sheight : sheight) & 0x7fffffff) * (sheight < 0 ? -1 : 1);
		if (type !== void)
		{
			type = ((type < 0 ? -type : type) & 0x7fffffff) * (type < 0 ? -1 : 1);
		}
		if (option !== void)
		{
			option *= 1.0;
		}
@endif
		left = src.transformLeft(left, this);
		top = src.transformTop(top, this);
		width *= this.widthScale;
		height *= this.heightScale;
		sleft = this.transformSLeft(src, sleft, swidth);
		stop *= src.heightScale;
		swidth *= src.widthScale;
		sheight *= src.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		left = global.Math.round(left) | 0;
		top = global.Math.round(top) | 0;
		width = global.Math.round(width) | 0;
		height = global.Math.round(height) | 0;
		sleft = global.Math.round(sleft) | 0;
		stop = global.Math.round(stop) | 0;
		swidth = global.Math.round(swidth) | 0;
		sheight = global.Math.round(sheight) | 0;
@endif

		var ie;
		try
		{
			this.absoluteMode += 1;
			src.absoluteMode += 1;
			(global.Layer_patch_hd_layer_original.stretchCopy incontextof this)(left, top, width, height, src, sleft, stop, swidth, sheight, type, option);
		}
		catch (e)
		{
			ie = e;
		}
		this.absoluteMode -= 1;
		src.absoluteMode -= 1;
		if (ie !== void)
		{
			throw ie;
		}
	}
	function piledCopy(left, top, src, sleft, stop, swidth, sheight)
	{
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale + src.widthScale + src.heightScale == 4)
		{
			return (global.Layer_patch_hd_layer_original.piledCopy incontextof this)(...);
		}
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		sleft = ((sleft < 0 ? -sleft : sleft) & 0x7fffffff) * (sleft < 0 ? -1 : 1);
		stop = ((stop < 0 ? -stop : stop) & 0x7fffffff) * (stop < 0 ? -1 : 1);
		swidth = ((swidth < 0 ? -swidth : swidth) & 0x7fffffff) * (swidth < 0 ? -1 : 1);
		sheight = ((sheight < 0 ? -sheight : sheight) & 0x7fffffff) * (sheight < 0 ? -1 : 1);
@endif
		this.updateBgFromSource(src, swidth, sheight);
		left = src.transformLeft(left, this);
		top = src.transformTop(top, this);
		sleft *= src.widthScale;
		stop *= src.heightScale;
		swidth *= src.widthScale;
		sheight *= src.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		left = global.Math.round(left) | 0;
		top = global.Math.round(top) | 0;
		sleft = global.Math.round(sleft) | 0;
		stop = global.Math.round(stop) | 0;
		swidth = global.Math.round(swidth) | 0;
		sheight = global.Math.round(sheight) | 0;
@endif

		var ie;
		try
		{
			this.absoluteMode += 1;
			src.absoluteMode += 1;
			(global.Layer_patch_hd_layer_original.piledCopy incontextof this)(left, top, src, sleft, stop, swidth, sheight);
		}
		catch (e)
		{
			ie = e;
		}
		this.absoluteMode -= 1;
		src.absoluteMode -= 1;
		if (ie !== void)
		{
			throw ie;
		}
	}
	function affineCopy(src, sx, sy, sw, sh, affine, a, b, c, d, tx, ty, type, clear)
	{
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale + src.widthScale + src.heightScale == 4)
		{
			return (global.Layer_patch_hd_layer_original.affineCopy incontextof this)(...);
		}
@if(!SCALE_USING_FLOATING_POINT)
		sx = ((sx < 0 ? -sx : sx) & 0x7fffffff) * (sx < 0 ? -1 : 1);
		sy = ((sy < 0 ? -sy : sy) & 0x7fffffff) * (sy < 0 ? -1 : 1);
		sw = ((sw < 0 ? -sw : sw) & 0x7fffffff) * (sw < 0 ? -1 : 1);
		sh = ((sh < 0 ? -sh : sh) & 0x7fffffff) * (sh < 0 ? -1 : 1);
		affine = !!affine;
		a *= 1.0;
		b *= 1.0;
		c *= 1.0;
		d *= 1.0;
		tx *= 1.0;
		ty *= 1.0;
		if (type !== void)
		{
			type = ((type < 0 ? -type : type) & 0x7fffffff) * (type < 0 ? -1 : 1);
		}
		if (clear !== void)
		{
			clear = ((clear < 0 ? -clear : clear) & 0x7fffffff) * (clear < 0 ? -1 : 1);
		}
@endif
		sx *= src.widthScale;
		sy *= src.heightScale;
		sw *= src.widthScale;
		sh *= src.heightScale;
		if (!affine)
		{
			a *= this.widthScale;
			b *= this.heightScale;
			c *= this.widthScale;
			d *= this.heightScale;
		}
		tx *= this.widthScale;
		ty *= this.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		sx = global.Math.round(sx) | 0;
		sy = global.Math.round(sy) | 0;
		sw = global.Math.round(sw) | 0;
		sh = global.Math.round(sh) | 0;
		a = global.Math.round(a) | 0;
		b = global.Math.round(b) | 0;
		c = global.Math.round(c) | 0;
		d = global.Math.round(d) | 0;
		tx = global.Math.round(tx) | 0;
		ty = global.Math.round(ty) | 0;
@endif

		var ie;
		try
		{
			this.absoluteMode += 1;
			src.absoluteMode += 1;
			(global.Layer_patch_hd_layer_original.affineCopy incontextof this)(src, sx, sy, sw, sh, affine, a, b, c, d, tx, ty, type, clear);
		}
		catch (e)
		{
			ie = e;
		}
		this.absoluteMode -= 1;
		src.absoluteMode -= 1;
		if (ie !== void)
		{
			throw ie;
		}
	}
	function operateAffine(src, sx, sy, sw, sh, affine, a, b, c, d, tx, ty, mode, opa, type)
	{
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale + src.widthScale + src.heightScale == 4)
		{
			return (global.Layer_patch_hd_layer_original.operateAffine incontextof this)(...);
		}
@if(!SCALE_USING_FLOATING_POINT)
		sx = ((sx < 0 ? -sx : sx) & 0x7fffffff) * (sx < 0 ? -1 : 1);
		sy = ((sy < 0 ? -sy : sy) & 0x7fffffff) * (sy < 0 ? -1 : 1);
		sw = ((sw < 0 ? -sw : sw) & 0x7fffffff) * (sw < 0 ? -1 : 1);
		sh = ((sh < 0 ? -sh : sh) & 0x7fffffff) * (sh < 0 ? -1 : 1);
		affine = !!affine;
		a *= 1.0;
		b *= 1.0;
		c *= 1.0;
		d *= 1.0;
		tx *= 1.0;
		ty *= 1.0;
		if (mode !== void)
		{
			mode = ((mode < 0 ? -mode : mode) & 0x7fffffff) * (mode < 0 ? -1 : 1);
		}
		if (opa !== void)
		{
			opa = ((opa < 0 ? -opa : opa) & 0x7fffffff) * (opa < 0 ? -1 : 1);
		}
		if (type !== void)
		{
			type = ((type < 0 ? -type : type) & 0x7fffffff) * (type < 0 ? -1 : 1);
		}
@endif
		sx *= src.widthScale;
		sy *= src.heightScale;
		sw *= src.widthScale;
		sh *= src.heightScale;
		if (!affine)
		{
			a *= this.widthScale;
			b *= this.heightScale;
			c *= this.widthScale;
			d *= this.heightScale;
		}
		tx *= this.widthScale;
		ty *= this.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		sx = global.Math.round(sx) | 0;
		sy = global.Math.round(sy) | 0;
		sw = global.Math.round(sw) | 0;
		sh = global.Math.round(sh) | 0;
		a = global.Math.round(a) | 0;
		b = global.Math.round(b) | 0;
		c = global.Math.round(c) | 0;
		d = global.Math.round(d) | 0;
		tx = global.Math.round(tx) | 0;
		ty = global.Math.round(ty) | 0;
@endif

		var ie;
		try
		{
			this.absoluteMode += 1;
			src.absoluteMode += 1;
			(global.Layer_patch_hd_layer_original.operateAffine incontextof this)(src, sx, sy, sw, sh, affine, a, b, c, d, tx, ty, mode, opa, type);
		}
		catch (e)
		{
			ie = e;
		}
		this.absoluteMode -= 1;
		src.absoluteMode -= 1;
		if (ie !== void)
		{
			throw ie;
		}
	}
	function doBoxBlur(xblur=1, yblur=1)
	{
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale == 2)
		{
			return (global.Layer_patch_hd_layer_original.doBoxBlur incontextof this)(...);
		}
@if(!SCALE_USING_FLOATING_POINT)
		xblur = ((xblur < 0 ? -xblur : xblur) & 0x7fffffff) * (xblur < 0 ? -1 : 1);
		yblur = ((yblur < 0 ? -yblur : yblur) & 0x7fffffff) * (yblur < 0 ? -1 : 1);
@endif
@if(GAME_WOHN)
		// Attempted workaround for overflow
		if ((xblur + 1) * (yblur + 1) >= 16777216)
		{
			return;
		}
@endif
		xblur *= this.widthScale;
		yblur *= this.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		xblur = global.Math.round(xblur) | 0;
		yblur = global.Math.round(yblur) | 0;
@endif

		var ie;
		try
		{
			this.absoluteMode += 1;
			(global.Layer_patch_hd_layer_original.doBoxBlur incontextof this)(xblur, yblur);
		}
		catch (e)
		{
			ie = e;
		}
		this.absoluteMode -= 1;
		if (ie !== void)
		{
			throw ie;
		}
	}
	function fillRect(left, top, width, height, color)
	{
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale == 2)
		{
			return (global.Layer_patch_hd_layer_original.fillRect incontextof this)(...);
		}
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		width = ((width < 0 ? -width : width) & 0x7fffffff) * (width < 0 ? -1 : 1);
		height = ((height < 0 ? -height : height) & 0x7fffffff) * (height < 0 ? -1 : 1);
		color &= 0xffffffff;
@endif
		left *= this.widthScale;
		top *= this.heightScale;
		width *= this.widthScale;
		height *= this.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		left = global.Math.round(left) | 0;
		top = global.Math.round(top) | 0;
		width = global.Math.round(width) | 0;
		height = global.Math.round(height) | 0;
@endif

		var ie;
		try
		{
			this.absoluteMode += 1;
			(global.Layer_patch_hd_layer_original.fillRect incontextof this)(left, top, width, height, color);
		}
		catch (e)
		{
			ie = e;
		}
		this.absoluteMode -= 1;
		if (ie !== void)
		{
			throw ie;
		}
	}
	function colorRect(left, top, width, height, color, opacity)
	{
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale == 2)
		{
			return (global.Layer_patch_hd_layer_original.colorRect incontextof this)(...);
		}
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		width = ((width < 0 ? -width : width) & 0x7fffffff) * (width < 0 ? -1 : 1);
		height = ((height < 0 ? -height : height) & 0x7fffffff) * (height < 0 ? -1 : 1);
		color &= 0xffffffff;
		if (opacity !== void)
		{
			opacity = ((opacity < 0 ? -opacity : opacity) & 0x7fffffff) * (opacity < 0 ? -1 : 1);
		}
@endif
		left *= this.widthScale;
		top *= this.heightScale;
		width *= this.widthScale;
		height *= this.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		left = global.Math.round(left) | 0;
		top = global.Math.round(top) | 0;
		width = global.Math.round(width) | 0;
		height = global.Math.round(height) | 0;
@endif

		var ie;
		try
		{
			this.absoluteMode += 1;
			(global.Layer_patch_hd_layer_original.colorRect incontextof this)(left, top, width, height, color, opacity);
		}
		catch (e)
		{
			ie = e;
		}
		this.absoluteMode -= 1;
		if (ie !== void)
		{
			throw ie;
		}
	}
	function drawText(left, top, text, color, opacity, aa, slevel, scolor, swidth, sofsx, sofsy)
	{
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale == 2)
		{
			return (global.Layer_patch_hd_layer_original.drawText incontextof this)(...);
		}
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		color &= 0xffffffff;
		if (opacity !== void)
		{
			opacity = ((opacity < 0 ? -opacity : opacity) & 0x7fffffff) * (opacity < 0 ? -1 : 1);
		}
		if (aa !== void)
		{
			aa = !!aa;
		}
		if (slevel !== void)
		{
			slevel = ((slevel < 0 ? -slevel : slevel) & 0x7fffffff) * (slevel < 0 ? -1 : 1);
		}
		if (scolor !== void)
		{
			scolor &= 0xffffffff;
		}
		if (swidth !== void)
		{
			swidth = ((swidth < 0 ? -swidth : swidth) & 0x7fffffff) * (swidth < 0 ? -1 : 1);
		}
		if (sofsx !== void)
		{
			sofsx = ((sofsx < 0 ? -sofsx : sofsx) & 0x7fffffff) * (sofsx < 0 ? -1 : 1);
		}
		if (sofsy !== void)
		{
			sofsy = ((sofsy < 0 ? -sofsy : sofsy) & 0x7fffffff) * (sofsy < 0 ? -1 : 1);
		}
@endif
		left *= this.widthScale;
		top *= this.heightScale;
		swidth *= (this.heightScale < this.widthScale) ? this.heightScale : this.widthScale;
		sofsx *= this.widthScale;
		sofsy *= this.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		left = global.Math.round(left) | 0;
		top = global.Math.round(top) | 0;
		swidth = global.Math.round(swidth) | 0;
		sofsx = global.Math.round(sofsx) | 0;
		sofsy = global.Math.round(sofsy) | 0;
@endif

		var ie;
		try
		{
			this.absoluteMode += 1;
			(global.Layer_patch_hd_layer_original.drawText incontextof this)(left, top, text, color, opacity, aa, slevel, scolor, swidth, sofsx, sofsy);
		}
		catch (e)
		{
			ie = e;
		}
		this.absoluteMode -= 1;
		if (ie !== void)
		{
			throw ie;
		}
	}
	function drawGlyph(left, top, glyph, color, opacity, aa, slevel, scolor, swidth, sofsx, sofsy)
	{
		// Optimization for 1x size.
		if (this.widthScale + this.heightScale == 2)
		{
			return (global.Layer_patch_hd_layer_original.drawGlyph incontextof this)(...);
		}
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
		color &= 0xffffffff;
		if (opacity !== void)
		{
			opacity = ((opacity < 0 ? -opacity : opacity) & 0x7fffffff) * (opacity < 0 ? -1 : 1);
		}
		if (aa !== void)
		{
			aa = !!aa;
		}
		if (slevel !== void)
		{
			slevel = ((slevel < 0 ? -slevel : slevel) & 0x7fffffff) * (slevel < 0 ? -1 : 1);
		}
		if (scolor !== void)
		{
			scolor &= 0xffffffff;
		}
		if (swidth !== void)
		{
			swidth = ((swidth < 0 ? -swidth : swidth) & 0x7fffffff) * (swidth < 0 ? -1 : 1);
		}
		if (sofsx !== void)
		{
			sofsx = ((sofsx < 0 ? -sofsx : sofsx) & 0x7fffffff) * (sofsx < 0 ? -1 : 1);
		}
		if (sofsy !== void)
		{
			sofsy = ((sofsy < 0 ? -sofsy : sofsy) & 0x7fffffff) * (sofsy < 0 ? -1 : 1);
		}
@endif
		left *= this.widthScale;
		top *= this.heightScale;
		swidth *= (this.heightScale < this.widthScale) ? this.heightScale : this.widthScale;
		sofsx *= this.widthScale;
		sofsy *= this.heightScale;

@if(SCALE_ROUND_TOWARDS_NEAREST)
		left = global.Math.round(left) | 0;
		top = global.Math.round(top) | 0;
		swidth = global.Math.round(swidth) | 0;
		sofsx = global.Math.round(sofsx) | 0;
		sofsy = global.Math.round(sofsy) | 0;
@endif

		var ie;
		try
		{
			this.absoluteMode += 1;
			(global.Layer_patch_hd_layer_original.drawGlyph incontextof this)(left, top, glyph, color, opacity, aa, slevel, scolor, swidth, sofsx, sofsy);
		}
		catch (e)
		{
			ie = e;
		}
		this.absoluteMode -= 1;
		if (ie !== void)
		{
			throw ie;
		}
	}
}
global.Layer = Layer_patch_hd_layer_override;


global.Window_patch_hd_layer_original = Window;
class Window_patch_hd_layer_override extends Window_patch_hd_layer_original
{
	var _originalLeft;
	var originalTop;
	var originalWidth;
	var originalHeight;
	var originalInnerWidth;
	var originalInnerHeight;

	var scrollXOffset = 0;
	var scrollYOffset = 0;
	var originalscrollXOffset = void;
	var originalscrollYOffset = void;
	var scrollYOffsetSpeed = 5;
	var scrollYOffsetMin = 0;
	var scrollYOffsetMax = 150;

	property transformedScrollXOffset { getter { return scrollXOffset; } }

	// Under normal conditions result=-scrollYOffset, but this transformation considers different scale/wide factors.
	property transformedScrollYOffset { getter {
		var scale = scrollYOffset / 150; // 0: image unchanged, 150: image scrolled all the way to the bottom.
		var factor = this.wideScreen? wideFactor : cropFactor;
@if(SCALE_USING_FLOATING_POINT)
		var result = originalResHeight * (Math.abs(1 - factor)    ) * scale / wideFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		var result = originalResHeight * (Math.abs(1 - factor) | 0) * scale \ wideFactor;
@endif
		return result;
	} }

	property widthScale { getter { return wideScaleFactor; } }
	property heightScale { getter { return scaleFactor * (this.isMainWindow? cropFactor : 1); } }
	property isMainWindow { getter { return this === global.Window.mainWindow; } }
	property body { getter() { return fore; } }

	property hdScaleFactor
	{
		getter
		{
			if (!this.isMainWindow) {
				return mainWindow.scflags[hdScaleFactorFlagName];
			}
			if (this.scflags[hdScaleFactorFlagName] === void) {
				for (var i=global.scaleFactors.count-1; i>=0; i--) {
					if (patchExists(global.hdPatchesNames[i]) &&
						System.desktopWidth >= originalResWidth * global.scaleFactors[i] && System.desktopHeight >= originalResHeight * global.scaleFactors[i]) {
						this.scflags[hdScaleFactorFlagName] = global.scaleFactors[i];
						break;
					}
				}
				if (this.scflags[hdScaleFactorFlagName] === void) {
					this.scflags[hdScaleFactorFlagName] = 1;
				}
			}
			return this.scflags[hdScaleFactorFlagName];
		}
		setter(v)
		{
			this.scflags[hdScaleFactorFlagName] = v;
		}
	}

	property isHd
	{
		getter
		{
			return this.hdScaleFactor > 1;
		}
	}

	property wideScreen
	{
		getter
		{
			if (!this.isMainWindow) {
				// return mainWindow.scflags[wideScreenFlagName];
				return false;
			}
			if (this.scflags[wideScreenFlagName] === void) {
				this.scflags[wideScreenFlagName] = false;
			}
			return this.scflags[wideScreenFlagName];
		}
		setter(v)
		{
			this.scflags[wideScreenFlagName] = v;
		}
	}

	property wideRatio
	{
		getter
		{
			var retvalue;
			if (!this.wideScreen) {
				retvalue = cubicRatio;
			} else if (this.scflags[autoWideRatioFlagName]) {
				retvalue = systemRatio;
			} else {
				retvalue = this.scflags[wideRatioFlagName] != void? this.scflags[wideRatioFlagName] : systemRatio;
			}
@if(!SCALE_USING_FLOATING_POINT)
			retvalue |= 0;
@endif
			return retvalue;
		}
		setter(v)
		{
			if (!this.wideScreen) {
				this.scflags[autoWideRatioFlagName] = false;
				this.scflags[wideRatioFlagName] = cubicRatio;
			}
			this.scflags[autoWideRatioFlagName] = floatEquals(v, systemRatio);
			this.scflags[wideRatioFlagName] = v;
		}
	}

	property isAutoWide
	{
		getter
		{
			return this.scflags[autoWideRatioFlagName];
		}
	}

	property left
	{
		getter
		{
			if (this.isMainWindow) {
				return super.left;
			} else {
				return this._originalLeft;
			}
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			if (this.isMainWindow) {
				super.left = v;
			} else {
				this._originalLeft = v;
				super.left = (v-mainWindow.left) * this.widthScale + mainWindow.left;
			}
		}
	}

	property top
	{
		getter
		{
			if (this.isMainWindow) {
				return super.top;
			} else {
				return this.originalTop;
			}
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			if (this.isMainWindow) {
				super.top = v;
			} else {
				this.originalTop = v;
				super.top = (v-mainWindow.top) * this.heightScale + mainWindow.top;
			}
		}
	}

	property width
	{
		getter
		{
			return this.originalWidth;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			this.originalWidth = v;
			super.width = v * this.widthScale;
		}
	}

	property height
	{
		getter
		{
			return this.originalHeight;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			this.originalHeight = v;
			super.height = v * this.heightScale;
		}
	}

	property innerWidth
	{
		getter
		{
			return this.originalInnerWidth;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			this.originalInnerWidth = v;
			super.innerWidth = v * this.widthScale;
		}
	}

	property innerHeight
	{
		getter
		{
			return this.originalInnerHeight;
		}
		setter(v)
		{
@if(!SCALE_USING_FLOATING_POINT)
			v = ((v < 0 ? -v : v) & 0x7fffffff) * (v < 0 ? -1 : 1);
@endif
			this.originalInnerHeight = v;
			super.innerHeight = v * this.heightScale;
		}
	}

	function Window_patch_hd_layer_override()
	{
		super.Window(...);
		this._originalLeft = super.left;
		this.originalTop = super.top;
		this.originalWidth = super.width;
		this.originalHeight = super.height;
		this.originalInnerWidth = super.innerWidth;
		this.originalInnerHeight = super.innerHeight;
	}

	function Window()
	{
		Window_patch_hd_layer_override(...);
	}

	function setPos(left, top)
	{
@if(!SCALE_USING_FLOATING_POINT)
		left = ((left < 0 ? -left : left) & 0x7fffffff) * (left < 0 ? -1 : 1);
		top = ((top < 0 ? -top : top) & 0x7fffffff) * (top < 0 ? -1 : 1);
@endif
		if (this.isMainWindow) {
			super.setPos(left, top);
		} else {
			this._originalLeft = left;
			this.originalTop = top;
			super.setPos((left-mainWindow.left) * this.widthScale + mainWindow.left, (top-mainWindow.top) * this.heightScale + mainWindow.top);
		}
	}

	function setInnerSize(innerWidth, innerHeight)
	{
@if(!SCALE_USING_FLOATING_POINT)
		innerWidth = ((innerWidth < 0 ? -innerWidth : innerWidth) & 0x7fffffff) * (innerWidth < 0 ? -1 : 1);
		innerHeight = ((innerHeight < 0 ? -innerHeight : innerHeight) & 0x7fffffff) * (innerHeight < 0 ? -1 : 1);
@endif
		this.originalInnerWidth = innerWidth;
		this.originalInnerHeight = innerHeight;
		super.setInnerSize(innerWidth * this.widthScale, innerHeight * this.heightScale);

@if(!ZOOM_WINDOW)
@if(SCALE_USING_FLOATING_POINT)
		this.originalWidth = super.width / this.widthScale;
		this.originalHeight = super.height / this.heightScale;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		this.originalWidth = super.width \ this.widthScale;
		this.originalHeight = super.height \ this.heightScale;
@endif
@endif
	}

	function setSize(width, height)
	{
@if(!SCALE_USING_FLOATING_POINT)
		width = ((width < 0 ? -width : width) & 0x7fffffff) * (width < 0 ? -1 : 1);
		height = ((height < 0 ? -height : height) & 0x7fffffff) * (height < 0 ? -1 : 1);
@endif
		this.originalWidth = width;
		this.originalHeight = height;
		super.setSize(width * this.widthScale, height * this.heightScale);

@if(!ZOOM_WINDOW)
@if(SCALE_USING_FLOATING_POINT)
		this.originalInnerWidth = super.innerWidth / this.widthScale;
		this.originalInnerHeight = super.innerHeight / this.heightScale;
@endif
@if(!SCALE_USING_FLOATING_POINT)
		this.originalInnerWidth = super.innerWidth \ this.widthScale;
		this.originalInnerHeight = super.innerHeight \ this.heightScale;
@endif
@endif
	}
}
global.Window = Window_patch_hd_layer_override;

global.VideoOverlay_patch_hd_layer_original = VideoOverlay;
class VideoOverlay_patch_hd_layer_override extends VideoOverlay_patch_hd_layer_original
{
	function VideoOverlay_patch_hd_layer_override()
	{
		super.VideoOverlay(...);
	}

	function VideoOverlay()
	{
		VideoOverlay_patch_hd_layer_override(...);
	}

	property width
	{
		getter
		{
@if(SCALE_USING_FLOATING_POINT)
			return super.width / wideScaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
			return super.width \ wideScaleFactor;
@endif
		}
	}

	property height
	{
		getter
		{
@if(SCALE_USING_FLOATING_POINT)
			return super.height / scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
			return super.height \ scaleFactor;
@endif
		}
	}

	property originalWidth
	{
		getter
		{
@if(SCALE_USING_FLOATING_POINT)
			return super.originalWidth / wideScaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
			return super.originalWidth \ wideScaleFactor;
@endif
		}
	}

	property originalHeight
	{
		getter
		{
@if(SCALE_USING_FLOATING_POINT)
			return super.originalHeight / scaleFactor;
@endif
@if(!SCALE_USING_FLOATING_POINT)
			return super.originalHeight \ scaleFactor;
@endif
		}
	}

	function setBounds(left, top, width, height)
	{
		return super.setBounds(left*wideScaleFactor, top*scaleFactor, width*wideScaleFactor, height*scaleFactor);
	}
}
global.VideoOverlay = VideoOverlay_patch_hd_layer_override;
