
global.MessageLayer_patch_messagecharlayer_cache_override_original = MessageLayer;
class MessageLayer_patch_messagecharlayer_cache_override_override extends MessageLayer_patch_messagecharlayer_cache_override_original
{
	function MessageLayer_patch_messagecharlayer_cache_override_override()
	{
		super.MessageLayer(...);
		this.mcrc_fontFace = this.fontFace;
		this.mcrc_fontAngle = this.fontAngle;
		this.mcrc_bold = this.bold;
		this.mcrc_fontItalic = this.fontItalic;
		this.mcrc_fontSize = this.fontSize;
		this.mcrc_antialiased = this.antialiased;
		this.mcrc_chColor = this.chColor;
		this.mcrc_edgeColor = this.edgeColor;
		this.mcrc_shadowColor = this.shadowColor;
		this.mcrc_edgeEmphasis = this.edgeEmphasis;
		this.mcrc_edgeExtent = this.edgeExtent;
		this.mcrc_shadowOffsetX = this.shadowOffsetX;
		this.mcrc_shadowOffsetY = this.shadowOffsetY;
		this.mcrc_vertical = this.vertical;
		&this.fontFace = &this.mcrc_prop_fontFace;
		&this.fontAngle = &this.mcrc_prop_fontAngle;
		&this.bold = &this.mcrc_prop_bold;
		&this.fontItalic = &this.mcrc_prop_fontItalic;
		&this.fontSize = &this.mcrc_prop_fontSize;
		&this.antialiased = &this.mcrc_prop_antialiased;
		&this.chColor = &this.mcrc_prop_chColor;
		&this.edgeColor = &this.mcrc_prop_edgeColor;
		&this.shadowColor = &this.mcrc_prop_shadowColor;
		&this.edgeEmphasis = &this.mcrc_prop_edgeEmphasis;
		&this.edgeExtent = &this.mcrc_prop_edgeExtent;
		&this.shadowOffsetX = &this.mcrc_prop_shadowOffsetX;
		&this.shadowOffsetY = &this.mcrc_prop_shadowOffsetY;
		&this.vertical = &this.mcrc_prop_vertical;
	}

	function MessageLayer()
	{
		MessageLayer_patch_messagecharlayer_cache_override_override(...);
	}

	var fontParams = [];
	var fontParamsStr = "";

	var mcrc_fontFace;
	property mcrc_prop_fontFace
	{
		getter
		{
			return this.mcrc_fontFace;
		}
		setter (v)
		{
			this.mcrc_fontFace = v;
			this.fontParamsStr = "";
		}
	}
	var mcrc_fontAngle;
	property mcrc_prop_fontAngle
	{
		getter
		{
			return this.mcrc_fontAngle;
		}
		setter (v)
		{
			this.mcrc_fontAngle = v;
			this.fontParamsStr = "";
		}
	}
	var mcrc_bold;
	property mcrc_prop_bold
	{
		getter
		{
			return this.mcrc_bold;
		}
		setter (v)
		{
			this.mcrc_bold = v;
			this.fontParamsStr = "";
		}
	}
	var mcrc_fontItalic;
	property mcrc_prop_fontItalic
	{
		getter
		{
			return this.mcrc_fontItalic;
		}
		setter (v)
		{
			this.mcrc_fontItalic = v;
			this.fontParamsStr = "";
		}
	}
	var mcrc_fontSize;
	property mcrc_prop_fontSize
	{
		getter
		{
			return this.mcrc_fontSize;
		}
		setter (v)
		{
			this.mcrc_fontSize = v;
			this.fontParamsStr = "";
		}
	}
	var mcrc_antialiased;
	property mcrc_prop_antialiased
	{
		getter
		{
			return this.mcrc_antialiased;
		}
		setter (v)
		{
			this.mcrc_antialiased = v;
			this.fontParamsStr = "";
		}
	}
	var mcrc_chColor;
	property mcrc_prop_chColor
	{
		getter
		{
			return this.mcrc_chColor;
		}
		setter (v)
		{
			this.mcrc_chColor = v;
			this.fontParamsStr = "";
		}
	}
	var mcrc_edgeColor;
	property mcrc_prop_edgeColor
	{
		getter
		{
			return this.mcrc_edgeColor;
		}
		setter (v)
		{
			this.mcrc_edgeColor = v;
			this.fontParamsStr = "";
		}
	}
	var mcrc_shadowColor;
	property mcrc_prop_shadowColor
	{
		getter
		{
			return this.mcrc_shadowColor;
		}
		setter (v)
		{
			this.mcrc_shadowColor = v;
			this.fontParamsStr = "";
		}
	}
	var mcrc_edgeEmphasis;
	property mcrc_prop_edgeEmphasis
	{
		getter
		{
			return this.mcrc_edgeEmphasis;
		}
		setter (v)
		{
			this.mcrc_edgeEmphasis = v;
			this.fontParamsStr = "";
		}
	}
	var mcrc_edgeExtent;
	property mcrc_prop_edgeExtent
	{
		getter
		{
			return this.mcrc_edgeExtent;
		}
		setter (v)
		{
			this.mcrc_edgeExtent = v;
			this.fontParamsStr = "";
		}
	}
	var mcrc_shadowOffsetX;
	property mcrc_prop_shadowOffsetX
	{
		getter
		{
			return this.mcrc_shadowOffsetX;
		}
		setter (v)
		{
			this.mcrc_shadowOffsetX = v;
			this.fontParamsStr = "";
		}
	}
	var mcrc_shadowOffsetY;
	property mcrc_prop_shadowOffsetY
	{
		getter
		{
			return this.mcrc_shadowOffsetY;
		}
		setter (v)
		{
			this.mcrc_shadowOffsetY = v;
			this.fontParamsStr = "";
		}
	}
	var mcrc_vertical;
	property mcrc_prop_vertical
	{
		getter
		{
			return this.mcrc_vertical;
		}
		setter (v)
		{
			this.mcrc_vertical = v;
			this.fontParamsStr = "";
		}
	}

	function getFontParamsAsString(ruby=false, graph=false, italic, ischar=false, key, max, min)
	{
		var font_params_valid = true;
		if (italic !== void)
		{
			font_params_valid = false;
			// invalidate cache
		}
		else
		{
			italic = fontItalic;
		}
		if (ruby || graph)
		{
			font_params_valid = false;
		}
		if (font_params_valid && this.fontParamsStr !== "")
		{
			return this.fontParamsStr;
		}
		this.fontParams.clear();
		if (graph)
		{
			this.fontParams.push("graph", key, ischar);
		}
		else
		{
			if (ruby)
			{
				this.fontParams.push(fontFace, fontAngle, rubyBold, italic, rubySize, rubyAntialiased, rubyChColor, rubyEdgeColor, rubyShadowColor, max, min);
			}
			else
			{
				this.fontParams.push(fontFace, fontAngle, bold, italic, fontSize, antialiased, chColor, edgeColor, shadowColor);
			}
		}
		this.fontParams.push(edgeEmphasis, edgeExtent, shadowOffsetX, shadowOffsetY, vertical);
		var joined_font_params = this.fontParams.join("|");
		if (font_params_valid && this.fontParamsStr === "")
		{
			this.fontParamsStr = joined_font_params;
		}
		return joined_font_params;
	}

	function cacheCharLayerFromCh(ch, ruby=false, graph=false, italic=false, ischar=false, key, max, min, cache=true)
	{
		var fontParamsAsString = this.getFontParamsAsString(ruby, graph, italic, ischar, key, max, min);
		var knownCharLayers = this.knownCharLayersByFont[fontParamsAsString];
		if (knownCharLayers === void)
		{
			this.knownCharLayersByFont[fontParamsAsString] = %[];
			knownCharLayers = this.knownCharLayersByFont[fontParamsAsString];
		}
		if (knownCharLayers[ch] !== void)
		{
			return;
		}
		with (this.tmpCharLayer)
		{
			.clear();
			if (graph)
			{
				if(ischar)
				{
					if(edge)
						.drawGraphWithEdge(ch, key, chColor, edgeEmphasis, edgeColor, edgeExtent);
					else if(shadow)
						.drawGraphWithShadow(ch, key, chColor, shadowColor, shadowOffsetX, shadowOffsetY);
					else
						.drawGraph(ch, key, chColor);
				}
				else
				{
					.drawGraph(ch, key);
				}
			}
			else
			{
				if (ruby)
				{
					.setFont(fontFace, fontAngle, rubyBold, italic, rubySize);
					if(edge)
						.drawTextWithEdge(ch, rubyChColor, rubyAntialiased, edgeEmphasis, rubyEdgeColor, edgeExtent, vertical, max, min);
					else if(shadow)
						.drawTextWithShadow(ch, rubyChColor, rubyAntialiased, rubyShadowColor, shadowOffsetX, shadowOffsetY, vertical, max, min);
					else
						.drawText(ch, rubyChColor, rubyAntialiased, vertical, max, min);
				}
				else
				{
					.setFont(fontFace, fontAngle, bold, italic, fontSize);
					if(edge)
						.drawTextWithEdge(ch, chColor, antialiased, edgeEmphasis, edgeColor, edgeExtent, vertical);
					else if(shadow)
						.drawTextWithShadow(ch, chColor, antialiased, shadowColor, shadowOffsetX, shadowOffsetY, vertical);
					else
						.drawText(ch, chColor, antialiased, vertical);
				}
			}
		}
		var charlayer = createNewCharLayer();
		charlayer.assignImages(this.tmpCharLayer);
		if (cache)
		{
			knownCharLayers[ch] = charlayer;
		}
		return charlayer;
	}

	function cacheCharLayerFromText(text)
	{
		for (var i = 0, internal_forloop_count = text.length; i < internal_forloop_count; i += 1)
		{
			var ch = text[i];
			this.cacheCharLayerFromCh(ch, false, false, false);
			this.cacheCharLayerFromCh(ch, false, false, true);
		}
	}
}
global.MessageLayer = MessageLayer_patch_messagecharlayer_cache_override_override;
