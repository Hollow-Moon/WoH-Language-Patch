
global.MessageLayer_patch_messagecharlayer_cache_override_original = global.MessageLayer;
class MessageLayer_patch_messagecharlayer_cache_override_override extends global.MessageLayer_patch_messagecharlayer_cache_override_original
{
	function MessageLayer_patch_messagecharlayer_cache_override_override()
	{
		super.MessageLayer(...);
		this.mcrc_fontFace = this.fontFace;
		this.mcrc_fontAngle = this.fontAngle;
		this.mcrc_bold = this.bold;
		this.mcrc_fontItalic = this.fontItalic;
		this.mcrc_fontSize = this.fontSize;
		this.mcrc_antialiased = this.antialiased;
		this.mcrc_chColor = this.chColor;
		this.mcrc_edgeColor = this.edgeColor;
		this.mcrc_shadowColor = this.shadowColor;
		this.mcrc_edgeEmphasis = this.edgeEmphasis;
		this.mcrc_edgeExtent = this.edgeExtent;
		this.mcrc_shadowOffsetX = this.shadowOffsetX;
		this.mcrc_shadowOffsetY = this.shadowOffsetY;
		this.mcrc_vertical = this.vertical;
		&this.fontFace = &this.mcrc_prop_fontFace;
		&this.fontAngle = &this.mcrc_prop_fontAngle;
		&this.bold = &this.mcrc_prop_bold;
		&this.fontItalic = &this.mcrc_prop_fontItalic;
		&this.fontSize = &this.mcrc_prop_fontSize;
		&this.antialiased = &this.mcrc_prop_antialiased;
		&this.chColor = &this.mcrc_prop_chColor;
		&this.edgeColor = &this.mcrc_prop_edgeColor;
		&this.shadowColor = &this.mcrc_prop_shadowColor;
		&this.edgeEmphasis = &this.mcrc_prop_edgeEmphasis;
		&this.edgeExtent = &this.mcrc_prop_edgeExtent;
		&this.shadowOffsetX = &this.mcrc_prop_shadowOffsetX;
		&this.shadowOffsetY = &this.mcrc_prop_shadowOffsetY;
		&this.vertical = &this.mcrc_prop_vertical;
	}

	function MessageLayer()
	{
		this.MessageLayer_patch_messagecharlayer_cache_override_override(...);
	}

	var knownCharLayersByFont = %[]; // Character layer cache.
	var knownCharLayers = void;

	function finalize()
	{
@if(1)
@if(MESSAGELAYER_ACTIONMANAGER)
		stopCharAction();
@endif
		var knownCharLayersArr = [];
		knownCharLayersArr.assign(this.knownCharLayersByFont);
		(global.Dictionary.clear incontextof this.knownCharLayersByFont)();
		for (var i = 0, internal_forloop_count = knownCharLayersArr.count; i < internal_forloop_count; i += 2)
		{
			if (knownCharLayersArr[i + 1] !== void)
			{
				var knownCharLayersArr2 = [];
				knownCharLayersArr2.assign(knownCharLayersArr[i + 1]);
				(global.Dictionary.clear incontextof knownCharLayersArr[i + 1])();
				for (var j = 0, internal_forloop_count = knownCharLayersArr2.count; j < internal_forloop_count; j += 2)
				{
					if (knownCharLayersArr2[j + 1] !== void)
					{
						invalidate knownCharLayersArr2[j + 1];
					}
				}
			}
		}
@endif
		super.finalize();
	}

	var fontParams = [];
	var fontParamsStr = "";

	var mcrc_fontFace;
	property mcrc_prop_fontFace
	{
		getter
		{
			return this.mcrc_fontFace;
		}
		setter (v)
		{
			if (this.mcrc_fontFace !== v)
			{
				this.fontParamsStr = "";
				this.mcrc_fontFace = v;
			}
		}
	}
	var mcrc_fontAngle;
	property mcrc_prop_fontAngle
	{
		getter
		{
			return this.mcrc_fontAngle;
		}
		setter (v)
		{
			if (this.mcrc_fontAngle !== v)
			{
				this.fontParamsStr = "";
				this.mcrc_fontAngle = v;
			}
		}
	}
	var mcrc_bold;
	property mcrc_prop_bold
	{
		getter
		{
			return this.mcrc_bold;
		}
		setter (v)
		{
			if (this.mcrc_bold !== v)
			{
				this.fontParamsStr = "";
				this.mcrc_bold = v;
			}
		}
	}
	var mcrc_fontItalic;
	property mcrc_prop_fontItalic
	{
		getter
		{
			return this.mcrc_fontItalic;
		}
		setter (v)
		{
			if (this.mcrc_fontItalic !== v)
			{
				this.fontParamsStr = "";
				this.mcrc_fontItalic = v;
			}
		}
	}
	var mcrc_fontSize;
	property mcrc_prop_fontSize
	{
		getter
		{
			return this.mcrc_fontSize;
		}
		setter (v)
		{
			if (this.mcrc_fontSize !== v)
			{
				this.fontParamsStr = "";
				this.mcrc_fontSize = v;
			}
		}
	}
	var mcrc_antialiased;
	property mcrc_prop_antialiased
	{
		getter
		{
			return this.mcrc_antialiased;
		}
		setter (v)
		{
			if (this.mcrc_antialiased !== v)
			{
				this.fontParamsStr = "";
				this.mcrc_antialiased = v;
			}
		}
	}
	var mcrc_chColor;
	property mcrc_prop_chColor
	{
		getter
		{
			return this.mcrc_chColor;
		}
		setter (v)
		{
			if (this.mcrc_chColor !== v)
			{
				this.fontParamsStr = "";
				this.mcrc_chColor = v;
			}
		}
	}
	var mcrc_edgeColor;
	property mcrc_prop_edgeColor
	{
		getter
		{
			return this.mcrc_edgeColor;
		}
		setter (v)
		{
			if (this.mcrc_edgeColor !== v)
			{
				this.fontParamsStr = "";
				this.mcrc_edgeColor = v;
			}
		}
	}
	var mcrc_shadowColor;
	property mcrc_prop_shadowColor
	{
		getter
		{
			return this.mcrc_shadowColor;
		}
		setter (v)
		{
			if (this.mcrc_shadowColor !== v)
			{
				this.fontParamsStr = "";
				this.mcrc_shadowColor = v;
			}
		}
	}
	var mcrc_edgeEmphasis;
	property mcrc_prop_edgeEmphasis
	{
		getter
		{
			return this.mcrc_edgeEmphasis;
		}
		setter (v)
		{
			if (this.mcrc_edgeEmphasis !== v)
			{
				this.fontParamsStr = "";
				this.mcrc_edgeEmphasis = v;
			}
		}
	}
	var mcrc_edgeExtent;
	property mcrc_prop_edgeExtent
	{
		getter
		{
			return this.mcrc_edgeExtent;
		}
		setter (v)
		{
			if (this.mcrc_edgeExtent !== v)
			{
				this.fontParamsStr = "";
				this.mcrc_edgeExtent = v;
			}
		}
	}
	var mcrc_shadowOffsetX;
	property mcrc_prop_shadowOffsetX
	{
		getter
		{
			return this.mcrc_shadowOffsetX;
		}
		setter (v)
		{
			if (this.mcrc_shadowOffsetX !== v)
			{
				this.fontParamsStr = "";
				this.mcrc_shadowOffsetX = v;
			}
		}
	}
	var mcrc_shadowOffsetY;
	property mcrc_prop_shadowOffsetY
	{
		getter
		{
			return this.mcrc_shadowOffsetY;
		}
		setter (v)
		{
			if (this.mcrc_shadowOffsetY !== v)
			{
				this.fontParamsStr = "";
				this.mcrc_shadowOffsetY = v;
			}
		}
	}
	var mcrc_vertical;
	property mcrc_prop_vertical
	{
		getter
		{
			return this.mcrc_vertical;
		}
		setter (v)
		{
			if (v !== this.mcrc_vertical)
			{
				this.fontParamsStr = "";
			}
			this.mcrc_vertical = v;
		}
	}

	function getFontParamsAsString(ruby=false, graph=false, italic, ischar=false, key, max, min)
	{
		var font_params_valid = true;
		if (italic !== this.fontItalic)
		{
			font_params_valid = false;
			// invalidate cache
		}
		if (ruby || graph)
		{
			font_params_valid = false;
		}
		if (font_params_valid && this.fontParamsStr !== "")
		{
			return this.fontParamsStr;
		}
		this.fontParams.clear();
		if (graph)
		{
			this.fontParams.push("graph", key, ischar);
		}
		else
		{
			if (ruby)
			{
				this.fontParams.push(this.fontFace, this.fontAngle, this.rubyBold, italic, this.rubySize, this.rubyAntialiased, this.rubyChColor, this.rubyEdgeColor, this.rubyShadowColor, max, min);
			}
			else
			{
				this.fontParams.push(this.fontFace, this.fontAngle, this.bold, italic, this.fontSize, this.antialiased, this.chColor, this.edgeColor, this.shadowColor);
			}
		}
		this.fontParams.push(this.edgeEmphasis, this.edgeExtent, this.shadowOffsetX, this.shadowOffsetY, this.vertical);
		var joined_font_params = this.fontParams.join("|");
		if (font_params_valid && this.fontParamsStr === "")
		{
			this.fontParamsStr = joined_font_params;
		}
		return joined_font_params;
	}
	function getKnownCharLayers(ruby=false, graph=false, italic, ischar=false, key, max, min)
	{
		var font_params_valid = true;
		if (italic !== this.fontItalic)
		{
			font_params_valid = false;
			// invalidate cache
		}
		if (ruby || graph)
		{
			font_params_valid = false;
		}
		if (font_params_valid && this.fontParamsStr !== "" && this.knownCharLayers !== void)
		{
			return this.knownCharLayers;
		}
		var fontParamsAsString = this.getFontParamsAsString(ruby, graph, italic, ischar, key, max, min);
		var known_char_layers = this.knownCharLayersByFont[fontParamsAsString];
		if (known_char_layers === void)
		{
			known_char_layers = %[];
			this.knownCharLayersByFont[fontParamsAsString] = known_char_layers;
		}
		if (font_params_valid)
		{
			this.knownCharLayers = known_char_layers;
		}
		return known_char_layers;
	}

	function cacheCharLayerFromCh(layer, ch, ruby=false, graph=false, italic, ischar=false, key, max, min, cache=true)
	{
		if (ch === "" || ch === void)
		{
			return;
		}
		var knownCharLayers = this.getKnownCharLayers(ruby, graph, italic, ischar, key, max, min);
		if (knownCharLayers[ch] !== void)
		{
			if (layer !== void)
			{
				layer.assignImages(knownCharLayers[ch]);
			}
			return;
		}
		{
			var l = this.tmpCharLayer;
			l.clear();
			if (graph)
			{
				if(ischar)
				{
					if(this.edge)
						l.drawGraphWithEdge(ch, key, this.chColor, this.edgeEmphasis, this.edgeColor, this.edgeExtent);
					else if(this.shadow)
						l.drawGraphWithShadow(ch, key, this.chColor, this.shadowColor, this.shadowOffsetX, this.shadowOffsetY);
					else
						l.drawGraph(ch, key, this.chColor);
				}
				else
				{
					l.drawGraph(ch, key);
				}
			}
			else
			{
				if (ruby)
				{
					l.setFont(this.fontFace, this.fontAngle, this.rubyBold, italic, this.rubySize);
					if(this.edge)
						l.drawTextWithEdge(ch, this.rubyChColor, this.rubyAntialiased, this.edgeEmphasis, this.rubyEdgeColor, this.edgeExtent, this.vertical, max, min);
					else if(this.shadow)
						l.drawTextWithShadow(ch, this.rubyChColor, this.rubyAntialiased, this.rubyShadowColor, this.shadowOffsetX, this.shadowOffsetY, this.vertical, max, min);
					else
						l.drawText(ch, this.rubyChColor, this.rubyAntialiased, this.vertical, max, min);
				}
				else
				{
					l.setFont(this.fontFace, this.fontAngle, this.bold, italic, this.fontSize);
					if(this.edge)
						l.drawTextWithEdge(ch, this.chColor, this.antialiased, this.edgeEmphasis, this.edgeColor, this.edgeExtent, this.vertical);
					else if(this.shadow)
						l.drawTextWithShadow(ch, this.chColor, this.antialiased, this.shadowColor, this.shadowOffsetX, this.shadowOffsetY, this.vertical);
					else
						l.drawText(ch, this.chColor, this.antialiased, this.vertical);
				}
			}
		}
		var charlayer = this.createNewCharLayer();
		charlayer.assignImages(this.tmpCharLayer);
		if (cache)
		{
			knownCharLayers[ch] = charlayer;
		}
		if (layer !== void)
		{
			layer.assignImages(charlayer);
		}
		return charlayer;
	}

	function cacheCharLayerFromText(text, italic=false)
	{
		for (var i = 0, internal_forloop_count = text.length; i < internal_forloop_count; i += 1)
		{
			var ch = text[i];
			this.cacheCharLayerFromCh(void, ch, false, false, italic);
		}
	}
}
global.MessageLayer = global.MessageLayer_patch_messagecharlayer_cache_override_override;
