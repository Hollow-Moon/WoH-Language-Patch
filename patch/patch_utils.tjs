
function name_to_patch_basename(name, isFolder=devMode)
{
	if (isFolder)
	{
		return name.toLowerCase();
	}
	else
	{
		var prefix = "patch";
		if (name !== "" && !/^\d+$/.test(name))
		{ // Not empty and not a number
			prefix += "_";
		}

		return (prefix + name + ".xp3").toLowerCase();
	}
}

function name_to_patch(name, isFolder=devMode, basePath=global.paths_base[0])
{
	return basePath + name_to_patch_basename(name, isFolder);
}

function name_to_patch_path(name, isFolder=devMode, basePath=global.paths_base[0]) {
	var result = name_to_patch(name, isFolder, basePath);
	if (isFolder)
	{
		result += "/";
	}
	else
	{
		result += ">";
	}
	return result;
}

function patchExists(name, isFolder=devMode, basePath=global.paths_base[0]) {
	var result = false;
	if (!isFolder)
	{
		result = global.paths_base_dirlist[basePath]["."].find(name_to_patch_basename(name, false)) !== -1;
		if (devMode2)
		{
			result |= global.paths_base_dirlist[basePath]["."].find(name_to_patch_basename(name, true) + "/") !== -1;
		}
	}
	else
	{
		result = global.paths_base_dirlist[basePath]["."].find(name_to_patch_basename(name, true) + "/") !== -1;
	}
	return result;
}

function load_patches(patch_array, should_add_to_auto_path=true)
{
	var patches_to_add = [];
	for (var i = 0, internal_forloop_count = patch_array.count; i < internal_forloop_count; i += 1)
	{
		if (patch_array[i] === void)
		{
			continue;
		}
		var name = patch_array[i][0];
		if (typeof(name) !== "String")
		{
			throw new Exception("Expected a string when loading patch");
		}
		var folderName = patch_array[i][1];
		if (typeof(folderName) !== "String")
		{
			folderName = "";
		}
		folderName += "/" if folderName != "";
		var basePath = patch_array[i][2];
		if (typeof(basePath) !== "String")
		{
			basePath = global.paths_base[0];
		}
		if (!devMode)
		{
			if (global.paths_base_dirlist[basePath]["."].find(name_to_patch_basename(name, false)) !== -1)
			{
				patches_to_add.add(name_to_patch_path(name, false, basePath) + folderName);
			}
		}
		if (devMode || devMode2)
		{
			var fpath = name_to_patch_path(name, true, basePath) + folderName;
			if (Storages.isExistentDirectory(fpath))
			{
				patches_to_add.add(fpath);
			}
		}
	}
	for (var i = 0, internal_forloop_count = patches_to_add.count; i < internal_forloop_count; i += 1)
	{
		if (should_add_to_auto_path)
		{
			global.Storages.removeAutoPath(patches_to_add[i]);
			global.Storages.removeAutoPath(global.translate_archive_path(patches_to_add[i], false));
			global.Storages.addAutoPath(global.translate_archive_path(patches_to_add[i]));
		}
	}
	return patches_to_add;
}

function unload_patches(patch_array)
{
	var patches_to_remove = [];
	for (var i = 0, internal_forloop_count = patch_array.count; i < internal_forloop_count; i += 1)
	{
		if (patch_array[i] === void)
		{
			continue;
		}
		var name = patch_array[i][0];
		if (typeof(name) !== "String")
		{
			throw new Exception("Expected a string when unloading patch");
		}
		var folderName = patch_array[i][1];
		if (typeof(folderName) !== "String")
		{
			folderName = "";
		}
		folderName += "/" if folderName != "";
		var basePath = patch_array[i][2];
		if (typeof(basePath) !== "String")
		{
			basePath = global.paths_base[0];
		}
		patches_to_remove.add(name_to_patch_path(name, false, basePath) + folderName);
		patches_to_remove.add(name_to_patch_path(name, true, basePath) + folderName);
	}
	for (var i = 0, internal_forloop_count = patches_to_remove.count; i < internal_forloop_count; i += 1)
	{
		Storages.removeAutoPath(patches_to_remove[i]);
		Storages.removeAutoPath(global.translate_archive_path(patches_to_remove[i], false));
	}
}

function getAnchorValue(anchor)
{
	var anchorValue = 0;
	if (anchor == "right") {
		anchorValue = 1;
	} else if (anchor == "center") {
		anchorValue = 0.5;
	} else if (("" + (+anchor)) == anchor) {
		anchorValue = +anchor;
	}
	return anchorValue;
}

Array.contains = function(item) {
	return this.find(item) != -1;
};

function lastIndexOf(obj, str)
{
	var pos = reverseStr(str).indexOf(obj);
	if(pos)
		return str.length - pos - 1;
	else
		return -1;
}

// FHA's exe doesn't have string.reverse
function reverseStr(str)
{
// TODO should also use this method in RN exe.
@if(kirikiriz)
	return str.reverse();
@endif
@if(!kirikiriz)
	var result = "";
	for (var i = str.length - 1; i >= 0; i -= 1) {
		result += str[i];
	}
	return result;
@endif
}

function startsWith(obj, str)
{
	return str.substr(0, obj.length) === obj;
}

function endsWith(obj, str)
{
	return str.substr(str.length - obj.length, obj.length) === obj;
}

function capitalize(str)
{
	return str.substr(0, 1).toUpperCase() + str.substr(1);
}

function addMaskOverlay(layer, name, l=0, t=0, add=true, horizontalAlignment=void)
{
	var overlay = new global.Layer(layer.window, layer);
	with (overlay) {
		if (horizontalAlignment !== void) {
			.horizontalAlignment = horizontalAlignment;
		}
		if (add) {
			.type = ltPsAdditive;
		}
		.isMask = true;
		.loadImages(name);
		layer.operateRect(l, t, overlay, 0, 0, .imageWidth, .imageHeight);
	}
	invalidate overlay;
}


global.defaultScrollbarImages =  [	//	base
	"",//"top_horizontal",
	"",//"base_horizontal",
	"",//"bottom_horizontal",
	"scroll_top_horizontal",
	"scroll_base_horizontal",
	"scroll_bottom_horizontal"
];

function initializeScollbar(x, y, w, h, total, moving, top, scrimgs=defaultScrollbarImages)
{
	mini_layer = new global.FadeLayer(window, this);
	with(mini_layer)
	{
		.setPos(x, y);
		.setSize(w, h);
		.visible = true;
		.hitThreshold = 0;
		.opacity = 255;
		.focusable = true;
		.onMouseDown = function() {
			parent.onMouseDown(...);
		} incontextof mini_layer;
		.onButtonDown = function() {
			parent.onButtonDown(...);
		} incontextof mini_layer;
		.onButtonUp = function() {
			parent.onButtonUp(...);
		} incontextof mini_layer;
	}

	with(scrollbar = new ScrollBarLayer(window, mini_layer, w, 0, 0, false, scrimgs)) //6,6 margin if you use the horizontal background for the scroller
	{
		.top = top; //use top 0 if you use the horizontal background for the scroller
		.total		= total;
		.area		= .width;
		.onscroll	= onScroll;
		.current	= 0;
		.moving		= moving;
	}

	window.org_onMouseWheel	= window.onMouseWheel;
	window.onMouseWheel		= scrollbar.onMouseWheel;
}


/// 停止所有视频图层的播放 ///
function stopAllMovies(kag=global.kag)
{
	for (var i = 0, internal_forloop_count = kag.movies.count; i < internal_forloop_count; i += 1)
	{
		with(kag.movies[i])
		{
			if(.canWaitStop)
				.stop();
		}
	}
}

function isAnyMoviePlaying(kag=global.kag)
{
	for (var i = 0, internal_forloop_count = kag.movies.count; i < internal_forloop_count; i += 1)
	{
		with(kag.movies[i])
		{
			if(.canWaitStop)
				return true;
		}
	}
	return false;
}

function fixAndLoadDictionaryForKrkr2(filename, mode)
{
	var file_as_array = [];
	file_as_array.load(filename, mode);
	return Scripts.eval(file_as_array.join("\n").replace(/\(const\)/g, ""));
}

global.krkrzDictionaryReplace = function(matcharr)
{
	matcharr.erase(0);
	return matcharr.join("");
};

global.krkrzDictionaryRegex1 = new RegExp("(?:real (0x\\d\\.[A-F0-9][A-F0-9][A-F0-9][A-F0-9][A-F0-9][A-F0-9][A-F0-9][A-F0-9][A-F0-9][A-F0-9][A-F0-9][A-F0-9][A-F0-9]p-?\\d*|[-\+]?0\.0|NaN|[-\+]?Infinity)(?: /\\* (?:.*?) \\*/)?|int ([-\\+]?\\d*)|string (\".*\"))", "g");
global.krkrzDictionaryRegex2 = /(?: )(?=\%?\[\n)/g;

function fixAndLoadDictionaryForKrkrZ(filename, mode)
{
	var file_as_array = [];
	file_as_array.load(filename, mode);
	var j = file_as_array.join("\n").replace(global.krkrzDictionaryRegex1, global.krkrzDictionaryReplace).replace(global.krkrzDictionaryRegex2, " (const)");
	Debug.message(j);
	return Scripts.eval(("(const)[ (const)%s ]").sprintf(j))[0];
}

// Avoid CVE-2015-5672
function safeEvalStorage(filename, mode)
{
@if(!KIRIKIROID)
	if (typeof(global.Dictionary) === "Object" && typeof(global.Dictionary.loadStruct) === "Object")
	{
		var ret;
		try
		{
			ret = global.Dictionary.loadStruct(filename, mode);
		}
		catch (e)
		{
			if (e !== void && e.message.indexOf("Invalid argument") !== -1)
			{
				dm("Attempting to fix " + filename + " for Kirikiri Z...");
				return global.fixAndLoadDictionaryForKrkrZ(filename, mode);
			}
			throw e;
		}
		return ret;
	}
	else
@endif
	{
		var ret;
		try
		{
			ret = global.Scripts.evalStorage(filename, mode);
		}
		catch (e)
		{
			if (e !== void && e.message.indexOf("const") !== -1)
			{
				dm("Attempting to fix " + filename + " for Kirikiri 2...");
				return global.fixAndLoadDictionaryForKrkr2(filename, mode);
			}

			throw e;
		}
		return ret;
	}
}

function build_exec_command_line(exepath, arguments, normalize_exepath=true, normalize_arguments=true)
{
	var all_args = [];
	var exe_path = exepath;
	if (normalize_exepath)
	{
		var exe_path_placed = Storages.getPlacedPath(exe_path);
		if (exe_path_placed !== "")
		{
			var exe_path_local = Storages.getLocalName(exe_path_placed);
			if (exe_path_local !== "")
			{
				exe_path = exe_path_local;
			}
		}
	}
	//exe_path = ('"%s"').sprintf(exe_path);
	for (var i = 0, internal_forloop_count = arguments.count; i < internal_forloop_count; i += 1)
	{
		var arg_path = arguments[i];
		if (normalize_arguments)
		{
			if (typeof(arg_path) === "String")
			{
				var arg_path_placed = Storages.getPlacedPath(arg_path);
				if (arg_path_placed !== "")
				{
					var arg_path_local = Storages.getLocalName(arg_path_placed);
					if (arg_path_local !== "")
					{
						arg_path = arg_path_local;
					}
				}
			}
			else if (typeof(arg_path) === "Object")
			{
				var arg_components = [];
				for (var i = 0, internal_forloop_count = arg_path.count; i < internal_forloop_count; i += 1)
				{
					var arg_component = arg_path[i];
					var arg_path_placed = Storages.getPlacedPath(arg_component);
					if (arg_path_placed !== "")
					{
						var arg_path_local = Storages.getLocalName(arg_path_placed);
						if (arg_path_local !== "")
						{
							arg_component = arg_path_local;
						}
					}
					arg_components.add(arg_component);
				}
				arg_path = arg_components.join("");
			}
		}
		else
		{
			if (typeof(arg_path) === "Object")
			{
				arg_path = arg_path.join("");
			}
		}
		all_args.add(arg_path);
	}
	var args_joined = "";
	if (all_args.count === 1)
	{
		args_joined = ('"%s"').sprintf(all_args[0]);
	}
	else if (all_args.count > 1)
	{
		args_joined = ('"%s"').sprintf(all_args.join('" "'));
	}
	return global.System.shellExecute(exe_path, args_joined);
}

function showAboutKirikiriWindow()
{
	if (typeof(global.System.showVersion) === 'Object')
	{
		global.System.showVersion();
	}
	else
	{
		return global.build_exec_command_line(global.System.exeName, ["-about"]);
	}
}

function showEngineConfigureDialog()
{
	return global.build_exec_command_line(global.System.exeName, ["-userconf"]);
}

function showURLUsingDefaultHandler(url)
{
	return global.build_exec_command_line(url, [], false, false);
}

if (typeof(System.clearGraphicCache) !== "Object")
{
	global.System.clearGraphicCache = function() {
		var ccl = System.graphicCacheLimit;
		System.graphicCacheLimit = 0;
		System.graphicCacheLimit = ccl;
	};
}

global.check_app_lock = function()
{
	if (!System.createAppLock(System.exePath.replace(/[^A-Za-z]/g, '_')))
	{
		System.inform(__t("%sはすでに起動しています").sprintf(System.title));
		System.exit();
	}
};

@if(GAME_FATE)
global.prologue_storage_arr = [
	"プロローグ.ks",
	"プロローグ1日目.ks",
	"プロローグ2日目.ks",
	"プロローグ3日目.ks",
];
@endif

global.open_scenario_using_scenario_tracker = function(kag=global.kag, scenario, flowchart_id, flowchart_name=void)
{
@if(GAME_WOHN)
	if (typeof(kag.conductor) !== "Object")
	{
		throw new Exception("Conductor not found!");
	}
	kag.process("call.ks", "*resetall", false, true, true);
	if (tracer_object.chart_storage !== "main.gc")
	{
		tracer_object.load(tracer_object.chart_storage = "main.gc");
	}
	if (flowchart_id === void)
	{
		var block = tracer_object.getBlockFromScript(scenario);
		if (block === void)
		{
			throw new Exception("Couldn't find reference to script " + scenario + " in chart!");
		}
		global.tracer_object.start(block.id, false);
	}
	else
	{
		global.tracer_object.start(flowchart_id, false);
	}
	
	var save_scene_2nd_skip = cf.scene2ndSkip;
	cf.scene2ndSkip = false;
	tracer_object.exec();
	cf.scene2ndSkip = save_scene_2nd_skip;
	if (typeof(scenario) === "String")
	{
		var scripts = global.tracer_object.scripts;
		if (scripts === void)
		{
			throw new Exception("No scripts in block!");
		}
		var script_index = scripts.find(scenario);
		if (script_index === -1)
		{
			throw new Exception("Could not find specified script in block!");
		}
		global.tracer_object.scriptNo = script_index;
	}
	else
	{
		global.tracer_object.scriptNo = 0;
	}
	global.kag.conductor.clearCallStack();
	kag.process("tracerplugin.ks", "*play2");
@endif
@if(GAME_FATE||GAME_FHAT)
	kag.askOnClose = true;
	kag.setHistoryOptions(%[enabled:true]);
	flowchart_id |= 0;
@if(GAME_FATE)
	if (scenario === "タイトル.ks" || scenario === "体験版ダイジェスト仮組04.ks" || scenario === "ラストエピソード.ks" || scenario === "tiger_dojo_joke.ks" || scenario === "セイバーエピローグ.ks" || scenario === "凛エピローグ.ks" || scenario === "凛エピローグ2.ks" || scenario === "桜エピローグ2.ks" || scenario === "桜エピローグ.ks")
	{
		global.kag.setConductorToMain();
		global.kag.conductor.inProcessing = false;
		global.kag.conductor.interupted = false;
		global.kag.conductor.sleep();
		global.kag.process("FlowTrackerPlugin.ks", "*cleanup", false, true, true);
		global.flow_tracker_object.isScenarioExecution = false;
		global.kag.conductor.clearCallStack();
		if (scenario === "タイトル.ks")
		{
			global.kag.process("suflags_hack.ks", "*wakame");
		}
		else if (scenario === "体験版ダイジェスト仮組04.ks")
		{
			global.kag.process("suflags_hack.ks", "*demoonly");
		}
		else if (scenario === "ラストエピソード.ks")
		{
			global.kag.process("suflags_hack.ks", "*realtanua");
		}
		else if (scenario === "tiger_dojo_joke.ks")
		{
			global.kag.process("endlist.ks", "*tiger_dojo_joke");
		}
		else if (scenario === "セイバーエピローグ.ks")
		{
			global.kag.process("endlist.ks", "*fate_true_end");
		}
		else if (scenario === "凛エピローグ.ks")
		{
			global.kag.process("endlist.ks", "*ubw_good_end");
		}
		else if (scenario === "凛エピローグ2.ks")
		{
			global.kag.process("endlist.ks", "*ubw_true_end");
		}
		else if (scenario === "桜エピローグ2.ks")
		{
			global.kag.process("endlist.ks", "*hf_normal_end");
		}
		else if (scenario === "桜エピローグ.ks")
		{
			global.kag.process("endlist.ks", "*hf_true_end");
		}
		return;
	}
@endif
	if (flowchart_name === void && scenario !== void)
	{
		var arr = global.flow_tracker_object.getIdNameFromScenario(scenario);
		flowchart_name = arr[1];
		flowchart_id = arr[0];
	}
	if (flowchart_name === void)
	{
		throw new Exception("Could not find flowchart name from scenario " + scenario);
	}
	global.flow_tracker_object.init(flowchart_name, flowchart_id);
	if (typeof(global.flow_tracker_object.flow) === "Object" && scenario !== void)
	{
		var flow = global.flow_tracker_object.flow;
@if(GAME_FHAT)
		var flowchart = void;
		if (typeof(global.flow_tracker_object.flowchart) === "Object")
		{
			flowchart = global.flow_tracker_object.flowchart;
		}
@endif
		var new_id = 0;
		for (var i = 0, internal_forloop_count = flow.count; i < internal_forloop_count; i += 1)
		{
			if (typeof(flow[i]) !== "Object")
			{
				continue;
			}
			if (typeof(flow[i].type) !== "String")
			{
				continue;
			}
			var t = flow[i].type;
			if (t === "SCENE" || t === "SELECTER")
			{
				var file = void;
@if(GAME_FHAT)
				if (flowchart !== void)
				{
					file = flowchart.getScriptFilename(i);
				}
@endif
@if(GAME_FATE)
				if (typeof(global.flow_tracker_object.flowfile) === "String")
				{
					file = global.flow_tracker_object.getScenarioFileNameFromFcf(global.flow_tracker_object.flowfile, i);
				}
@endif
				if (scenario === file)
				{
					new_id = i;
					break;
				}
			}
		}
		if (new_id !== 0)
		{
			global.flow_tracker_object.init(flowchart_name, new_id);
		}
	}
	if (!global.flow_tracker_object.isPlayOK())
	{
		throw new Exception("Flowchart passed in is invalid");
	}
@if(GAME_FATE)
	global.setSystemMode("scenario");
	if (kag.flags.layer_image === void)
	{
		kag.flags.layer_image = %[];
	}
	kag.flags.layer_image.base = "";
	kag.enabledAutoMode = true;
@endif
	kag.process("flowtrackerplugin.ks", "*moveToAnotherScene");
@endif
};

global.initial_scenario_load_ready = function()
{
@if(GAME_FHAT)
	if (System.getArgument("-loadticketatindex") !== void)
	{
		global.kag.askOnClose = true;
		global.loadTicketFile(System.getArgument("-loadticketatindex") | 0);
		(global.initializeTicketFlagsMenu incontextof global.kag)();
		if (System.getArgument("-loadsaveatindex") === void)
		{
			global.kag.setConductorToMain();
			global.kag.conductor.inProcessing = false;
			global.kag.conductor.interupted = false;
			global.kag.conductor.sleep();
			global.kag.process("title.ks", "*prepare", false, true, true);
			global.kag.process("title.ks", "*pretitle");
		}
	}
@endif
@if(GAME_FATE||GAME_FHAT)
	if (System.getArgument("-testmode") !== void)
	{
		global.testmode = true;
	}
@endif
	if (System.getArgument("-loadsaveatindex") !== void)
	{
		global.kag.askOnClose = true;
		global.kag.loadBookMark(System.getArgument("-loadsaveatindex") | 0);
	}
@if(GAME_WOHN)
	else if (System.getArgument("-archiveopenscenario") !== void)
	{
		global.startArchiveWithScenario(System.getArgument("-archiveopenscenario"));
	}
@endif
	else if (System.getArgument("-flowchartopen") !== void || System.getArgument("-flowchartopenbyscenario") !== void)
	{
		global.open_scenario_using_scenario_tracker(global.kag, System.getArgument("-flowchartopenbyscenario"), System.getArgument("-flowchartopenbyid"), System.getArgument("-flowchartopen"));
	}
	if (System.getArgument("-fullscreen") !== void)
	{
		var should_fullscreen = System.getArgument("-fullscreen") === "true";
		if (should_fullscreen)
		{
			global.kag.onFullScreenMenuItemClick();
		}
		else
		{
			global.kag.onWindowedMenuItemClick();
		}
	}
	else if (typeof(global.kag.scflags.fullScreen) === "Integer")
	{
		var should_fullscreen = global.kag.scflags.fullScreen;
		if (should_fullscreen)
		{
			global.kag.onFullScreenMenuItemClick();
		}
		else
		{
			global.kag.onWindowedMenuItemClick();
		}
	}
	if (System.getArgument("-innersizewidth") !== void)
	{
		if (typeof(global.kag.onWindowSizeMenuItemClick) === "Object")
		{
			global.kag.onWindowSizeMenuItemClick(void, System.getArgument("-innersizewidth") | 0);
		}
	}
	else
	{
		if (typeof(global.kag.callResizeHook) === "Object")
		{
			global.kag.callResizeHook();
		}
	}
};

global.full_game_reload = function(extra_args*)
{
	var should_reload_save = true;
	if ((typeof(global.titlemenu_object) === "Object" && typeof(global.titlemenu_object.menulayer) === "Object" && global.titlemenu_object.menulayer.visible) || typeof(global.titlemenu) === "Object" || typeof(global.ticket_menu) === "Object")
	{
		should_reload_save = false;
	}
	var args_arr = [];
	if (should_reload_save)
	{
		global.kag.saveBookMark(1000, true);
		args_arr.add("-loadsaveatindex=1000");
	}
@if(GAME_FHAT)
	args_arr.add("-readencoding=Shift_JIS");
	if (typeof(global.CurrentTicketNo) === "Integer")
	{
		global.saveTicketFile();
		args_arr.add("-loadticketatindex=" + CurrentTicketNo);
	}
@endif
	args_arr.add("-fullscreen=" + (global.kag.fullScreen ? "true" : "false"));
	args_arr.add("-innersizewidth=" + global.kag.innerWidth);
	for (var i = 0, internal_forloop_count = extra_args.count; i < internal_forloop_count; i += 1)
	{
		args_arr.add(extra_args[i]);
	}
	global.kag.saveSystemVariables();
	global.build_exec_command_line(global.System.exeName, args_arr);
	// Possible savedata mutex race condition?
	if (typeof(global.kag) === "Object")
	{
		global.kag.onCloseQuery(true);
	}
	global.System.exit();
};


function floatEquals(x, y, epsilon=0.0000001) {
	return Math.abs(x - y) < epsilon;
}

// https://stackoverflow.com/a/54137634
global.binary_to_decimal = function(arr)
{
	var decimal = 0;
	var bits = 1;
	for (var i = 0, internal_forloop_count = arr.count; i < internal_forloop_count; i += 1)
	{
		var current_number = (arr[arr.count - i - 1]);
		if (current_number === 1)
		{
			decimal += bits;
		}
		bits *= 2;
	}
	return decimal;
};

// Based on https://gist.github.com/Manouchehri/f4b41c8272db2d6423fa987e844dd9ac
// with modifications to make the output closer to that of TJSRealToHexString
global.real_to_hex_string = function(v)
{
	var ebits = 11;
	var fbits = 52;

	var s, e, f;
	// NaN doesn't equal itself
	if (v !== v)
	{
		return "NaN";
	}
	else if (v === Infinity)
	{
		return "Infinity";
	}
	else if (v === -Infinity)
	{
		return "-Infinity";
	}
	else if (v === 0)
	{
		if (1 / v === -Infinity)
		{
			return "-0.0";
		}
		else
		{
			return "0.0";
		}
	}
	else
	{
		var bias = (1 << (ebits - 1)) - 1;
		s = v < 0;
		v = Math.abs(v);

		if (v >= Math.pow(2, 1 - bias))
		{
			var ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
			e = ln + bias;
			f = v * Math.pow(2, fbits - ln) - Math.pow(2, fbits);
		}
		else
		{
			e = 0;
			f = v / Math.pow(2, 1 - bias - fbits);
		}
	}

	// Pack sign, exponent, fraction
	var fbits_arr = [];
	for (var i = fbits; i !== 0; i -= 1)
	{
		fbits_arr.insert(0, f % 2 ? 1 : 0);
		f = Math.floor(f / 2);
	}
	var ebits_arr = [];
	for (var i = ebits; i !== 0; i -= 1)
	{
		ebits_arr.insert(0, e % 2 ? 1 : 0);
		e = Math.floor(e / 2);
	}

	// Bits to bytes
	return ("%s0x1.%013Xp%d").sprintf(s ? "-" : "", binary_to_decimal(fbits_arr), binary_to_decimal(ebits_arr) - 1023);
};

function reload_messagelayer_config(window=global.kag)
{
	var ignore_changes_tmp = false;
	if (typeof(window.ignore_font_changes) === "Integer" && window.ignore_font_changes)
	{
		ignore_changes_tmp = true;
		window.ignore_font_changes = false;
	}
	var old_current = window.currentNum;
	var old_chr_count = window.fore.layers.count;
	var old_msg_count = window.fore.messages.count;
	window.allocateCharacterLayers(0);
	window.allocateMessageLayers(0);
	window.allocateCharacterLayers(old_chr_count);
	window.allocateMessageLayers(old_msg_count);
	window.current = (window.currentPage?window.back:window.fore).messages[old_current];
	if (ignore_changes_tmp)
	{
		window.ignore_font_changes = true;
	}
@if(GAME_WOHN)
	for (var i = 0; i < old_msg_count; i += 1)
	{
		window.fore.messages[i].appearType = "opaque";
		window.fore.messages[i].appearTimeRate = 3;
	}
@endif
}

{
	if (System.getArgument("-systeminformgoestolog") !== void)
	{
		global.System.inform = function(arg)
		{
			Debug.message(arg);
		};
	}
}

function parse_iso8601(str)
{
	// https://www.myintervals.com/blog/2009/05/20/iso-8601-date-validation-that-doesnt-suck/
	var re = new RegExp("^([\\+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T\\s]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24\\:?00)([\\.,]\\d+(?!:))?)?(\\17[0-5]\\d([\\.,]\\d+)?)?([zZ]|([\\+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$");
	var match = re.match(str);
	if (match.count > 0)
	{
		var date_offset = new Date(1970, 0, 1, 0, 0, 0);
		var date_offset_seconds_total = date_offset.getTime() \ 1000;
		var date_offset_seconds =  (date_offset_seconds_total % 60);
		var date_offset_minutes =  (date_offset_seconds_total \ 60) % 60;
		var date_offset_hours   = ((date_offset_seconds_total \ 60) \ 60) % 60;
		var year = match[1] | 0;
		var month = (match[5] | 0) - 1;
		var day = match[7] | 0;
		var hour = (match[15] | 0) - date_offset_hours;
		var minute = (("" + match[16]).substr(1,3) | 0) - date_offset_minutes;
		var second = (("" + match[19]).substr(1,3) | 0) - date_offset_seconds;
		return new Date(year, month, day, hour, minute, second);
	}
}

global.open_savedata_dir = function(kag=global.kag)
{
	var dir = kag.saveDataLocation;
	if (typeof(dir) === "String" && dir !== "")
	{
		var localpath = Storages.getLocalName(dir);
		if (localpath !== "")
		{
			System.shellExecute(("\"%s\"").sprintf(localpath));
		}
	}
};

global.struct_is_equal = function(s1, s2)
{
	if (s1 === s2)
	{
		return true;
	}
	else if (s1 instanceof "Array" && s2 instanceof "Array" && s1.count == s2.count)
	{
		for (var i = 0, internal_forloop_count = s1.count; i < internal_forloop_count; i += 1)
		{
			var s1item = s1[i];
			var s2item = s2[i];
			if(s1item instanceof "Array" || s1item instanceof "Dictionary")
			{
				if (!global.struct_is_equal(s1item, s2item))
				{
					return false;
				}
			}
			else if (s1item !== s2item)
			{
				return false;
			}
		}
	}
	else if (s1 instanceof "Dictionary" && s2 instanceof "Dictionary")
	{
		var key1 = [];
		var key2 = [];
		key1.assign(s1);
		key2.assign(s2);
		if (key1.count !== key2.count)
		{
			return false;
		}
		for (var i = 0, internal_forloop_count = key1.count; i < internal_forloop_count; i += 2)
		{
			var key = key1[i];
			var s1item = s1[key];
			var s2item = s2[key];
			if (s1item instanceof "Array" || s1item instanceof "Dictionary")
			{
				if (!global.struct_is_equal(s1item, s2item))
				{
					return false;
				}
			}
			else if (s1item !== s2item)
			{
				return false;
			}
		}
	}
	else
	{
		return false;
	}
	return true;
};

// Splits a string (without any delimiters)
function split_string(s)
{
	var split_func = function(matcharr)
	{
		this.add(matcharr[0]);
	};
	var arr = [];
	s.replace(/(?s)./g, (split_func incontextof arr));
	return arr;
}

// Equivalent to JS Array.prototype.slice
function slice_array(in_arr, begin, end)
{
	var arr = [];
	for (var i = begin; i < end; i += 1)
	{
		arr.add(in_arr[i]);
	}
	return arr;
}


function from_codepoint_array(arr)
{
	for (var i = 0; i < arr.count; i += 1)
	{
		arr[i] = $arr[i];
	}
}

function to_codepoint_array(arr)
{
	for (var i = 0; i < arr.count; i += 1)
	{
		arr[i] = #arr[i];
	}
}

// Largely based on the following: http://www.arabic-keyboard.org/photoshop-arabic/
global.LINK_MAP = ['\xFE80', '\xFE81', '\xFE83', '\xFE85', '\xFE87', '\xFE89', '\xFE8D', '\xFE8F', '\xFE93', '\xFE95', '\xFE99', '\xFE9D', '\xFEA1', '\xFEA5', '\xFEA9', '\xFEAB', '\xFEAD', '\xFEAF', '\xFEB1', '\xFEB5', '\xFEB9', '\xFEBD', '\xFEC1', '\xFEC5', '\xFEC9', '\xFECD', '\x063B', '\x063C', '\x063D', '\x063E', '\x063F', '\x0640', '\xFED1', '\xFED5', '\xFED9', '\xFEDD', '\xFEE1', '\xFEE5', '\xFEE9', '\xFEED', '\xFEEF', '\xFEF1'];
global.UNLINK_MAP = ['\x0621', '\x0622', '\x0622', '\x0623', '\x0623', '\x0624', '\x0624', '\x0625', '\x0625', '\x0626', '\x0626', '\x0626', '\x0626', '\x0627', '\x0627', '\x0628', '\x0628', '\x0628', '\x0628', '\x0629', '\x0629', '\x062A', '\x062A', '\x062A', '\x062A', '\x062B', '\x062B', '\x062B', '\x062B', '\x062C', '\x062C', '\x062C', '\x062C', '\x062D', '\x062D', '\x062D', '\x062D', '\x062E', '\x062E', '\x062E', '\x062E', '\x062F', '\x062F', '\x0630', '\x0630', '\x0631', '\x0631', '\x0632', '\x0632', '\x0633', '\x0633', '\x0633', '\x0633', '\x0634', '\x0634', '\x0634', '\x0634', '\x0635', '\x0635', '\x0635', '\x0635', '\x0636', '\x0636', '\x0636', '\x0636', '\x0637', '\x0637', '\x0637', '\x0637', '\x0638', '\x0638', '\x0638', '\x0638', '\x0639', '\x0639', '\x0639', '\x0639', '\x063A', '\x063A', '\x063A', '\x063A', '\x0641', '\x0641', '\x0641', '\x0641', '\x0642', '\x0642', '\x0642', '\x0642', '\x0643', '\x0643', '\x0643', '\x0643', '\x0644', '\x0644', '\x0644', '\x0644', '\x0645', '\x0645', '\x0645', '\x0645', '\x0646', '\x0646', '\x0646', '\x0646', '\x0647', '\x0647', '\x0647', '\x0647', '\x0648', '\x0648', '\x0649', '\x0649', '\x064A', '\x064A', '\x064A', '\x064A'];
global.LAMALEF_LINK_MAP = ['\xFEF5', '\xFEF7', '\x0624', '\xFEF9', '\x0626', '\xFEFB'];
global.LAMALEF_UNLINK_MAP = ['\x0622', '\x0622', '\x0623', '\x0623', '\x0625', '\x0625', '\x0627', '\x0627'];
global.ALEF_CHARS = ['\x0622', '\x0623', '\x0625', '\x0627'];
global.CHAR_LINK_TYPE = [0 /* NONE */, 1 /* BEFORE */, 1 /* BEFORE */, 1 /* BEFORE */, 1 /* BEFORE */, 2 /* DUAL */, 1 /* BEFORE */, 2 /* DUAL */, 1 /* BEFORE */, 2 /* DUAL */, 2 /* DUAL */, 2 /* DUAL */, 2 /* DUAL */, 2 /* DUAL */, 1 /* BEFORE */, 1 /* BEFORE */, 1 /* BEFORE */, 1 /* BEFORE */, 2 /* DUAL */, 2 /* DUAL */, 2 /* DUAL */, 2 /* DUAL */, 2 /* DUAL */, 2 /* DUAL */, 2 /* DUAL */, 2 /* DUAL */, 0 /* NONE */, 0 /* NONE */, 0 /* NONE */, 0 /* NONE */, 0 /* NONE */, 3 /* CAUSING */, 2 /* DUAL */, 2 /* DUAL */, 2 /* DUAL */, 2 /* DUAL */, 2 /* DUAL */, 2 /* DUAL */, 2 /* DUAL */, 1 /* BEFORE */, 2 /* DUAL */, 2 /* DUAL */];

{
	// Convert the arrays unicode to codepoint.
	to_codepoint_array(LINK_MAP);
	to_codepoint_array(UNLINK_MAP);
	to_codepoint_array(LAMALEF_LINK_MAP);
	to_codepoint_array(LAMALEF_UNLINK_MAP);
	to_codepoint_array(ALEF_CHARS);
}

function shape_arabic_is_alef_char(c)
{
	return ALEF_CHARS.find(c) !== -1;
}

function shape_arabic_is_lam_char(c)
{
	return c == #'\x0644' /* LAM_CHAR */;
}

function shape_arabic_is_lam_alef_char(c)
{
	return c >= #'\xFEF5' && c <= #'\xFEFC';
}

function shape_arabic_is_transparent_char(c)
{
	return c >= #'\x064B' && c <= #'\x065E';
}

function shape_arabic_in_link_range(c)
{
	return c >= #'\x0621' /* LINK_MAP_RANGE[0] */ && c <= #'\x064A' /* LINK_MAP_RANGE[1] */;
}

function shape_arabic_in_unlink_range(c)
{
	return c >= #'\xFE80' /* UNLINK_MAP_RANGE[0] */ && c <= #'\xFEF4' /* UNLINK_MAP_RANGE[1] */ || shape_arabic_is_lam_alef_char(c);
}

function shape_arabic_is_linkable_before(c)
{
	if (!shape_arabic_in_link_range(c))
	{
		return false;
	}
	var placement = CHAR_LINK_TYPE[c - #'\x0621' /* LINK_MAP_RANGE[0] */];
	return placement == 1 /* BEFORE */ || placement == 2 /* DUAL */ || placement == 3 /* CAUSING */;
}

function shape_arabic_is_linkable_after(c)
{
	if (!shape_arabic_in_link_range(c))
	{
		return false;
	}
	var placement = CHAR_LINK_TYPE[c - #'\x0621' /* LINK_MAP_RANGE[0] */];
	return placement == 2 /* DUAL */ || placement == 3 /* CAUSING */;
}

function shape_arabic_get_char_link_type(c)
{
	if (!shape_arabic_in_link_range(c))
	{
		return 0 /* NONE */;
	}
	return CHAR_LINK_TYPE[c - #'\x0621' /* LINK_MAP_RANGE[0] */];
}

function shape_arabic_link_char(c, type)
{
	if (!shape_arabic_in_link_range(c))
	{
		return c;
	}
	var indexLookupKey = c - #'\x0621' /* LINK_MAP_RANGE[0] */;
	switch(CHAR_LINK_TYPE[indexLookupKey])
	{
		case 1: /* BEFORE */
			return LINK_MAP[indexLookupKey] + type % 2;
		case 2: /* DUAL */
			return LINK_MAP[indexLookupKey] + type;
		case 0: /* NONE */
			return LINK_MAP[indexLookupKey];
		case 3: /* CAUSING */
		default:
			return c;
	}
}

function shape_arabic_link_lam_alef(c, type)
{
	if (!shape_arabic_is_alef_char(c))
	{
		return c;
	}
	return LAMALEF_LINK_MAP[c - #'\x0622' /* LAMALEF_LINK_MAP_RANGE[0] */] + type % 2;
}

function shape_arabic_unlink_char(c)
{
	if (!shape_arabic_in_unlink_range(c))
	{
		return c;
	}
	return UNLINK_MAP[c - #'\xFE80' /* UNLINK_MAP_RANGE[0] */];
}

function shape_arabic_unlink_lam_alef(c)
{
	if (!shape_arabic_is_lam_alef_char(c))
	{
		return c;
	}
	return LAMALEF_UNLINK_MAP[c - #'\xFEF5' /* LAMALEF_UNLINK_MAP_RANGE[0] */];
}

global.internal_shape_arabic_linkage_temp = [];
function internal_shape_arabic(in_split_text, out_split_text, should_split_by_linkage=false)
{
	var type1;
	var type2 = 0 /* ISOLATED */;
	var res = out_split_text;
	if (should_split_by_linkage)
	{
		res = global.internal_shape_arabic_linkage_temp;
		res.clear();
	}
	for (var i = 0; i < in_split_text.length; i += 1)
	{
		var c = #(in_split_text[i]);
		if (shape_arabic_get_char_link_type(c) === 3 /* CAUSING */)
		{
			res.add($(c));
			type2 = 3 /* MEDIAL */;
			continue;
		}
		var j = i + 1;
		var cj = #(in_split_text[j]);
		for (; j < in_split_text.length - 1 && shape_arabic_is_transparent_char(cj); j += 1)
		{
			cj = #(in_split_text[j]);
		}
		type1 = type2 === 2 /* INITIAL */ || type2 === 3 /* MEDIAL */ ? 1 /* FINAL */ : 0 /* ISOLATED */;
		if (j < in_split_text.length)
		{
			if (shape_arabic_is_lam_char(c) && shape_arabic_is_alef_char(cj))
			{
				res.add($(shape_arabic_link_lam_alef(cj, type1)));
				type2 = type1;
				i = j;
				continue;
			}
			if (shape_arabic_is_linkable_after(c) && shape_arabic_is_linkable_before(cj))
			{
				type1 |= 2 /* INITIAL */;
			}
		}
		{
			res.add($(shape_arabic_link_char(c, type1)));
			if (should_split_by_linkage && (type1 === 1 /* FINAL */ || type1 === 0 /* ISOLATED */))
			{
				if (res.count === 1 && shape_arabic_is_transparent_char(#(res[0])) && out_split_text.count - 1 >= 0)
				{
					out_split_text[out_split_text.count - 1] += res[0];
				}
				else
				{
					out_split_text.add(res.join(""));
				}
				res.clear();
			}
			type2 = type1;
		}
	}
	if (should_split_by_linkage && res.count > 0)
	{
		if (res.count === 1 && shape_arabic_is_transparent_char(#(res[0])) && out_split_text.count - 1 >= 0)
		{
			out_split_text[out_split_text.count - 1] += res[0];
		}
		else
		{
			out_split_text.add(res.join(""));
		}
		res.clear();
	}
}

global.shape_arabic_array_temp = [];
function shape_arabic(text, should_split_by_linkage=false)
{
	text += "";
	if (text.length == 0)
	{
		return text;
	}
	var out_split_text = global.shape_arabic_array_temp;
	out_split_text.clear();
	internal_shape_arabic(text, out_split_text, should_split_by_linkage);
	if (should_split_by_linkage)
	{
		return out_split_text;
	}
	else
	{
		return out_split_text.join("");
	}
}

function internal_unshape_arabic(in_split_text, out_split_text)
{
	for (var i = 0; i < in_split_text.length; i++)
	{
		var isBground = #(in_split_text[i]);
		if (shape_arabic_is_lam_alef_char(isBground))
		{
			out_split_text.add('\x0644' /* LAM_CHAR */);
			out_split_text.add($(shape_arabic_unlink_lam_alef(isBground)));
		}
		else
		{
			out_split_text.add($(shape_arabic_unlink_char(isBground)));
		}
	}
}

global.unshape_arabic_array_temp = [];
function unshape_arabic(text)
{
	text += "";
	if (text.length == 0)
	{
		return text;
	}
	var out_split_text = global.unshape_arabic_array_temp;
	out_split_text.clear();
	var end_pos = internal_unshape_arabic(text, out_split_text);
	return out_split_text.join("");
}

function dmt(args*)
{
	Debug.message(args.join(", ")+": "+Scripts.getTraceString());
}
@if(DEBUG==1)
var	_dm	= Debug.message;
@endif
@if(DEBUG!=1)
var	_dm	= function(){};
@endif

//	krkr 2.25 beta 8 より前のexeには"imageTagLayerType"が存在しないので、仮に定義する
if (typeof global.imageTagLayerType == "undefined")
{
	global.imageTagLayerType	= %[
		opaque:		%[type:ltOpaque],
		rect:		%[type:ltOpaque],
		addalpha:	%[type:ltAddAlpha],
		add:		%[type:ltAdditive],
		sub:		%[type:ltSubtractive],
		mul:		%[type:ltMultiplicative],
		dodge:		%[type:ltDodge],
		darken:		%[type:ltDarken],
		lighten:	%[type:ltLighten],
		screen:		%[type:ltScreen],
	];
}

@if(DEBUG==1)
//開発時トレース用
function getDebugStringFromElm( elm, str="", maxdepth=3, depth=0 )
{
	var tmp = [];
	var ret = "";

	if( elm instanceof "Dictionary" ){
		ret = str + "%[";
		tmp.assign(elm);
		for(var i=0; i<tmp.count; i+=2 ){
			ret += (string)tmp[i] + "=>";
			if( maxdepth == depth || typeof tmp[i+1] != "Object" ){
				ret += (string)tmp[i+1] + ",";
			}else{
				ret += getDebugStringFromElm(tmp[i+1], "", maxdepth, depth+1) + ",";
			}
		}
		ret += "]";
	}else if( elm instanceof "Array" ){
		ret = str;
		for(var i=0; i<elm.count; i++){
			if( maxdepth == depth || typeof elm[i] != "Object" ){
				ret += (string)i + ":" + (string)elm[i] + ",";
			}else{
				ret += getDebugStringFromElm(elm[i], "(array["+i+"])", maxdepth, depth+1) + ",";
			}
//		//再帰処理で長々と出しても仕方ないので２次元配列まで
//			if( elm[i] instanceof "Array" ){
//				for(var j=0; j<elm[i].count; j++){
//					ret += "[" + (string)i + "][" + (string)j + "]=" + (string)elm[i][j] + ",";
//				}
//			}else{
//				ret += (string)i + ":" + (string)elm[i] + ",";
//			}
		}
	}

	return ret;
}
@endif
@if(DEBUG==0)
function getDebugStringFromElm(){ return ""; }
@endif

@if(0)
/*
	実行オプションのチェック
*/
if(typeof global.Plugins.cxdec != "undefined" && typeof global.Plugins.cxdec.embedOptions != "undefined")
{
	var emb = global.Plugins.cxdec.embedOptions.split("\n");
	var opt, ep, tag, val, now;
	for(var i=0; i<emb.count; i++)
	{
		if((opt = emb[i]) == "" || (ep=opt.indexOf("=")) < 0) continue;
		tag = opt.substr(0,ep);
		val = opt.substr(ep+1);
		now = System.getArgument("-"+tag);
		if(now != (val!))
		{
			System.inform(@"不正なオプションです: ${tag}");
			System.exit();
		}
	}
}
@endif

/*
	ClassName の獲得関数
*/
//※あとで適切な場所に移動(krkrirc 2008/04/22 log よりHALO氏の情報)
function getClassName( obj )
{
	var tmp = [];
	var ret = [];
	if( typeof obj == "Object" ){
		ret = Scripts.getClassNames(obj);
		if( ret instanceof "Array" ){
			tmp.assign( ret );

			//for( var i=0; i<tmp.count; i++ )	dm("class: [" + i + "] = " + tmp[i]);
			if( tmp.count > 0 )
				return tmp[0];
		}
	}
	return "is not class object";
}

function getLayerInfo()
{
	var	func	= function(children, indent, func)
	{
		var	text;
		for(var i=0; i<children.count; i++)
		{
			with(children[i])
			{
				if(.parent == kag.primaryLayer && .name == "Menuitem[pool]")
					continue;
				if(children[i] instanceof "MessageCharLayer")
					continue;
				text	+= indent + (.visible ? "■" : "□")+" "+.name+(typeof .layerID != "undefined" ? "/"+.layerID : "")+
					(typeof .storage != "undefined" ? " <"+Storages.extractStorageName(.storage)+">" : "")+
					"["+.type+"]"+
//					"["+(isbase ? ._effect +"/in:"+.childEffect : (typeof ._effect != "undefined" ? (._effect != "" ? ._effect : (typeof .parent.childEffect != "undefined" ? .parent.childEffect : "")): ""))+"]"+
					" ("+.left+", "+.top+(typeof .realLeft != "undefined" ? "/"+.realLeft+","+.realTop+"/"+.realImageLeft+","+.realImageTop : "")+")-"+
					(typeof .center != "undefined" ? ("(C:"+.center+", "+.vcenter+")-") : "")+
					"("+.width+", "+.height+") opac="+.opacity+
					(typeof .zoomx != "undefined" ? " zoom="+(.zoomx == .zoomy ? "%4.2f".sprintf(.zoomx) : "(%4.2f, %4.2f)".sprintf(.zoomx, .zoomy)) : "")+
					(typeof .rotate != "undefined" ? " rot=%4.2f".sprintf(.rotate) : "")+
					(typeof .afx != "undefined" ? " af=(%d, %d)".sprintf(.afx, .afy) : "")+
					(typeof .srcleft != "undefined" ? " (%4.2f, %4.2f)[%4.2f/%4.2f](%d, %d)".sprintf(.srcleft, .srctop, .srczoomx, .srcrotate, .srcafx, .srcafy): "")+
					(typeof .notuse != "undefined" ? " use=%d".sprintf(!.notuse) : "")+"\r\n";
				text	+= func(.children, indent + "  ", func);
			}
		}
		return text;
	};
	return func(kag.primaryLayer.children, "", func);
}
var	sharelogdir		= "file://192.168.101.232/exchange/WoHエラーログ/";
function saveLogToExchange()
{
	if(Storages.isExistentStorage(System.exePath+"savedata/NoSendExchange.txt"))
	{
		dm("saveLogToExchange処理は savedata/NoSendExchange.txt が存在するため中断しました。");
		return;
	}

	var	logfn	= "krkr.console.log";
	var	date	= new Date();
	var	datestr;
	with(date)
		datestr	= "%02d%02d%02d-%02d%02d%02d".sprintf(.getYear() % 100, .getMonth()+1, .getDate(), .getHours(), .getMinutes(), .getSeconds());
	var	linfo	= getLayerInfo();
	dm(linfo);	//	レイヤー構成をログ
	var	savefn	= datestr+".bmp";
	var	savedir	= System.dataPath + "excpdata/";
	Storages.createDirectory(savedir) if !Storages.isExistentDirectory(savedir);
	kag.saveBookMarkToFile(savedir+savefn);	//	セーブ可能ならデータを保存する
	var	copied	= false;
	if(Storages.isExistentDirectory(sharelogdir))
	{
		Storages.exportFile(System.dataPath+logfn, sharelogdir+datestr+"."+logfn);
		Storages.exportFile(savedir+savefn, sharelogdir+savefn);
		copied	= true;
	}

	//	クリップボードに参照情報を書き込み、念のためテキストにも出力
	var	text;
	with(date)
		text	+= "error date: %d年%d月%d日 %02d:%02d:%02d\r\n".sprintf(.getYear(), .getMonth()+1, .getDate(), .getHours(), .getMinutes(), .getSeconds());
	text	+= "error log : "+datestr+"."+logfn+"\r\n";
	text	+= "save data : "+savefn+"\r\n";
	text	+= "layer info: \r\n" + linfo;
	Clipboard.asText	= text;
	var	lines	= [ text ];
	lines.save(System.dataPath+"lasterrorinfo.txt");
	var	msg	= "現在の情報をクリップボードへコピーしました。\n問題の発生を伝えるときに、この情報も渡してください。\n(念の為 savedata/lasterrorinfo.txt にも同じ情報を記録しています)";
	msg	+= "(対応するエラーログ・セーブデータも提出してください)" if !copied;
	System.inform(msg);
}

