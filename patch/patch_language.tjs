// i18n
function __t(text)
{
	return text;
}

function _mt(text)
{
	return text;
}

var settingsDomain = "settings";
function __s(text, context)
{
	return _x(text, context, settingsDomain);
}

function __si(text, context)
{
	return int(__s(string text, context));
}

function __sb(text, context)
{
	return __si(text, context) == true;
}

function __st(text, context)
{
	return text;
}

function __sti(text, context)
{
	return int(__st(text, context));
}

function loadMOs()
{
	removeAllMO();
	loadMoFile("Translation.mo");
	loadMoFile("Settings.mo", settingsDomain);
}

function refreshMenuString(menu)
{
	if(typeof menu.originalCaption !== "undefined") {
		menu.caption = __(menu.originalCaption);
	}

	var children = menu.children;
	for(var i=0; i<children.count; i++)
		refreshMenuString(children[i]);
}

function refreshStringWithLanguage(kag) {
	loadMOs();

	var patch_info_url = __s("https://example.com/", "patch_info_url");
	if (patch_info_url !== "https://example.com/")
	{
		global.PatchInfoURL = patch_info_url;
	}

	if (typeof(global.System) === "Object" && typeof(global.System.update_title) === "Object")
	{
		global.System.update_title();
	}
	if ((typeof(kag) === "Object") && (typeof(kag.menu) === "Object"))
	{
		refreshMenuString(kag.menu);
	}
}
@if(FREETYPE_FONT)
if(typeof(global.frFreeType) !== "undefined" && typeof(global.Font.rasterizer) !== "undefined")
{
	global.Font.rasterizer = frFreeType;
}
@endif
var loaded_language_fonts = [];
function load_fonts(language) {
	if (loaded_language_fonts.contains(language)) {
		return;
	}

	var fontFiles = getFontFiles(language);
	for (var i=0; i<fontFiles.count; i++) {
		if (Storages.isExistentStorage(fontFiles[i]))
		{
@if(0)
			if (typeof(global.Font) !== "undefined" && typeof(global.Font.addFont) !== "undefined")
			{
				// XXX: this doesn't work correctly, even with the names provided by this function.
				global.Font.addFont(fontFiles[i]);
			}
@endif
			if (typeof(System.addFont) !== "undefined")
			{
				var result = System.addFont(fontFiles[i], true);
				if (typeof(result) === "Integer" && result > 0)
				{
					Debug.message(("Successfully added font \"%s\"").sprintf(fontFiles[i]));
				}
				else
				{
					Debug.message(("Failed to add font file \"%s\"").sprintf(fontFiles[i]));
				}
			}
		}
		else
		{
			dm(("warning: font %s does not exist").sprintf(fontFiles[i]));
		}
	}

	loaded_language_fonts.add(language);
}

var loaded_language_prerendered_fonts = [];
function load_prerendered_fonts(language) {
	if (loaded_language_prerendered_fonts.contains(language)) {
		return;
	}

	if (typeof(global.bitmapFonts) === "Object")
	{
		var prerenderedFontFiles = getPrerenderedFontFiles(language);
		for (var i = 0; i < prerenderedFontFiles.count; i += 2)
		{
			dm(("Adding prerendered font %s").sprintf(prerenderedFontFiles[i]));
			global.bitmapFonts.push(prerenderedFontFiles[i]);
			global.bitmapFonts.push(prerenderedFontFiles[i + 1]);
		}
		for (var i = 0; i < global.bitmapFonts.count; i += 2)
		{
			global.loadedBitmapFonts[global.bitmapFonts[i]] = global.bitmapFonts[i + 1];
		}
	}

	loaded_language_prerendered_fonts.add(language);
}


function setFontWithLanguage(language, kag=global.kag)
{
	load_fonts(language);

	/// Main ///
	kag.sflags.userFont[language] = %[
		fontface:get_default_font(),
		bold:false,
		rubybold:false
	] if kag.sflags.userFont[language] === void;

	with(kag)
	{
		var uf = .sflags.userFont[language];
		.chDefaultFace				= uf.fontface;
		if (typeof(.chDefaultBold) === "Integer")
		{
			.chDefaultBold				= uf.bold;
		}
		if (typeof(.chDefaultRubyBold) === "Integer")
		{
			.chDefaultRubyBold				= uf.rubybold;
		}
		.current.defaultBold		= uf.bold;
		.current.defaultRubyBold	= uf.rubybold;
		.setMessageLayerUserFont();
	}

	/// History ///
	var hf = kag.chDefaultFace !== void && get_historyFont(kag)[kag.chDefaultFace] !== void ? get_historyFont(kag)[kag.chDefaultFace] : get_historyFontDefault(kag);

	with(kag.historyLayer.font)
	{
		.face = kag.sflags.historyFont		= hf[0];
		.bold = kag.sflags.historyFontBold	= hf[1];
	}
}

function saveFontWithLanguage(kag=global.kag)
{
	var bold = false;
	var rubybold = false;
	with(kag)
	{
		if (typeof(.chDefaultBold) === "Integer")
		{
			bold = .chDefaultBold;
		}
		else if (typeof(.current) !== "Object")
		{
			return;
		}
		else
		{
			bold = .current.defaultBold;
		}
		if (typeof(.chDefaultRubyBold) === "Integer")
		{
			rubybold = .chDefaultRubyBold;
		}
		else if (typeof(.current) !== "Object")
		{
			return;
		}
		else
		{
			rubybold = .current.defaultRubyBold;
		}
		.sflags.userFont[.sflags.language] = %[
			fontface:.chDefaultFace,
			bold:bold,
			rubybold:rubybold
		];
	}
}

var chara2displayname = %[];
var voicesNames = %[];
var imagesFolderName = "images";
var subbedVideosFlagName = "subbedVideos";
var videosFolderName = "videos";
var japanese_patch_name = devMode? "Japanese" : mainPatchName;
var japaneseLanguageLoaded = false;
var languageSearchPathFile = "LanguageSearchpath.ksc";
var languageSearchPath = [];

function languagePatchName(language) {
	return language == japaneseLanguage? japanese_patch_name : language_patch_prefix + language;
}

function languagePatchExists(language) {
	if (language == japaneseLanguage) {
		return true;
	}
	if (devMode) {
		return Storages.isExistentDirectory(System.exePath + language + "/");
	}
	return patchExists(languagePatchName(language));
}

function load_language_patch(language, kag) {
	var languagePatchName = languagePatchName(language);
	var patches_arr = [];

	if (language != japaneseLanguage || (devMode && !japaneseLanguageLoaded))
	{
		patches_arr.add([languagePatchName]);
	}

	if (language != japaneseLanguage || !japaneseLanguageLoaded) {
		if (devMode)
		{
			patches_arr.add([languagePatchName, "", System.exePath + "../Common/"]);
		}

		patches_arr.add([languagePatchName, imagesFolderName]);
		if (typeof(kag) === "Object")
		{
@if(HD_MODE)
			patches_arr.add([languagePatchName, imagesFolderName + hdFolderSuffix]) if kag.isHd;
@endif
			patches_arr.add([languagePatchName, censoredHFolderName]) if kag.sflags[hCensoredFlagName];
			patches_arr.add([languagePatchName, censoredMatureFolderName]) if !kag.sflags[matureFlagName];
			patches_arr.add([languagePatchName, fullyCensoredFolderName]) if get_fullyCensored(kag);
			patches_arr.add([languagePatchName, videosFolderName]) if kag.sflags[subbedVideosFlagName];
		}
	}

	load_patches(patches_arr);
	invalidate patches_arr;
	delete patches_arr;

	var patch_subfolders = [];
	languageSearchPath = Storages.isExistentStorage(languageSearchPathFile)? Scripts.evalStorage(languageSearchPathFile) : [];
	for (var i=0; i<languageSearchPath.count; i++) {
		patch_subfolders.add([languagePatchName, languageSearchPath[i]]);
	}
	load_patches(patch_subfolders);
	invalidate patch_subfolders;
	delete patch_subfolders;

	refreshStringWithLanguage(kag);
	loadLanguageDict(language);
	load_fonts(language);

	chara2displayname = Storages.isExistentStorage("chara2displayname.dic")? Scripts.evalStorage("chara2displayname.dic") : %[];
	voicesNames = Storages.isExistentStorage("voice-names.dic")? Scripts.evalStorage("voice-names.dic"): %[];
	if (language == japaneseLanguage) {
		japaneseLanguageLoaded = true;
	}
}

function unload_language_patch(language, kag) {
	var languagePatchName = languagePatchName(language);
	var patches_arr = [];

	if (language != japaneseLanguage) {
@if(HD_MODE)
		if (typeof(kag) === "Object")
		{
			patches_arr.add([languagePatchName, imagesFolderName + hdFolderSuffix]) if kag.isHd;
		}
@endif
		patches_arr.add([languagePatchName, imagesFolderName]);
		if (typeof(kag) === "Object")
		{
			patches_arr.add([languagePatchName, censoredHFolderName]) if kag.sflags[hCensoredFlagName];
			patches_arr.add([languagePatchName, censoredMatureFolderName]) if !kag.sflags[matureFlagName];
			patches_arr.add([languagePatchName, fullyCensoredFolderName]) if get_fullyCensored(kag);
			patches_arr.add([languagePatchName, videosFolderName]) if kag.sflags[subbedVideosFlagName];
		}

		for (var i=0; i<languageSearchPath.count; i++) {
			patches_arr.add([languagePatchName, languageSearchPath[i]]);
		}

		patches_arr.add([languagePatchName]);
		if (devMode)
		{
			patches_arr.add([languagePatchName, "", System.exePath + "../Common/"]);
		}
	}

	unload_patches(patches_arr);
	invalidate patches_arr;
	delete patches_arr;

	chara2displayname = %[];
	voicesNames = %[];
}

function loadLanguageSettings() {
	// system locale might be void on older windows systems (such as Windows XP), or systems other than windows (Android, Mac, etc.)
	var systemLocale = System.readRegValue("HKEY_CURRENT_USER\\Control Panel\\International\\LocaleName");
	var found = 0;
	for (var i=0; i < languages.count; i++) {
		var language = languages[i];
		load_language_patch(language, void);

		var locale = __s("ja_JP", "locale");

		if (locale == systemLocale) {
			default_language = language;
			found = 2;
		} else if (found == 0 && systemLocale !== void && locale.substr(0, 2) == systemLocale.substr(0, 2)) {
			default_language = language;
			found = 1;
		}

		unload_language_patch(language, void);
	}
}

// constants
var japaneseLanguage = "japanese";
var englishLanguage = "english";
var koreanLanguage = "korean";
var frenchLanguage = "french";
var simplifiedChineseLanguage = "simplified_chinese";
var russianLanguage = "russian";
var languagesPatches = [englishLanguage, koreanLanguage, russianLanguage, frenchLanguage, simplifiedChineseLanguage];

function loadLanguagesList() {
	if (devMode || isKirikiroid) {
		var patches_arr = [];
		// It's important that Japanese is first.
		var result = [japaneseLanguage];
		for (var i=0; i<languagesPatches.count; i++) {
			if (languagePatchExists(languagesPatches[i])) {
				patches_arr.add([language_patch_prefix + languagesPatches[i]]);
				result.add(languagesPatches[i]);
			}
		}
		unload_patches(patches_arr);
		invalidate patches_arr;
		delete patches_arr;
		return result;
	}

	var patches_arr = [];
	var	files = global.paths_base_dirlist[System.exePath]["."];
	var loadedLanguages = [japaneseLanguage];
	for(var i=0; i<files.count; i++) {
		var	fn	= files[i].toLowerCase();
		var languageRegex = new RegExp("patch_%s(.*)\.xp3".sprintf(language_patch_prefix));
		var langugeFolderRegex = new RegExp("%s(.*)\/".sprintf(language_patch_prefix));
		if (languageRegex.test(fn)) {
			// The following check is because in FHA exe the "matches" member is void.
			var languageName = languageRegex.matches !== void? languageRegex.matches[1] : languageRegex.match(fn)[1];
			patches_arr.add([language_patch_prefix + languageName]);

			if (!loadedLanguages.contains(languageName)) {
				loadedLanguages.add(languageName); // In case there is a folder and an xp3 file, don't add twice.
			}
		} else if (devMode2 && langugeFolderRegex.test(fn)) {
			// The following check is because in FHA exe the "matches" member is void.
			var languageName = langugeFolderRegex.matches !== void? langugeFolderRegex.matches[1] : langugeFolderRegex.match(fn)[1];

			if (!loadedLanguages.contains(languageName)) {
				loadedLanguages.add(languageName); // In case there is a folder and an xp3 file, don't add twice.
			}
		}
	}
	//dm("Loaded languages: " + loadedLanguages.join(", "));
	unload_patches(patches_arr);
	invalidate patches_arr;
	delete patches_arr;
	return loadedLanguages;
}

var language_patch_prefix = devMode? "" : "lang_";
var languageMenuItemFormat = "language%sMenuItem";

var languages = loadLanguagesList();

var default_language = japaneseLanguage;
var languageSettings = %[];
loadLanguageSettings();

// If we only have a single language patch, we most probably want the game to run in that language (regardless of locale).
if (languages.count == 2) {
	default_language = languages[1];
}

initializeDefaultLanguage();

// For convenience
function get_currentLanguageSettings(kag=global.kag) { { return languageSettings[kag.sflags.language]; } }
function get_special_characters(kag=global.kag) { { return get_currentLanguageSettings(kag)["special_characters"] !== void? get_currentLanguageSettings(kag)["special_characters"] : %[]; } }
function get_default_history_font(kag=global.kag) { { return get_currentLanguageSettings(kag)["history_default"]; } }
function get_default_history_bold(kag=global.kag) { { return get_currentLanguageSettings(kag)["history_default_bold"]; } }
function get_historyFontDefault(kag=global.kag) { { return [ get_default_history_font(kag), get_default_history_bold(kag) ]; } }
function get_historyFont(kag=global.kag) { { return get_currentLanguageSettings(kag)["history"] !== void? get_currentLanguageSettings(kag)["history"] : %[]; } }

function get_default_font()
{
	{
		var font_face_to_use = "ＭＳ ゴシック";
		if (typeof(global.fontSettings) === "Object")
		{
			font_face_to_use = fontSettings["window"].face;
		}
		return __s(font_face_to_use, "window_font_face");
	}
}


function getFontFiles(language) {
	var fontFiles = languageSettings[language]["fontFiles"];
	return (fontFiles !== void? fontFiles : []);
}

function getPrerenderedFontFiles(language) {
	var fontFiles = languageSettings[language]["prerenderedFontFiles"];
	return (fontFiles !== void? fontFiles : []);
}


function isChinese(kag=global.kag) {
	//Catch simplified and traditional.
	return /chinese/.test(kag.sflags.language.toLowerCase());
}

function isJapanese(kag=global.kag) {
	return japaneseLanguage == kag.sflags.language.toLowerCase();
}

function isNoSpaceLanguage(kag=global.kag) {
	return isJapanese(kag) || isChinese(kag);
}


function initializeDefaultLanguage() {
	load_language_patch(default_language, void);
}

function initializeLanguage(kag=global.kag) {
	if (kag.sflags.language === void || global.languages.find(kag.sflags.language) === -1) {
		// language already loaded in initializeDefaultLanguage
		kag.sflags.language = default_language;
		kag.sflags.userFont = %[];
	}

	// Load/Reload language after kag is defined:
	unload_language_patch(default_language, kag);
	load_language_patch(kag.sflags.language, kag);

	saveFontWithLanguage(kag);
	if ((typeof(kag) === "Object") && (typeof(kag.menu) === "Object"))
	{
		(addLanguageMenu incontextof kag)();
		kag[languageMenuItemFormat.sprintf(kag.sflags.language)].checked	= true;
	}
}

function addLanguageMenu() {
	menu.insert(this.languageMenu = new KAGMenuItem(this, __t("言語(&Language)"), 0, void, false), patchMenuIndex);
	for (var i = 0; i < languages.count; i++) {
		var language = languages[i];
		var languageMenuItemName = languageMenuItemFormat.sprintf(language);
		this.languageMenu.add(this[languageMenuItemName] = new KAGMenuItem(this, languageSettings[language]["menu_name"], 1,
		function (sender) { sender.owner.onLanguageMenuItemClick(sender, sender.language); }, false));
		this[languageMenuItemName].language = language;
	}
}

function loadLanguageDict(language) {
	if (languageSettings[language] === void) {
		if (Storages.isExistentStorage("language.dic")) {
			languageSettings[language] = Scripts.evalStorage("language.dic");
		} else {
			languageSettings[language] = %[];
		}

		var currentLanguageSettings = languageSettings[language];

		currentLanguageSettings["menu_name"] = __s("日本語 - &Japanese", "language_menu_name");
		currentLanguageSettings["history_default"] = __s("ＭＳ Ｐ明朝", "history_font_face");
		currentLanguageSettings["history_default_bold"] = __sb("1", "history_font_bold");
	}
}

global.Layer_PatchLanguage_original = Layer;
class Layer_PatchLanguage_override extends Layer_PatchLanguage_original
{
	property hint
	{
		setter(v)
		{
			if (typeof(v) === "String")
			{
				super.hint = __(v);
			}
			else
			{
				super.hint = v;
			}
		}
		getter { return super.hint; }
	}

	function Layer_PatchLanguage_override()
	{
		super.Layer(...);
	}

	function Layer()
	{
		Layer_PatchLanguage_override(...);
	}
}
global.Layer = Layer_PatchLanguage_override;

global.Window_PatchLanguage_original = Window;
class Window_PatchLanguage_override extends Window_PatchLanguage_original
{
	function Window_PatchLanguage_override()
	{
		super.Window(...);
	}

	function Window()
	{
		Window_PatchLanguage_override(...);
	}

	function onLanguageMenuItemClick(sender, language)
	{
		if (this.sflags.language == language)
		{
			return;
		}
		saveFontWithLanguage(this);
		unload_language_patch(this.sflags.language, this);
		load_language_patch(language, this);
		this.sflags.language = language;
		setFontWithLanguage(this.sflags.language, this);
		sender.checked = true;
		extraConductor.clear(); // Fix code for AutoPath
		onReloadScenarioMenuItemClick(sender);
		if(typeof global.flow_tracker_object !== "undefined" && typeof flow_tracker_object.flowchart !== "undefined" && flow_tracker_object.flowchart.filename !== void)
		{
			flow_tracker_object.isPlayOK();
			currentPageName = f.scripttitle;
		}
	}

	function replace_font_for_special_characters(elm)
	{
		var originalFontFace = current.lineLayer.font.face;
		var special = get_special_characters(this)[originalFontFace];
		if (special !== void && special[0].contains(elm.text))
		{
			var specialCharactersFontFace = special[1];
			tagHandlers.font(%["face" => specialCharactersFontFace]);
			var restoreFontFaceTag = %[tagname:"font", face:"user"];
			conductor.pendings.insert(0, restoreFontFaceTag);
		}
	}

	function replaceCharacters(obj)
	{
		if (obj.text=="~")
		{
			obj.text = "〜";
		}

		if (this.sflags.language == englishLanguage
			&& obj.text=="　" 							// Japanese whitespace
			&& !startsWith("花札", conductor.curStorage) // Not hanafuda
			)
		{
			obj.text = " ";
		}
	}
}
global.Window = Window_PatchLanguage_override;

global.System_PatchLanguage_original = System;
class System_PatchLanguage_override extends System_PatchLanguage_original
{
	property title
	{
		setter(v)
		{
			global.System.original_title = v;
			if (typeof(v) === "String")
			{
				super.title = __(v);
			}
			else
			{
				super.title = v;
			}
		}
		getter
		{
			if (typeof(global.System.original_title) === "String")
			{
				return global.System.original_title;
			}
			return super.title;
		}
	}

	function update_title()
	{
		if (typeof(global.System.original_title) === "String")
		{
			super.title = __(global.System.original_title);
		}
	}

	function inform(text)
	{
		if (text === System.title + "はすでに起動しています")
		{
			text = __("%sはすでに起動しています").sprintf(System.title);
		}
		return super.inform(text);
	}
}
global.System = System_PatchLanguage_override;

var pluralNames = %[
 "氷室と蒔寺" => 2,
 "桜と藤ねえ" => 2,
 "桜とライダー" => 2,
 "凛と桜とイリヤ" => 3,
 "士郎とハサン" => 2,
 "セイバーと桜" => 2,
 "セイバーと凛とイリヤ" => 3,
 "士郎と桜" => 2,
 "士郎と凛とイリヤ" => 3,
 "凛とイリヤ" => 2,
 "セイバーと凛とキャスター" => 3,
 "士郎と凛" => 2,
 "セイバーとイリヤ" => 2,
 "士郎とセイバーと慎二" => 3,
 "士郎とセイバーと凛" => 3,
 "士郎とイリヤ" => 2,
 "凛と桜" => 2,
 "道場イリヤと道場凛" => 2,
 "士郎とセイバー" => 2,
 "士郎とアーチャー" => 2,
 "凛とセイバー" => 2,
 "氷室と蒔寺と由紀香" => 3,
 "セイバーと凛" => 2,
 "セイバーとランサー" => 2,
 "クラスメートたち" => 30, // dummy value - used to invoke plural form (in this case, average class size).
 "棺の贄" => 100,     // dummy value - used to invoke plural form.
 "others" => 100,    // dummy value - used to invoke plural form.
];
