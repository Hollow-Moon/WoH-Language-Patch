// i18n
function __t(text)
{
	return text;
}

function _mt(text)
{
	return text;
}

var settingsDomain = "settings";
function __s(text, context)
{
	return _x(text, context, settingsDomain);
}

function __si(text, context)
{
	return (__s("" + text, context)) | 0;
}

function __sb(text, context)
{
	return __si(text, context) == true;
}

function __st(text, context)
{
	return text;
}

function __sti(text, context)
{
	return (__st(text, context)) | 0;
}

function loadMOs(language)
{
	removeAllMO();
	var translation_mo_path = find_file_in_language_paths("Translation.mo", language);
	if (typeof(translation_mo_path) === "String")
	{
		loadMoFile(translation_mo_path);
	}
	var settings_mo_path = find_file_in_language_paths("Settings.mo", language);
	if (typeof(settings_mo_path) === "String")
	{
		loadMoFile(settings_mo_path, settingsDomain);
	}
}

function refreshMenuString(kag, menu)
{
	if(typeof menu.originalCaption !== "undefined") {
		menu.caption = __(menu.originalCaption);
	}

	var children = menu.children;
	for(var i=0; i<children.count; i++)
		refreshMenuString(kag, children[i]);
@if(ZOOM_WINDOW)
	kag.refreshExSystemMenu();
@endif
}

function refreshStringWithLanguage(kag, language) {
	loadMOs(language);

	var patch_info_url = __s("https://example.com/", "patch_info_url");
	if (patch_info_url !== "https://example.com/")
	{
		global.PatchInfoURL = patch_info_url;
	}

	if (typeof(global.System) === "Object" && typeof(global.System.update_title) === "Object")
	{
		global.System.update_title();
	}
	if (typeof(kag) === "Object")
	{
		if (typeof(kag.menu) === "Object")
		{
			refreshMenuString(kag, kag.menu);
		}
		if (typeof(kag.hintlayer) === "Object")
		{
			invalidate kag.hintlayer;
			kag.hintlayer = void;
		}
	}
}
@if(FREETYPE_FONT)
if(typeof(global.frFreeType) !== "undefined" && typeof(global.Font.rasterizer) !== "undefined")
{
	global.Font.rasterizer = frFreeType;
}
@endif
var loaded_language_fonts = [];
function load_fonts(language) {
	if (loaded_language_fonts.contains(language)) {
		return;
	}

	var fontFiles = getFontFiles(language);
	for (var i=0; i<fontFiles.count; i++) {
		var font_file_path = find_file_in_language_paths(fontFiles[i], language);
		if (typeof(font_file_path) === "String")
		{
			if (typeof(global.Font) !== "undefined" && typeof(global.Font.addFont) !== "undefined")
			{
				global.Font.addFont(font_file_path);
			}
			if (typeof(System.addFont) !== "undefined")
			{
				var result = System.addFont(font_file_path, true);
				if (typeof(result) === "Integer" && result > 0)
				{
					Debug.message(("Successfully added font \"%s\"").sprintf(fontFiles[i]));
				}
				else
				{
					Debug.message(("Failed to add font file \"%s\"").sprintf(fontFiles[i]));
				}
			}
		}
		else
		{
			dm(("warning: font %s does not exist").sprintf(font_file_path));
		}
	}

	loaded_language_fonts.add(language);
}

var loaded_language_prerendered_fonts = [];
function load_prerendered_fonts(language) {
	if (loaded_language_prerendered_fonts.contains(language)) {
		return;
	}

	if (typeof(global.bitmapFonts) === "Object")
	{
		var prerenderedFontFiles = getPrerenderedFontFiles(language);
		for (var i = 0; i < prerenderedFontFiles.count; i += 2)
		{
			var prerendered_font_file_path = find_file_in_language_paths(prerenderedFontFiles[i + 1], language);
			if (typeof(prerendered_font_file_path) === "String")
			{
				dm(("Adding prerendered font %s").sprintf(prerenderedFontFiles[i]));
				global.bitmapFonts.push(prerenderedFontFiles[i]);
				global.bitmapFonts.push(prerendered_font_file_path);
			}
			else
			{
				dm(("warning: prerendered font %s does not exist").sprintf(prerenderedFontFiles[i]));
			}
		}
		for (var i = 0; i < global.bitmapFonts.count; i += 2)
		{
			global.loadedBitmapFonts[global.bitmapFonts[i]] = global.bitmapFonts[i + 1];
		}
	}

	loaded_language_prerendered_fonts.add(language);
}


function setFontWithLanguage(language, kag=global.kag)
{
	load_fonts(language);

	/// Main ///
	kag.sflags.userFont[language] = %[
		fontface:get_default_font(),
		bold:false,
		rubybold:false
	] if kag.sflags.userFont[language] === void;

	with(kag)
	{
		var uf = .sflags.userFont[language];
		.chDefaultFace				= uf.fontface;
		if (typeof(.chDefaultBold) === "Integer")
		{
			.chDefaultBold				= uf.bold;
		}
		if (typeof(.chDefaultRubyBold) === "Integer")
		{
			.chDefaultRubyBold				= uf.rubybold;
		}
		.current.defaultBold		= uf.bold;
		.current.defaultRubyBold	= uf.rubybold;
		.setMessageLayerUserFont();
	}

	/// History ///
	var hf = kag.chDefaultFace !== void && get_historyFont(kag)[kag.chDefaultFace] !== void ? get_historyFont(kag)[kag.chDefaultFace] : get_historyFontDefault(kag);

	with(kag.historyLayer.font)
	{
		.face = kag.sflags.historyFont		= hf[0];
		.bold = kag.sflags.historyFontBold	= hf[1];
	}
}

function saveFontWithLanguage(kag=global.kag)
{
	var bold = false;
	var rubybold = false;
	with(kag)
	{
		if (typeof(.chDefaultBold) === "Integer")
		{
			bold = .chDefaultBold;
		}
		else if (typeof(.current) !== "Object")
		{
			return;
		}
		else
		{
			bold = .current.defaultBold;
		}
		if (typeof(.chDefaultRubyBold) === "Integer")
		{
			rubybold = .chDefaultRubyBold;
		}
		else if (typeof(.current) !== "Object")
		{
			return;
		}
		else
		{
			rubybold = .current.defaultRubyBold;
		}
		.sflags.userFont[.sflags.language] = %[
			fontface:.chDefaultFace,
			bold:bold,
			rubybold:rubybold
		];
	}
}

var chara2displaynamefile = "chara2displayname.dic";
var chara2displayname = %[];
var imagesFolderName = "images";
var subbedVideosFlagName = "subbedVideos";
var videosFolderName = "videos";
var japanese_patch_name = devMode? "Japanese" : mainPatchName;
var japaneseLanguageLoaded = false;
var languageSearchPathFile = "LanguageSearchpath.ksc";
var languageSearchPath = [];
var languagePatchPaths = [];
var languageFilePathCache = %[];
var languageFileCache = %[];

function find_file_in_language_paths(filename, language = void, exts = "")
{
	// Check for absolute path
	if (typeof(filename) !== "String")
	{
		return false;
	}
	if (filename.indexOf(":") !== -1)
	{
		return false;
	}
@if(kirikiriz)
	if (filename.trim() === "")
	{
		return false;
	}
@endif
	if (typeof(language) !== "String")
	{
		if (typeof(global.kag) === "Object")
		{
			if (typeof(global.kag.sflags) === "Object")
			{
				if (typeof(global.kag.sflags.language) === "String")
				{
					language = global.kag.sflags.language;
				}
			}
		}
	}
	if (typeof(language) !== "String")
	{
		return false;
	}
	if (typeof(languageFileCache[language]) !== "Object")
	{
		languageFileCache[language] = %[];
	}
	if (typeof(languageFilePathCache[language]) !== "Object")
	{
		languageFilePathCache[language] = %[];
	}
	if (typeof(languageFileCache[language][filename]) === "Object")
	{
		return true;
	}
	if (typeof(languageFilePathCache[language][filename]) === "String" || typeof(languageFilePathCache[language][filename]) === "Integer")
	{
		return languageFilePathCache[language][filename];
	}
	if (exts !== "")
	{
		exts = exts.split("|");
	}
	else
	{
		exts = [""];
	}
	var potential_path = false;
	for (var j = 0; j < exts.count; j += 1)
	{
		for (var i = 0; i < languagePatchPaths.count; i += 1)
		{
			try
			{
				var current_potential_path = ("%s%s%s").sprintf(languagePatchPaths[i], filename, exts[j]);
				if (global.Storages.isExistentStorageNoSearchNoNormalize(current_potential_path))
				{
					potential_path = current_potential_path;
				}
			}
			catch(e)
			{

			}
		}
		if (potential_path !== false)
		{
			break;
		}
	}

	languageFilePathCache[language][filename] = potential_path;
	return potential_path;
}

global.Array.load_PatchLanguage_original = global.Array.load;
global.Array.load = function(filename, mode='')
{
	var file_result = void;
@if(GAME_WOHN)
	if (filename !== "first.ks")
@endif
	{
		file_result = find_file_in_language_paths(filename);
	}
	if (typeof(file_result) === "String")
	{
		if ((filename.indexOf(".ks") === filename.length - 3) && global.get_fsncleaner_rescript_enabled() && typeof(global.fsncleaner_rescript) === "Object")
		{
			this.clear();
			this.load_PatchLanguage_original(filename, mode);
			var language_load = [];
			language_load.load_PatchLanguage_original(file_result, mode);
			global.fsncleaner_rescript(this, language_load);
			delete language_load;
			return this;
		}
		return global.Array.load_PatchLanguage_original(file_result, mode);
	}
	else if (typeof(file_result) === "Integer" && file_result === true)
	{
		this.clear();
		var language_load = this;
		if ((filename.indexOf(".ks") === filename.length - 3) && global.get_fsncleaner_rescript_enabled() && typeof(global.fsncleaner_rescript) === "Object")
		{
			language_load = [];
			this.load_PatchLanguage_original(filename, mode);
		}
		language_load.assign(languageFileCache[global.kag.sflags.language][filename]);
		if (language_load.count > 0 && language_load[language_load.count - 1] === "")
		{
			language_load.erase(language_load.count - 1);
		}
		if (language_load !== this)
		{
			global.fsncleaner_rescript(this, language_load);
			delete language_load;
		}
		return this;
	}
	else
	{
		return global.Array.load_PatchLanguage_original(...);
	}
};

global.Scripts.execStorage_PatchLanguage_original = global.Scripts.execStorage;
global.Scripts.execStorage = function(filename, mode='', context=global)
{
	var file_result = find_file_in_language_paths(filename);
	if (typeof(file_result) === "String")
	{
		return global.Scripts.execStorage_PatchLanguage_original(file_result, mode, context);
	}
	else if (typeof(file_result) === "Integer" && file_result === true)
	{
		return global.Scripts.exec(languageFileCache[global.kag.sflags.language][filename].join("\n"), filename, 0, context);
	}
	else
	{
		return global.Scripts.execStorage_PatchLanguage_original(...);
	}
};

global.Scripts.evalStorage_PatchLanguage_original = global.Scripts.evalStorage;
global.Scripts.evalStorage = function(filename, mode='', context=global)
{
	var file_result = find_file_in_language_paths(filename);
	if (typeof(file_result) === "String")
	{
		return global.Scripts.evalStorage_PatchLanguage_original(file_result, mode, context);
	}
	else if (typeof(file_result) === "Integer" && file_result === true)
	{
		return global.Scripts.eval(languageFileCache[global.kag.sflags.language][filename].join("\n"), filename, 0, context);
	}
	else
	{
		return global.Scripts.evalStorage_PatchLanguage_original(...);
	}
};

global.Storages.isExistentStorage_PatchLanguage_original = global.Storages.isExistentStorage;
global.Storages.isExistentStorage = function(filename)
{
	var file_result = find_file_in_language_paths(filename);
	if (typeof(file_result) === "String")
	{
		return true;
	}
	else if (typeof(file_result) === "Integer" && file_result === true)
	{
		return true;
	}
	else
	{
		return global.Storages.isExistentStorage_PatchLanguage_original(...);
	}
};

global.Storages.getPlacedPath_PatchLanguage_original = global.Storages.getPlacedPath;
global.Storages.getPlacedPath = function(filename, exts)
{
	var file_result = find_file_in_language_paths(filename, , exts);
	if (typeof(file_result) === "String")
	{
		return file_result;
	}
	else if (typeof(file_result) === "Integer" && file_result === true)
	{
		return filename;
	}
	else
	{
		return global.Storages.getPlacedPath_PatchLanguage_original(...);
	}
};

function languagePatchName(language) {
	return language == japaneseLanguage? japanese_patch_name : language_patch_prefix + language;
}

function languagePatchExists(language) {
	if (language == japaneseLanguage) {
		return true;
	}
	if (devMode) {
		return Storages.isExistentDirectory("../" + language + "/");
	}
	return patchExists(languagePatchName(language));
}

function load_language_patch(language, kag) {
	var languagePatchName = languagePatchName(language);
	var patches_arr = [];

	if (language != japaneseLanguage || !japaneseLanguageLoaded) {
		patches_arr.add([languagePatchName]);
		if (devMode)
		{
			patches_arr.add([languagePatchName, "", global.typemoon_repo_root + "common/"]);
		}

		patches_arr.add([languagePatchName, imagesFolderName]);
		if (typeof(kag) === "Object")
		{
@if(HD_MODE)
			patches_arr.add([languagePatchName, imagesFolderName + hdFolderSuffix]) if kag.isHd;
@endif
			patches_arr.add([languagePatchName, censoredHFolderName]) if kag.sflags[hCensoredFlagName];
			patches_arr.add([languagePatchName, censoredMatureFolderName]) if !kag.sflags[matureFlagName];
			patches_arr.add([languagePatchName, fullyCensoredFolderName]) if get_fullyCensored(kag);
			patches_arr.add([languagePatchName, videosFolderName]) if kag.sflags[subbedVideosFlagName];
		}
	}

	languagePatchPaths = load_patches(patches_arr, false);

	var language_search_path = find_file_in_language_paths(languageSearchPathFile, language);
	languageSearchPath = (typeof(language_search_path) === "String") ? Scripts.evalStorage(language_search_path) : [];
	if (language != japaneseLanguage || !japaneseLanguageLoaded)
	{
		for (var i = 0; i < languageSearchPath.count; i += 1)
		{
			patches_arr.add([languagePatchName, languageSearchPath[i]]);
		}
	}

	if (language === japaneseLanguage && devMode)
	{
		load_patches(patches_arr, true);
		languagePatchPaths = [];
	}
	else
	{
		languagePatchPaths = load_patches(patches_arr, false);
	}
	invalidate patches_arr;
	delete patches_arr;

	refreshStringWithLanguage(kag, language);
	loadLanguageDict(language);
	load_fonts(language);

	var chara2displayname_dic_path = find_file_in_language_paths(chara2displaynamefile, language);
	chara2displayname = (typeof(chara2displayname_dic_path) === "String") ? Scripts.evalStorage(chara2displayname_dic_path) : %[];
	if (language == japaneseLanguage) {
		japaneseLanguageLoaded = true;
	}
}

function unload_language_patch(language, kag) {
	var languagePatchName = languagePatchName(language);
	var patches_arr = [];

	if (language != japaneseLanguage) {
@if(HD_MODE)
		if (typeof(kag) === "Object")
		{
			patches_arr.add([languagePatchName, imagesFolderName + hdFolderSuffix]) if kag.isHd;
		}
@endif
		patches_arr.add([languagePatchName, imagesFolderName]);
		if (typeof(kag) === "Object")
		{
			patches_arr.add([languagePatchName, censoredHFolderName]) if kag.sflags[hCensoredFlagName];
			patches_arr.add([languagePatchName, censoredMatureFolderName]) if !kag.sflags[matureFlagName];
			patches_arr.add([languagePatchName, fullyCensoredFolderName]) if get_fullyCensored(kag);
			patches_arr.add([languagePatchName, videosFolderName]) if kag.sflags[subbedVideosFlagName];
		}

		for (var i=0; i<languageSearchPath.count; i++) {
			patches_arr.add([languagePatchName, languageSearchPath[i]]);
		}

		patches_arr.add([languagePatchName]);
		if (devMode)
		{
			patches_arr.add([languagePatchName, "", global.typemoon_repo_root + "common/"]);
		}
	}

	unload_patches(patches_arr);
	invalidate patches_arr;
	delete patches_arr;

	if (typeof(languageFileCache[language] !== "Object"))
	{
		invalidate languageFileCache[language];
		delete languageFileCache[language];
	}

	if (typeof(languageFilePathCache[language] !== "Object"))
	{
		invalidate languageFilePathCache[language];
		delete languageFilePathCache[language];
	}

	chara2displayname = %[];
}

function loadLanguageSettings() {
	// system locale might be void on older windows systems (such as Windows XP), or systems other than windows (Android, Mac, etc.)
	var systemLocale = System.readRegValue("HKEY_CURRENT_USER\\Control Panel\\International\\LocaleName");
	var found = 0;
	for (var i=0; i < languages.count; i++) {
		var language = languages[i];
		load_language_patch(language, void);

		var locale = __s("ja_JP", "locale");

		if (locale == systemLocale) {
			default_language = language;
			found = 2;
		} else if (found == 0 && systemLocale !== void && locale.substr(0, 2) == systemLocale.substr(0, 2)) {
			default_language = language;
			found = 1;
		}

		unload_language_patch(language, void);
	}
}

// constants
var japaneseLanguage = "japanese";
var englishLanguage = "english";
var koreanLanguage = "korean";
var frenchLanguage = "french";
var simplifiedChineseLanguage = "simplified_chinese";
var russianLanguage = "russian";
var languagesPatches = [englishLanguage, koreanLanguage, russianLanguage, frenchLanguage, simplifiedChineseLanguage];

function loadLanguagesList() {
	if (devMode || isKirikiroid) {
		var patches_arr = [];
		// It's important that Japanese is first.
		var result = [japaneseLanguage];
		for (var i=0; i<languagesPatches.count; i++) {
			if (languagePatchExists(languagesPatches[i])) {
				patches_arr.add([language_patch_prefix + languagesPatches[i]]);
				result.add(languagesPatches[i]);
			}
		}
		unload_patches(patches_arr);
		invalidate patches_arr;
		delete patches_arr;
		return result;
	}

	var patches_arr = [];
	var	files = global.paths_base_dirlist[global.paths_base[0]]["."];
	var loadedLanguages = [japaneseLanguage];
	for(var i=0; i<files.count; i++) {
		var	fn	= files[i].toLowerCase();
		var languageRegex = new RegExp("patch_%s(.*)\.xp3".sprintf(language_patch_prefix));
		var langugeFolderRegex = new RegExp("%s(.*)\/".sprintf(language_patch_prefix));
		if (languageRegex.test(fn)) {
			// The following check is because in FHA exe the "matches" member is void.
			var languageName = languageRegex.matches !== void? languageRegex.matches[1] : languageRegex.match(fn)[1];
			patches_arr.add([language_patch_prefix + languageName]);

			if (!loadedLanguages.contains(languageName)) {
				loadedLanguages.add(languageName); // In case there is a folder and an xp3 file, don't add twice.
			}
		} else if (devMode2 && langugeFolderRegex.test(fn)) {
			// The following check is because in FHA exe the "matches" member is void.
			var languageName = langugeFolderRegex.matches !== void? langugeFolderRegex.matches[1] : langugeFolderRegex.match(fn)[1];

			if (!loadedLanguages.contains(languageName)) {
				loadedLanguages.add(languageName); // In case there is a folder and an xp3 file, don't add twice.
			}
		}
	}
	//dm("Loaded languages: " + loadedLanguages.join(", "));
	unload_patches(patches_arr);
	invalidate patches_arr;
	delete patches_arr;
	return loadedLanguages;
}

var language_patch_prefix = devMode? "" : "lang_";
var languageMenuItemFormat = "language%sMenuItem";

var languages = loadLanguagesList();

var default_language = japaneseLanguage;
var languageSettings = %[];

// Initialize the Japanese language first.
load_language_patch(default_language, void);

loadLanguageSettings();

// If we only have a single language patch, we most probably want the game to run in that language (regardless of locale).
if (languages.count == 2)
{
	default_language = languages[1];
}

// If the language has changed, reload into the new language.
if (default_language !== japaneseLanguage)
{
	unload_language_patch(japaneseLanguage, void);
	load_language_patch(default_language, void);
}

// For convenience
function get_currentLanguageSettings(kag=global.kag) { { return languageSettings[kag.sflags.language]; } }
function get_special_characters(kag=global.kag) { { return get_currentLanguageSettings(kag)["special_characters"] !== void? get_currentLanguageSettings(kag)["special_characters"] : %[]; } }
function get_default_history_font(kag=global.kag) { { return get_currentLanguageSettings(kag)["history_default"]; } }
function get_default_history_bold(kag=global.kag) { { return get_currentLanguageSettings(kag)["history_default_bold"]; } }
function get_historyFontDefault(kag=global.kag) { { return [ get_default_history_font(kag), get_default_history_bold(kag) ]; } }
function get_historyFont(kag=global.kag) { { return get_currentLanguageSettings(kag)["history"] !== void? get_currentLanguageSettings(kag)["history"] : %[]; } }
function get_fsncleaner_rescript_enabled(kag=global.kag) { { return !!(get_currentLanguageSettings(kag)["fsncleaner_rescript_enabled"]); } }


function get_default_font()
{
	{
		var font_face_to_use = "ＭＳ ゴシック";
		if (typeof(global.fontSettings) === "Object")
		{
			font_face_to_use = fontSettings["window"].face;
		}
		return __s(font_face_to_use, "window_font_face");
	}
}


function getFontFiles(language) {
	var fontFiles = languageSettings[language]["fontFiles"];
	return (fontFiles !== void? fontFiles : []);
}

function getPrerenderedFontFiles(language) {
	var fontFiles = languageSettings[language]["prerenderedFontFiles"];
	return (fontFiles !== void? fontFiles : []);
}


function isChinese(kag=global.kag) {
	//Catch simplified and traditional.
	return /chinese/.test(kag.sflags.language.toLowerCase());
}

function isJapanese(kag=global.kag) {
	return japaneseLanguage == kag.sflags.language.toLowerCase();
}

function isNoSpaceLanguage(kag=global.kag) {
	return isJapanese(kag) || isChinese(kag);
}

function initializeLanguage(kag=global.kag) {
	if (kag.sflags.language === void || global.languages.find(kag.sflags.language) === -1) {
		// language already loaded
		kag.sflags.language = default_language;
		kag.sflags.userFont = %[];
	}

	// Load/Reload language after kag is defined:
	unload_language_patch(default_language, kag);
	load_language_patch(kag.sflags.language, kag);

	saveFontWithLanguage(kag);
	if ((typeof(kag) === "Object") && (typeof(kag.menu) === "Object"))
	{
		(addLanguageMenu incontextof kag)();
		kag[languageMenuItemFormat.sprintf(kag.sflags.language)].checked	= true;
	}
}

function addLanguageMenu() {
	menu.insert(this.languageMenu = new KAGMenuItem(this, __t("言語(&Language)"), 0, void, false), patchMenuIndex);
	for (var i = 0; i < languages.count; i++) {
		var language = languages[i];
		var languageMenuItemName = languageMenuItemFormat.sprintf(language);
		this.languageMenu.add(this[languageMenuItemName] = new KAGMenuItem(this, languageSettings[language]["menu_name"], 1,
		function (sender) { sender.owner.onLanguageMenuItemClick(sender, sender.language); }, false));
		this[languageMenuItemName].language = language;
	}
}

function loadLanguageDict(language) {
	if (languageSettings[language] === void) {
		var language_dic_path = find_file_in_language_paths("language.dic", language);
		if (typeof(language_dic_path) === "String")
		{
			languageSettings[language] = Scripts.evalStorage(language_dic_path);
		}
		else
		{
			languageSettings[language] = %[];
		}

		var currentLanguageSettings = languageSettings[language];

		currentLanguageSettings.menu_name = __s("日本語 - &Japanese", "language_menu_name");
		currentLanguageSettings.history_default = __s("ＭＳ Ｐ明朝", "history_font_face");
		currentLanguageSettings.history_default_bold = __sb("1", "history_font_bold");

		if (typeof(currentLanguageSettings.files) === "Object")
		{
			languageFileCache[language] = %[];
			(Dictionary.assignStruct incontextof languageFileCache[language])(currentLanguageSettings.files);
		}
	}
}

global.Layer_PatchLanguage_original = Layer;
class Layer_PatchLanguage_override extends Layer_PatchLanguage_original
{
	property hint
	{
		setter(v)
		{
			if (typeof(v) === "String")
			{
				super.hint = __(v);
			}
			else
			{
				super.hint = v;
			}
		}
		getter { return super.hint; }
	}

	function Layer_PatchLanguage_override()
	{
		super.Layer(...);
	}

	function Layer()
	{
		Layer_PatchLanguage_override(...);
	}
}
global.Layer = Layer_PatchLanguage_override;

global.Window_PatchLanguage_original = Window;
class Window_PatchLanguage_override extends Window_PatchLanguage_original
{
	function Window_PatchLanguage_override()
	{
		super.Window(...);
	}

	function Window()
	{
		Window_PatchLanguage_override(...);
	}

	function onLanguageMenuItemClick(sender, language)
	{
		if (this.sflags.language == language)
		{
			return;
		}
		saveFontWithLanguage(this);
		unload_language_patch(this.sflags.language, this);
		load_language_patch(language, this);
		this.sflags.language = language;
		setFontWithLanguage(this.sflags.language, this);
		sender.checked = true;
		extraConductor.clear(); // Fix code for AutoPath
@if(GAME_WOHN)
		// Reload the font configuration.
		global.reload_messagelayer_config(this);
@endif
		onReloadScenarioMenuItemClick(sender);
		if(typeof global.flow_tracker_object !== "undefined" && typeof flow_tracker_object.flowchart !== "undefined" && flow_tracker_object.flowchart.filename !== void)
		{
			flow_tracker_object.isPlayOK();
			currentPageName = f.scripttitle;
		}
	}

	function replace_font_for_special_characters(elm)
	{
		var originalFontFace = current.lineLayer.font.face;
		var special = get_special_characters(this)[originalFontFace];
		if (special !== void && special[0].contains(elm.text))
		{
			var specialCharactersFontFace = special[1];
			tagHandlers.font(%["face" => specialCharactersFontFace]);
			var restoreFontFaceTag = %[tagname:"font", face:"user"];
			conductor.pendings.insert(0, restoreFontFaceTag);
		}
	}

	function replaceCharacters(obj)
	{
		if (#(obj.text) === 126) // "~"
		{
			obj.text = "〜";
		}

		if (
			#(obj.text) === 12288 					// Japanese whitespace "　"
			&& this.sflags.language == englishLanguage
			&& !startsWith("花札", conductor.curStorage) // Not hanafuda
			)
		{
			obj.text = " ";
		}
	}
}
global.Window = Window_PatchLanguage_override;

global.System_PatchLanguage_original = System;
class System_PatchLanguage_override extends System_PatchLanguage_original
{
	property title
	{
		setter(v)
		{
			global.System.original_title = v;
			if (typeof(v) === "String")
			{
				super.title = __(v);
			}
			else
			{
				super.title = v;
			}
		}
		getter
		{
			if (typeof(global.System.original_title) === "String")
			{
				return global.System.original_title;
			}
			return super.title;
		}
	}

	function update_title()
	{
		if (typeof(global.System.original_title) === "String")
		{
			super.title = __(global.System.original_title);
		}
	}

	function inform(text)
	{
		if (text === System.title + "はすでに起動しています")
		{
			text = __("%sはすでに起動しています").sprintf(System.title);
		}
		return super.inform(text);
	}
}
global.System = System_PatchLanguage_override;

var pluralNames = %[
 "氷室と蒔寺" => 2,
 "桜と藤ねえ" => 2,
 "桜とライダー" => 2,
 "凛と桜とイリヤ" => 3,
 "士郎とハサン" => 2,
 "セイバーと桜" => 2,
 "セイバーと凛とイリヤ" => 3,
 "士郎と桜" => 2,
 "士郎と凛とイリヤ" => 3,
 "凛とイリヤ" => 2,
 "セイバーと凛とキャスター" => 3,
 "士郎と凛" => 2,
 "セイバーとイリヤ" => 2,
 "士郎とセイバーと慎二" => 3,
 "士郎とセイバーと凛" => 3,
 "士郎とイリヤ" => 2,
 "凛と桜" => 2,
 "道場イリヤと道場凛" => 2,
 "士郎とセイバー" => 2,
 "士郎とアーチャー" => 2,
 "凛とセイバー" => 2,
 "氷室と蒔寺と由紀香" => 3,
 "セイバーと凛" => 2,
 "セイバーとランサー" => 2,
 "クラスメートたち" => 30, // dummy value - used to invoke plural form (in this case, average class size).
 "棺の贄" => 100,     // dummy value - used to invoke plural form.
 "others" => 100,    // dummy value - used to invoke plural form.
];
