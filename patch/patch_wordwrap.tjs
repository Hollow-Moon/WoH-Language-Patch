@if(__WORDWRAP_DEFINED__==0)
@set(__WORDWRAP_DEFINED__=1)

@if(GAME_WOHN)
@set(USE_GET_GLYPH_DRAW_RECT=1)
@endif

@set(DO_WORDWRAP_BENCHMARK=0)
@set(USE_GET_INDIVIDUAL_CHARS=1)

global.HistoryLayer_patch_wordwrap_original = HistoryLayer;
class HistoryLayer_patch_wordwrap_override extends HistoryLayer_patch_wordwrap_original
{
	function HistoryLayer_patch_wordwrap_override()
	{
		super.HistoryLayer(...);
	}

	function HistoryLayer()
	{
		HistoryLayer_patch_wordwrap_override(...);
	}

	function nextWord(elm)
	{
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
		var currentWordWidth = elm.hllength;
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
		var currentWordWidth = 0;
		var bold = this.font.bold;
		var italic = this.font.italic;
		if (bold && italic)
		{
			currentWordWidth = elm.hllengthbi;
		}
		else if (bold)
		{
			currentWordWidth = elm.hllengthb;
		}
		else if (italic)
		{
			currentWordWidth = elm.hllengthi;
		}
		else
		{
			currentWordWidth = elm.hllength;
		}
@endif
		if ((getCurrentLineWidth() + currentWordWidth) >= relinePos && currentWordWidth < relinePos)
		{
			if (reline())
			{
				return autoReturn;
			}
		}
		return false;
	}

	function needsReline(elm)
	{
		var currentWordWidth = 0;
		if (typeof(elm) === "Object")
		{
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
			currentWordWidth = elm.hllength;
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
			var bold = this.font.bold;
			var italic = this.font.italic;
			if (bold && italic)
			{
				currentWordWidth = elm.hllengthbi;
			}
			else if (bold)
			{
				currentWordWidth = elm.hllengthb;
			}
			else if (italic)
			{
				currentWordWidth = elm.hllengthi;
			}
			else
			{
				currentWordWidth = elm.hllength;
			}
@endif
		}
		else
		{
			currentWordWidth = this.font.getTextWidth(elm);
		}

		if ((getCurrentLineWidth() + currentWordWidth) >= relinePos && currentWordWidth < relinePos)
		{
			return true;
		}
		return false;
	}
}
global.HistoryLayer = HistoryLayer_patch_wordwrap_override;

global.MessageLayer_patch_wordwrap_original = MessageLayer;
class MessageLayer_patch_wordwrap_override extends MessageLayer_patch_wordwrap_original
{
@if(GAME_WOHN)
	var char2graph_arr = [];
@endif
	function MessageLayer_patch_wordwrap_override()
	{
		super.MessageLayer(...);
@if(GAME_WOHN)
		this.char2graph_arr.assign(this.char2graph);
@endif
	}

	function MessageLayer()
	{
		MessageLayer_patch_wordwrap_override(...);
	}

	function shouldReline(ch)
	{
		var vert = vertical;
		if((vert ?  y >= relinexpos  : x >= relinexpos ) && autoReturn)
		{
			if(((lastDrawnCh=="" || wwLeading.indexOf(lastDrawnCh)==-1) &&
				wwFollowing.indexOf(ch)==-1) ||
				(lastDrawnCh!="" && wwFollowingWeak.indexOf(lastDrawnCh)!=-1 &&
					wwFollowingWeak.indexOf(ch)!=-1))
			{
				// 最後に描画したのが行末禁則文字でない場合
				// しかもこれから描画するのが行頭禁則文字でない
				// 場合
				// または弱禁則文字が連続していない場合
				return true;
			}
			else if(vert ? ( y>imageHeight ) : (x>imageWidth))
			{
				// これから描画するのが強禁則文字ではなくて、
				// 確実に 右端を越える場合
				// ( この場合は余白は考えない )
				return true;
			}
		}
		return false;
	}

	function nextWord(elm)
	{
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
		var currentWordWidth = elm.mllength;
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
		var currentWordWidth = 0, bold = false, italic = false;
		if (typeof(this.lineLayer) === "Object")
		{
			bold = this.lineLayer.font.bold;
			italic = this.lineLayer.font.italic;
		}
		else if (typeof(this.getChWidth) === "Object")
		{
			bold = this.bold;
			italic = this.fontItalic;
		}
		if (bold && italic)
		{
			currentWordWidth = elm.mllengthbi;
		}
		else if (bold)
		{
			currentWordWidth = elm.mllengthb;
		}
		else if (italic)
		{
			currentWordWidth = elm.mllengthi;
		}
		else
		{
			currentWordWidth = elm.mllength;
		}
@endif
		if ((x + currentWordWidth) >= relinexpos && currentWordWidth < relinexpos)
		{
			if (reline())
			{
				return autoReturn;
			}
		}
		return false;
	}

	function needsReline(elm)
	{
		var currentWordWidth = 0;
		if (typeof(elm) === "Object")
		{
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
			currentWordWidth = elm.mllength;
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
			var bold = false, italic = false;
			if (typeof(this.lineLayer) === "Object")
			{
				bold = this.lineLayer.font.bold;
				italic = this.lineLayer.font.italic;
			}
			else if (typeof(this.getChWidth) === "Object")
			{
				bold = this.bold;
				italic = this.fontItalic;
			}
			if (bold && italic)
			{
				currentWordWidth = elm.mllengthbi;
			}
			else if (bold)
			{
				currentWordWidth = elm.mllengthb;
			}
			else if (italic)
			{
				currentWordWidth = elm.mllengthi;
			}
			else
			{
				currentWordWidth = elm.mllength;
			}
@endif
		}
		else
		{
			if (typeof(this.lineLayer) === "Object")
			{
				currentWordWidth = this.lineLayer.font.getTextWidth(elm);
			}
			else if (typeof(this.getChWidth) === "Object")
			{
				currentWordWidth = this.getChWidth(elm)[1];
			}
		}

		if ((x + currentWordWidth) >= relinexpos && currentWordWidth < relinexpos)
		{
			return true;
		}
		return false;
	}
}
global.MessageLayer = MessageLayer_patch_wordwrap_override;

global.KAGWindow_patch_wordwrap_original = KAGWindow;
class KAGWindow_patch_wordwrap_override extends KAGWindow_patch_wordwrap_original
{
	function KAGWindow_patch_wordwrap_override()
	{
		super.KAGWindow(...);
	}

	function KAGWindow()
	{
		KAGWindow_patch_wordwrap_override(...);
	}

	var word_lines_scenario_changed = false;
	function onConductorScenarioLoad()
	{
		if (this.conductor === this.mainConductor)
		{
			this.words.clear();
@if(0)
			this.inQuotes = 0;
@endif
			this.word_lines_scenario_changed = true;
		}
		return super.onConductorScenarioLoad(...);
	}

	function onConductorScenarioLoaded()
	{
		if ((this.conductor === this.mainConductor) && (this.word_lines_space.count !== 0 || this.word_lines_chinese.count !== 0))
		{
			if ((typeof(this.current) === "Object" && !isvalid(this.current)) || (typeof(this.current) !== "Object") || (this.fore.messages.count === 0))
			{
				this.allocateMessageLayers(1);
				global.reload_messagelayer_config(this);
			}
			this.setMessageLayerUserFont();
			this.clearMessageLayers();
			if (this.word_lines_scenario_changed || this.check_word_length_cache())
			{
				this.word_lines_scenario_changed = false;
				this.generate_word_wrapping_list(this.conductor);
			}
		}

		return super.onConductorScenarioLoaded(...);
	}

	var words = [];

	//Chinese
	var currentWordIndex = 0;
	var currentCharPos = 0;

	var word_lines_current_storage = "";

	function onNewLine(elm)
	{
		var is_japanese = isJapanese();
		if (is_japanese)
		{
			// Don't bother doing the wordwrap calculations since we won't be using them
			return;
		}
		if (this.conductor === this.extraConductor)
		{
			// We don't do wordwrap on the extra conductor
			return;
		}

@if(0)
		processQuotedLine();
@endif

		{
			this.words.clear();
		}

		var clean = this.conductor.cleaned_lines[elm.__patch_conductor_line];

		if ((clean === void) || (clean !== void && clean.length === 0)) return;

		if (isChinese()) {
			onNewLineWordWrapChinese(elm.__patch_conductor_line);
		} else if (!is_japanese) {
			onNewLineWordWrapSpace(elm.__patch_conductor_line);
		}
	}

@if(GAME_WOHN)
	var char2glyph_cache = %[];
@endif

@if(USE_GET_INDIVIDUAL_CHARS)
	var individual_chars_cache = %[];
@endif

	function gtw_func(font, str, use_char2graph=false)
	{
		var res = 0;
@if(GAME_WOHN)
		if (use_char2graph)
		{
			var cache = this.char2glyph_cache["|" + font.height];
			if (cache !== void)
			{
				var maps = cache[0];
				var regexps = cache[1];
				for (var i = 0, internal_forloop_count = regexps.count; i < internal_forloop_count; i += 1)
				{
					var oldstr = str;
					str = regexps[i].replace(str, "");
					var count_diff = oldstr.length - str.length;
					if (count_diff > 0)
					{
						res += maps[regexps[i]]["" + count_diff];
					}
				}
			}
		}
@endif
@if(USE_GET_INDIVIDUAL_CHARS)
		var individual_chars_cache = this.individual_chars_cache;
		var font_values = [font.face, font.angle, font.bold, font.italic, font.height].join("|");
		for (var i = 0; i < str.length; i += 1)
		{
			var str_char = str[i];
			var str_key = str_char + "|" + font_values;
			var str_value = individual_chars_cache[str_key];
			if (str_value !== void)
			{
				res += str_value;
				continue;
			}
@if(USE_GET_GLYPH_DRAW_RECT)
			var rect = font.getGlyphDrawRect(str_char);
			if (typeof(rect) === "Object")
			{
				str_value = rect.right;
			}
			else
			{
				str_value = 0;
			}
@endif
@if(!USE_GET_GLYPH_DRAW_RECT)
			str_value = font.getTextWidth(str_char);
@endif
			res += str_value;
			individual_chars_cache[str_key] = str_value;
		}
@endif
@if(!USE_GET_INDIVIDUAL_CHARS)
@if(USE_GET_GLYPH_DRAW_RECT)
		var rect = font.getGlyphDrawRect(str);
		if (typeof(rect) === "Object")
		{
			res += rect.right;
		}
@endif
@if(!USE_GET_GLYPH_DRAW_RECT)
		res += font.getTextWidth(str);
@endif
@endif
		return res;
	}

@if(!WORDWRAP_BOLDITALIC_MODIFIER)
	var get_lengths_for_string_ret = [0, 0];
	function getLengthsForString(str, hlf, mlf)
	{
		var ret = get_lengths_for_string_ret;
		ret[0] = this.gtw_func(hlf, str);
		ret[1] = this.gtw_func(mlf, str, true);
		return ret;
	}
@endif

	var word_length_cache = %[];
	var word_length_test = [0, 0];
	var word_lines_space = [];
	var word_lines_chinese = [];
	var word_lines_needed = [];
	var nextWordTagName = "nextword";
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
	var empty_word = %[
		tagname: this.nextWordTagName,
		text: "",
		hllength: 0,
		mllength: 0
	];
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
	var empty_word = %[
		tagname: this.nextWordTagName,
		text: "",
		hllength: 0,
		mllength: 0,
		hllengthb: 0,
		mllengthb: 0,
		hllengthi: 0,
		mllengthi: 0,
		hllengthbi: 0,
		mllengthbi: 0
	];
@endif
	var empty_line = [];

	function onConductorScenarioPreLoad(joined_cleaned_lines, conductor)
	{
		if (typeof(global.kag) !== "Object")
		{
			// We haven't finished initialization yet
			return;
		}
		if (conductor === this.extraConductor)
		{
			// We don't do wordwrap on the extra conductor
			return;
		}
		if (conductor.callStackDepth === 0)
		{
			// We are still at the initialization stage
			return;
		}
		if (isJapanese())
		{
			// Don't bother doing the wordwrap calculations since we won't be using them
			return;
		}
		var empty_scr = joined_cleaned_lines.replace(/[\n \t\[\]\(\)""'']+/g, "");
		if (empty_scr.length === 0)
		{
			return;
		}
		var word_length_cache = this.word_length_cache;
		var word_lines_space = this.word_lines_space;
		var word_lines_chinese = this.word_lines_chinese;
		word_lines_space.clear();
		word_lines_chinese.clear();
		var empty_line = this.empty_line;
		var empty_word = this.empty_word;
		var cleaned_lines = conductor.cleaned_lines;
		var word_lines_needed = this.word_lines_needed;
		var getLengthsForString = this.getLengthsForString;
		var nextWordTagName = this.nextWordTagName;
@if(GAME_WOHN)
		if ((typeof(this.current) === "Object" && !isvalid(this.current)) || (typeof(this.current) !== "Object") || (this.fore.messages.count === 0))
		{
			this.allocateMessageLayers(1);
			global.reload_messagelayer_config(this);
		}
		var mlf = this.get_mlf();
		var mlf_size = mlf.height;
		var char2glyph_cache = this.char2glyph_cache;
		var test_char2glyph = "|" + mlf_size;
		var total = 30;
		if (char2glyph_cache[test_char2glyph] === void)
		{
			var tmp_cache = %[];
			
			var tmp_char2glyph_arr = [];
			tmp_char2glyph_arr.assign(this.current.char2graph);
			var tmp_char2glyph_mapped = [];
			var tmp_char2glyph_map = %[];
			var tmp_layer_for_char2glyph = new Layer(this, this.primaryLayer);
			for (var i = 0, internal_forloop_count = tmp_char2glyph_arr.count; i < internal_forloop_count; i += 2)
			{
				var regexp_obj = new RegExp(tmp_char2glyph_arr[i]);
				tmp_char2glyph_mapped.add(regexp_obj);
				var map_tmp = %[];
				for (var j = 0; j <= 30; j += 1)
				{
					var image_dir = tmp_char2glyph_arr[i + 1].sprintf(mlf_size, j);
					if (Storages.isExistentImage(image_dir))
					{
						tmp_layer_for_char2glyph.loadImages(image_dir);
						map_tmp["" + j] = tmp_layer_for_char2glyph.imageWidth;
					}
				}
				tmp_char2glyph_map[regexp_obj] = map_tmp;
			}
			invalidate tmp_layer_for_char2glyph;
			char2glyph_cache[test_char2glyph] = [tmp_char2glyph_map, tmp_char2glyph_mapped];
		}
@endif
		for (var i = 0, internal_forloop_count = cleaned_lines.count; i < internal_forloop_count; i += 1)
		{
			if (cleaned_lines[i].length === 0)
			{
				word_lines_space[i] = empty_line;
				continue;
			}
			var arr = [];
			var additionalWords = cleaned_lines[i].split(" ");
			for (var j = 0, internal_forloop_count = additionalWords.count; j < internal_forloop_count; j += 1)
			{
				var word = additionalWords[j];
				if (word.length === 0)
				{
					arr[j] = empty_word;
					continue;
				}
				if (word_length_cache[word] === void)
				{
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
					word_length_cache[word] = %[
						tagname: nextWordTagName,
						text: word
					];
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
					word_length_cache[word] = %[
						tagname: nextWordTagName,
						text: word,
					];
@endif
					word_lines_needed.add(word_length_cache[word]);
				}
				arr[j] = word_length_cache[word];
			}
			word_lines_space[i] = arr;
		}
		{
			var word = " ";
			if (word_length_cache[word] === void)
			{
				word_length_cache[word] = %[
					tagname: nextWordTagName,
					text: word,
				];
				word_lines_needed.add(word_length_cache[word]);
			}
		}
		if (isChinese())
		{
			for (var i = 0, internal_forloop_count = cleaned_lines.count; i < internal_forloop_count; i += 1)
			{
				if (cleaned_lines[i].length === 0)
				{
					word_lines_chinese[i] = empty_line;
					continue;
				}
				var arr = [];
				//	Use continuous English characters as separators to split the line into an array of substrings. / 中英文分词
				var additionalWords = cleaned_lines[i].split(/([A-zＡ-ｚ-]+)/);
				for (var j = 0, internal_forloop_count = additionalWords.count; j < internal_forloop_count; j += 1)
				{
					var word = additionalWords[j];
					if (word.length === 0)
					{
						arr[j] = empty_word;
						continue;
					}
					if (word_length_cache[word] === void)
					{
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
						var lengths = getLengthsForString(word, hlf, mlf);
						word_length_cache[word] = %[
							tagname: nextWordTagName,
							text: word
						];
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
						word_length_cache[word] = %[
							tagname: nextWordTagName,
							text: word,
						];
@endif
						word_lines_needed.add(word_length_cache[word]);
					}
					arr[j] = word_length_cache[word];
				}
				word_lines_chinese[i] = arr;
			}
		}
	}

	function get_hlf()
	{
		if (typeof(this.historyLayer) === "Object")
		{
			return this.historyLayer.font;
		}
		return void;
	}

	function get_mlf()
	{
		var ml_charlayer = void;
		var invalidate_wordcache = false;
		if (typeof(this.current.getCharLayer) === "Object")
		{
			var ml = this.current;
			ml_charlayer = ml.tmpCharLayer;
			ml_charlayer.setFont(ml.fontFace, ml.fontAngle, ml.bold, ml.fontItalic, ml.fontSize);
		}
		var mlf = void;
		if (typeof(this.current.lineLayer) === "Object")
		{
			mlf = this.current.lineLayer.font;
		}
		else if (ml_charlayer !== void)
		{
			if (!ml_charlayer.hasImage)
			{
				ml_charlayer.hasImage = true;
			}
			mlf = ml_charlayer.font;
		}
		return mlf;
	}

	function check_word_length_cache(hlf=this.get_hlf(), mlf=this.get_mlf(), process=false)
	{
		var invalidate_wordcache = false;
		if (hlf === void || mlf === void)
		{
			return invalidate_wordcache;
		}
		var word_length_test_str = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
@if(WORDWRAP_BOLDITALIC_MODIFIER)
		var gtw_func = this.gtw_func;
		var save_bold_hlf = hlf.bold;
		var save_italic_hlf = hlf.italic;
		var save_bold_mlf = mlf.bold;
		var save_italic_mlf = mlf.italic;
		hlf.bold = false;
		hlf.italic = false;
		mlf.bold = false;
		mlf.italic = false;
		var word_length_test_hl = gtw_func(hlf, word_length_test_str);
		var word_length_test_ml = gtw_func(mlf, word_length_test_str, true);
		if (word_length_test_hl !== word_length_test[0] || word_length_test_ml !== word_length_test[1])
		{
			invalidate_wordcache = true;
			if (process)
			{
				word_length_test[0] = word_length_test_hl;
				word_length_test[1] = word_length_test_ml;
			}
		}
		hlf.bold = save_bold_hlf;
		hlf.italic = save_italic_hlf;
		mlf.bold = save_bold_mlf;
		mlf.italic = save_italic_mlf;
@endif
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
		var word_length_test_cur = this.getLengthsForString(word_length_test_str, hlf, mlf);
		if (word_length_test_cur[0] !== word_length_test[0] || word_length_test_cur[1] !== word_length_test[1])
		{
			invalidate_wordcache = true;
			if (process)
			{
				word_length_test.assign(word_length_test_cur);
			}
		}
@endif
		return invalidate_wordcache;
	}

	function generate_word_wrapping_list(conductor, should_invalidate=true)
	{
@if(DO_WORDWRAP_BENCHMARK)
		var start = System.getTickCount();
@endif
		var hlf = this.get_hlf();
		var mlf = this.get_mlf();
		var invalidate_wordcache = should_invalidate ? this.check_word_length_cache(hlf, mlf, true) : false;

		if (invalidate_wordcache)
		{
			var word_length_cache_arr = [];
			word_length_cache_arr.assign(this.word_length_cache);
			for (var i = 0, internal_forloop_count = word_length_cache_arr.count; i < internal_forloop_count; i += 2)
			{
				var word_tag = word_length_cache_arr[i + 1];
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
				var lengths = this.getLengthsForString(word_tag.text, hlf, mlf);
				word_tag.hllength = lengths[0];
				word_tag.mllength = lengths[1];
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
				needed_lengths[word_tag.text] = word_tag;
@endif
			}
		}

@if(WORDWRAP_BOLDITALIC_MODIFIER)
		var needed_lengths = %[];
@endif
		var word_lines_needed = this.word_lines_needed;
		for (var i = 0, internal_forloop_count = word_lines_needed.count; i < internal_forloop_count; i += 1)
		{
			var word_tag = word_lines_needed[i];
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
			var lengths = this.getLengthsForString(word_tag.text, hlf, mlf);
			word_tag.hllength = lengths[0];
			word_tag.mllength = lengths[1];
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
			needed_lengths[word_tag.text] = word_tag;
@endif
		}
@if(WORDWRAP_BOLDITALIC_MODIFIER)
		var needed_lengths_arr = [];
		needed_lengths_arr.assign(needed_lengths);
		for (var i = 0, internal_forloop_count = needed_lengths_arr.count; i < internal_forloop_count; i += 2)
		{
			var word = needed_lengths_arr[i];
			var dic = needed_lengths_arr[i + 1];
			hlf.bold = false;
			hlf.italic = false;
			mlf.bold = false;
			mlf.italic = false;
			dic.hllength = gtw_func(hlf, word);
			dic.mllength = gtw_func(mlf, word, true);
			hlf.bold = true;
			mlf.bold = true;
			dic.hllengthb = gtw_func(hlf, word);
			dic.mllengthb = gtw_func(mlf, word, true);
			hlf.italic = true;
			mlf.italic = true;
			dic.hllengthbi = gtw_func(hlf, word);
			dic.mllengthbi = gtw_func(mlf, word, true);
			hlf.bold = false;
			mlf.bold = false;
			dic.hllengthi = gtw_func(hlf, word);
			dic.mllengthi = gtw_func(mlf, word, true);
		}
		hlf.bold = save_bold_hlf;
		hlf.italic = save_italic_hlf;
		mlf.bold = save_bold_mlf;
		mlf.italic = save_italic_mlf;
@endif

@if(CACHE_CHAR_LAYERS_FROM_TEXT)
		if (invalidate_wordcache)
		{
			global.reload_messagelayer_config(this);
			this.setMessageLayerUserFont();
		}
@if(CACHE_CHAR_LAYERS_FROM_TEXT_FIRSTLOAD_ONLY)
		if (invalidate_wordcache)
@endif
		{
			if (typeof(this.current.cacheCharLayerFromText) === "Object")
			{
				var cclft = this.current.cacheCharLayerFromText;
				for (var i = 0, internal_forloop_count = word_lines_needed.count; i < internal_forloop_count; i += 1)
				{
					var word_tag = word_lines_needed[i];
					cclft(word_tag.text, false);
				}
				for (var i = 0, internal_forloop_count = word_lines_needed.count; i < internal_forloop_count; i += 1)
				{
					var word_tag = word_lines_needed[i];
					cclft(word_tag.text, true);
				}
			}
		}
@endif
		word_lines_needed.clear();
		// Garbage collection.
		if (should_invalidate)
		{
			global.System.doCompact(global.clIdle);
		}
@if(DO_WORDWRAP_BENCHMARK)
		var end = System.getTickCount();
		Debug.message("Wordwrap was calculated in " + (end - start) + "ms");
@endif
	}

	function onNewLineWordWrapSpace(linenum)
	{
		var words = this.words;

		var word_lines = this.word_lines_space;

		var word_line = word_lines[linenum];
		if (word_line === void)
		{
			return;
		}
		{
			words.assign(word_line);
		}
		/*if (additionalWords.count > 0) {
			dm("clean line: " + clean);
			dm("found " + additionalWords.count + " words.");

			for (var i = 0, internal_forloop_count = words.count; i < internal_forloop_count; i += 1) {
				dm("word: '"+words[i][0]+"'");
			}
		}*/
	}

	function onNewLineWordWrapChinese(linenum)
	{
		var words = this.words;
		var word_lines = this.word_lines_chinese;
		var word_line = word_lines[linenum];
		if (word_line === void)
		{
			return;
		}
		{
			words.assign(word_line);
		}

		currentWordIndex = 0;
		currentCharPos = -2;

		/*if (words.count > 0) {
			dm("clean line: " + clean);
			dm("found " + words.count + " words.");

			for (var i = 0, internal_forloop_count = words.count; i < internal_forloop_count; i += 1) {
				dm("word: ['"+words[i][0]+"', "+i%2+"]");
			}
		}*/
	}

	function processWordWrapping(elm)
	{
		if (isChinese()) {
			return processWordWrappingChinese(elm);
		} else if (!isJapanese()) {
			return processWordWrappingSpace(elm);
		}
		return false;
	}

	function processWordWrappingSpace(elm)
	{
		if (
			#(elm.text) === 32 // " "
			&& words.count > 1
			)
		{
			words.erase(0);
			var nextWord = words[0];

			conductor.pendings.insert(0, nextWord);
			//dm("word: ["+nextWord[0]+"]");
		}
		return false;
	}

	function getHandlers()
	{
		var handlers = super.getHandlers();
@if(!PROCESS_WORD_WRAPPING_IN_CHUNKS)
		handlers[nextWordTagName] = function(elm)
		{
			if (processNextWord(elm))
			{
				return showPageBreakAndClear();
			}
			return 0;
		} incontextof this;
		handlers.ch_patch_wordwrap_original = handlers.ch;
		handlers.ch = function(elm)
		{
			// 文字表示
			var acs = actualChSpeed;
			if(updateBeforeCh)
			{
				if(acs) { updateBeforeCh--; return -5; } else { updateBeforeCh--; }
			}

			if (conductor.isNewLine()) {
				onNewLine(elm);
			}
			else
			{
				if ((this.current.shouldReline(elm.text)) && #(elm.text) === 32 && !isJapanese())
				{
					return 0;
				}
			}
@if(0)
			replaceCharacters(elm);
@endif
			if(processWordWrapping(elm)) {
				return showPageBreakAndClear();
			}

			var text = elm.text;
			if(currentWithBack) current.comp.processCh(text);
			if(current.processCh(text))
			{
				return showPageBreakAndClear();
			}
			if(historyWriteEnabled) historyLayer.store(text);

@if(0)
			processQuotesIndent(elm);
@endif

			if(autoWCEnabled)
			{
				// 自動ウェイト
				var ind;
				if((ind = autoWCChars.indexOf(text)) != -1)
				{
					return (acs * autoWCWaits[ind]) | 0;
				}
			}
			return acs;
		} incontextof this;
@endif
@if(PROCESS_WORD_WRAPPING_IN_CHUNKS)
		handlers.ruby_patch_wordwrap_original = handlers.ruby;
		handlers.ruby = function(elm)
		{
			{
				var e = elm;
				if(e.char != void && string(+e.char) != e.char)
				{
					// We'll treat this ruby entry as one whole word.
					var ttext = e.char;
					var word_length_cache = this.word_length_cache;
					var word_lines_needed = this.word_lines_needed;
					var wcacheentry = word_length_cache[ttext];
					if (typeof(wcacheentry) !== "Object")
					{
						word_length_cache[ttext] = %[
							tagname: nextWordTagName,
							text: ttext,
						];
						word_lines_needed.add(word_length_cache[ttext]);
						this.generate_word_wrapping_list(this.conductor, false);
						wcacheentry = word_length_cache[ttext];
					}
					var ml_needsreline = this.current.needsReline(wcacheentry);
					var hl_needsreline = this.historyLayer.needsReline(wcacheentry);
					if (ml_needsreline && hl_needsreline)
					{
						this.tagHandlers.r(%[tagname : "r"]);
					}
					else if (hl_needsreline && !ml_needsreline)
					{
						this.tagHandlers.hr(%[tagname : "hr"]);
					}
					else if (ml_needsreline && !hl_needsreline)
					{
						var old_historyWriteEnabled = this.historyWriteEnabled;
						{
							if (old_historyWriteEnabled)
							{
								// disable history output
								this.tagHandlers.history(%[tagname : "history", output : "0"]);
							}
							{
								// reline (on message layer only)
								this.tagHandlers.r(%[tagname : "r"]);
							}
							if (old_historyWriteEnabled)
							{
								// re-enable history output
								this.tagHandlers.history(%[tagname : "history", output : "1"]);
							}
						}
					}
				}
			}
			return this.tagHandlers.ruby_patch_wordwrap_original(elm);
		} incontextof this;
@endif
		return handlers;
	}

	function processWordWrappingChinese(elm)
	{
		if(words.count > 1) {
	//			dm(@"words[${currentWordIndex}][0] = ${words[currentWordIndex][0]}");
			switch(currentCharPos)
			{	//	Lookup the position of the first occurrence of current character in the current word. / 在当前词组中查找该字符第一次出现的位置
				case -3: // 禁用
					return false;
				case -1:
					break;
				case -2:	//	This is a new word or need start from 0 position. / 新词组
					currentCharPos++;
				default:
					currentCharPos = words[currentWordIndex].text.indexOf(elm.text, currentCharPos+1);
					break;
			}
			if(currentCharPos == -1) {	//	To determine the current word needs to be processed. / 处理
				while(currentWordIndex++ <= words.count) {
					if(words[currentWordIndex] === void)
					{
						currentCharPos = -3;
						return false;
					}
					else if(words[currentWordIndex].text.indexOf(elm.text) != -1)
					{
						currentCharPos = -2;
						if(currentWordIndex%2)
						{
							var word = words[currentWordIndex];
							return processNextWord(word);
						}
						return false;
					}
				}
			}
			//	End of the word, the next word should be determined it needs to process. / 到该词组末尾，下一词组需要处理
			if(currentCharPos == words[currentWordIndex].text.length - 1) currentCharPos = -1;
		}
		return false;
	}

	function processNextWord(elm)
	{
		historyLayer.nextWord(elm);
		if(currentWithBack) current.comp.nextWord(elm);
		return current.nextWord(elm);
	}

	function getWordWrapBreakPosition(text)
	{
		if (isChinese()) {
			return getWordWrapBreakPositionChinese(text);
		} else if (!isJapanese()) {
			return getWordWrapBreakPositionSpace(text);
		}
		return -1;
	}

	function getWordWrapBreakPositionSpace(text)
	{
		var space_index = text.indexOf(" ");
		// To avoid infinite recursion, break after space position
		if (space_index == 0)
		{
			return 1;
		}
		return space_index;
	}

	function getWordWrapBreakPositionChinese(text)
	{
		//	Use continuous English characters as separators to split the line into an array of substrings. / 中英文分词
		var additionalWords = text.split(/([A-zＡ-ｚ-]+)/);
		if (additionalWords.count > 0)
		{
			if (additionalWords[0].length > 0)
			{
				return additionalWords[0].length;
			}
		}
		return -1;
	}

@if(PROCESS_WORD_WRAPPING_IN_CHUNKS)
	function processWordWrappingChunkAtOnce(text, conductor, elm)
	{
		var word_wrap_break_position = this.getWordWrapBreakPosition(text);
		var ttext = text;
		var should_append_break_tags = true;
		if (elm.prepend.count > 0)
		{
			elm.requeue = false;
			conductor.requeueText(ttext, elm);
			conductor.queuePrependMessageLayerRelatedTags(elm);
			elm.prepend.clear();
			return "";
		}
		if (word_wrap_break_position > 0)
		{
			var cut_text = text.substr(word_wrap_break_position);
			if (cut_text.length > 0)
			{
				conductor.requeueText(cut_text, elm);
				should_append_break_tags = false;
			}
			ttext = text.substr(0, word_wrap_break_position);
		}
@if(0)
		var wcacheentry = word_length_cache[ttext];
		var ll_len = this.current.lineLayer.font.getTextWidth(ttext);
		if (typeof(wcacheentry) === "Object" && (wcacheentry.mllength !== ll_len))
		{
			Debug.message("ww x " + wcacheentry.mllength + " " + ll_len);
		}
@endif	
		var word_length_cache = this.word_length_cache;
		var word_lines_needed = this.word_lines_needed;
		var wcacheentry = word_length_cache[ttext];
		if (typeof(wcacheentry) !== "Object")
		{
			word_length_cache[ttext] = %[
				tagname: nextWordTagName,
				text: ttext,
			];
			word_lines_needed.add(word_length_cache[ttext]);
			this.generate_word_wrapping_list(conductor, false);
			wcacheentry = word_length_cache[ttext];
		}
		var ml_needsreline = this.current.needsReline(wcacheentry);
		var hl_needsreline = this.historyLayer.needsReline(wcacheentry);
		if (ml_needsreline && hl_needsreline)
		{
			ttext = "\n" + ttext;
		}
		else if (hl_needsreline && !ml_needsreline)
		{
			elm.requeue = false;
			if (should_append_break_tags)
			{
				conductor.queueAppendMessageLayerRelatedTags(elm);
			}
			conductor.queueText(ttext, elm);
			conductor.queueReline(elm, false, true);
			return "";
		}
		else if (ml_needsreline && !hl_needsreline)
		{
			elm.requeue = false;
			if (should_append_break_tags)
			{
				conductor.queueAppendMessageLayerRelatedTags(elm);
			}
			conductor.queueText(ttext, elm);
			conductor.queueReline(elm, true, false);
			return "";
		}

		if (!should_append_break_tags)
		{
			elm.requeue = false;
			conductor.queueText(ttext, elm);
			return "";
		}

		return ttext;
	}
@endif

@if(0)
	var quotesIndentedLeft = 1;
	var afterQuotesIndentedRight = 2;
	var quotesMethod = 0;
	var inQuotes = 0;
	var openingQuote = "“";
	var endingQuote = "”";
	var lineStartsWithOpeningQuoteRegex = new RegExp(" {2}"+openingQuote);
	var lineInSpeechRegex = new RegExp("^ {3}");

	function processQuotesIndent(elm)
	{
		{
			var text = elm.text;
			if (text == openingQuote) {
				inQuotes++;
				onOpeningQuote();
			} else if (text == endingQuote) {
				inQuotes--;
				onEndingQuote();
			}
		}
	}

	var quoteIndentation = false;
	function processQuotedLine()
	{
		if ([quotesIndentedLeft, afterQuotesIndentedRight].find(quotesMethod) == -1) {
			return;
		}

		if (!quoteIndentation) {
			quoteIndentation = lineStartsWithOpeningQuoteRegex.test(conductor.curLineStr);
		}

		if (!quoteIndentation) return;

		if (quotesMethod == afterQuotesIndentedRight) {
			if (lineInSpeechRegex.test(conductor.curLineStr)) {
				for (var i = 0; i < 3; i += 1) {
					conductor.getNextTag();
				}
			}
		}
	}

	function onOpeningQuote()
	{
		if (quotesMethod == afterQuotesIndentedRight && quoteIndentation) {
			tagHandlers.indent();
		}
	}

	function onEndingQuote()
	{
		if (inQuotes == 0 && quoteIndentation) {
			quoteIndentation = false;
			if (quotesMethod == afterQuotesIndentedRight) {
				tagHandlers.endindent();
			}
		}
	}
@endif
}
global.KAGWindow = KAGWindow_patch_wordwrap_override;


// Splits text into an array of lines with wordwrapping on spaces.
// Offset is an amount to add to the first line if you want it to be shorter
// than the rest of the lines (negative number for longer).
// Preserves leading spaces. Breaks lines at end of word and discards the first space between words.
// Words longer than one line break at the first character that is over the limit.
// If maxlines is reached, the rest of the string is returned in the last line regardless of length.
// Note: Breaking on characters other than space (e.g. tab, hyphen) is not supported.
global.wordWrapSplit = function(text, maxWidth, font, offset=0, maxLines=0, directiveCharacters="", delimiter=" ", delimiterOnNewLine=false)
{
	var directiveCharactersRegex = directiveCharacters != ""? new RegExp("["+directiveCharacters+"]", "g") : void;

	var totalTextToTest = directiveCharactersRegex === void? text : text.replace(directiveCharactersRegex, "");
	var textwidth = font.getTextWidth(totalTextToTest);
	if (textwidth+offset < maxWidth || maxLines == 1) {
		return [text];
	}

	var out = [];
	var words = [].split(delimiter, text);

	var tmp = "";
	for (var i = 0, internal_forloop_count = words.count; i < internal_forloop_count; i += 1)
	{
		var space = i != 0 ? delimiter : "";
		var word = space + words[i];
		var textToTest = directiveCharactersRegex === void? (tmp+word) : (tmp+word).replace(directiveCharactersRegex, "");
		if (font.getTextWidth(textToTest)+offset < maxWidth) {
			tmp += word;
		} else {
			if (tmp != "") {
				out.add(tmp);
			}

			if (out.count == maxLines && maxLines > 0) {
				for (var j = i, internal_forloop_count = words.count; j < internal_forloop_count; j += 1) {
					out[out.count-1] += space + words[j];
				}
				return out;
			} else {
				offset = 0;
				tmp = delimiterOnNewLine? delimiter + words[i] : words[i];
			}
		}
	}
	if (tmp != "") out.add(tmp);
	return out;
};


global.wordWrapSplitLines = function(lines, maxWidth, font, offset=0, maxLines=0)
{
	if (typeof lines == "String") {
		lines = lines.split("\n");
	}
	var out = [];
	for (var i = 0, internal_forloop_count = lines.count; i < internal_forloop_count; i += 1) {
		var sublines = wordWrapSplit(lines[i], maxWidth, font, offset, maxLines);
		for (var j = 0, internal_forloop_count = sublines.count; j < internal_forloop_count; j += 1) {
			out.add(sublines[j]);
		}
	}
	if (sf.language == japaneseLanguage) {
		var out2 = [];
		for (var i = 0, internal_forloop_count = out.count; i < internal_forloop_count; i += 1) {
			var sublines = wordWrapSplit(out[i], maxWidth, font, offset, maxLines,, "・", true);
			for (var j = 0, internal_forloop_count = sublines.count; j < internal_forloop_count; j += 1) {
				out2.add(sublines[j]);
			}
		}
		return out2;
	}
	return out;
};

global.wordWrapSplitParagraphs = function(paragraphs, maxWidth, font, offset=0, maxLines=0)
{
	if (typeof paragraphs == "String") {
		paragraphs = paragraphs.replace(/\n\n/g, "\v");
		paragraphs = paragraphs.split("\v");
	}
	for (var p = 0, internal_forloop_count = paragraphs.count; p < internal_forloop_count; p += 1) {
		paragraphs[p] = wordWrapSplitLines(paragraphs[p], maxWidth, font, offset, maxLines);
	}
	return paragraphs;
};

@endif
