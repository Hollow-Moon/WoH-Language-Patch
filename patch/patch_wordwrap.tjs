@if(__WORDWRAP_DEFINED__==0)
@set(__WORDWRAP_DEFINED__=1)

global.HistoryLayer_patch_wordwrap_original = HistoryLayer;
class HistoryLayer_patch_wordwrap_override extends HistoryLayer_patch_wordwrap_original
{
	function HistoryLayer_patch_wordwrap_override()
	{
		super.HistoryLayer(...);
	}

	function HistoryLayer()
	{
		HistoryLayer_patch_wordwrap_override(...);
	}

	function nextWord(elm)
	{
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
		var currentWordWidth = elm.hllength;
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
		var currentWordWidth = 0;
		var bold = this.font.bold;
		var italic = this.font.italic;
		if (bold && italic)
		{
			currentWordWidth = elm.hllengthbi;
		}
		else if (bold)
		{
			currentWordWidth = elm.hllengthb;
		}
		else if (italic)
		{
			currentWordWidth = elm.hllengthi;
		}
		else
		{
			currentWordWidth = elm.hllength;
		}
@endif
		if ((getCurrentLineWidth() + currentWordWidth) >= relinePos && currentWordWidth < relinePos)
		{
			if (reline())
			{
				return autoReturn;
			}
		}
		return false;
	}
}
global.HistoryLayer = HistoryLayer_patch_wordwrap_override;

global.MessageLayer_patch_wordwrap_original = MessageLayer;
class MessageLayer_patch_wordwrap_override extends MessageLayer_patch_wordwrap_original
{
	function MessageLayer_patch_wordwrap_override()
	{
		super.MessageLayer(...);
	}

	function MessageLayer()
	{
		MessageLayer_patch_wordwrap_override(...);
	}

	function nextWord(elm)
	{
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
		var currentWordWidth = elm.mllength;
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
		var currentWordWidth = 0, bold = false, italic = false;
		if (typeof(this.lineLayer) === "Object")
		{
			bold = this.lineLayer.font.bold;
			italic = this.lineLayer.font.italic;
		}
		else if (typeof(this.getChWidth) === "Object")
		{
			bold = this.bold;
			italic = this.fontItalic;
		}
		if (bold && italic)
		{
			currentWordWidth = elm.mllengthbi;
		}
		else if (bold)
		{
			currentWordWidth = elm.mllengthb;
		}
		else if (italic)
		{
			currentWordWidth = elm.mllengthi;
		}
		else
		{
			currentWordWidth = elm.mllength;
		}
@endif
		if ((x + currentWordWidth) >= relinexpos && currentWordWidth < relinexpos)
		{
			if (reline())
			{
				return autoReturn;
			}
		}
		return false;
	}
}
global.MessageLayer = MessageLayer_patch_wordwrap_override;

global.KAGWindow_patch_wordwrap_original = KAGWindow;
class KAGWindow_patch_wordwrap_override extends KAGWindow_patch_wordwrap_original
{
	function KAGWindow_patch_wordwrap_override()
	{
		super.KAGWindow(...);
	}

	function KAGWindow()
	{
		KAGWindow_patch_wordwrap_override(...);
	}

	var word_lines_scenario_changed = false;
	function onConductorScenarioLoad()
	{
		this.words.clear();
@if(0)
		this.inQuotes = 0;
@endif
		this.word_lines_scenario_changed = true;
		return super.onConductorScenarioLoad(...);
	}

	function onConductorScenarioLoaded()
	{
		if ((this.word_lines_scenario_changed) && (this.word_lines_space.count !== 0 || this.word_lines_chinese.count !== 0))
		{
			this.word_lines_scenario_changed = false;
			this.clearMessageLayers();
@if(GAME_WOHN)
			if ((typeof(this.current) === "Object" && !isvalid(this.current)) || (typeof(this.current) === "void"))
			{
				this.allocateMessageLayers(1);
				global.reload_messagelayer_config(this);
			}
@endif
			this.generate_word_wrapping_list(this.conductor);
		}
		return super.onConductorScenarioLoaded(...);
	}

	var words = [];

	//Chinese
	var currentWordIndex = 0;
	var currentCharPos = 0;

	var word_lines_current_storage = "";

	function onNewLine(elm)
	{
		var is_japanese = isJapanese();
		if (is_japanese)
		{
			// Don't bother doing the wordwrap calculations since we won't be using them
			return;
		}

@if(0)
		processQuotedLine();
@endif

		if (isChinese())
		{
			this.words.clear();
		}

		var clean = this.conductor.cleaned_lines[elm.__patch_conductor_line];

		if ((clean === void) || (clean !== void && clean.length === 0)) return;

		if (isChinese()) {
			onNewLineWordWrapChinese(elm.__patch_conductor_line);
		} else if (!is_japanese) {
			onNewLineWordWrapSpace(elm.__patch_conductor_line);
		}
	}

@if(!WORDWRAP_BOLDITALIC_MODIFIER)
	var get_lengths_for_string_ret = [0, 0];
	function getLengthsForString(str, hlf, mlf)
	{
		var ret = get_lengths_for_string_ret;
		ret[0] = hlf.getTextWidth(str);
		ret[1] = mlf.getTextWidth(str);
		return ret;
	}
@endif

	var word_length_cache = %[];
	var word_length_test = [0, 0];
	var word_lines_space = [];
	var word_lines_chinese = [];
	var word_lines_needed = [];
	var nextWordTagName = "nextword";
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
	var empty_word = %[
		tagname: this.nextWordTagName,
		text: "",
		hllength: 0,
		mllength: 0
	];
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
	var empty_word = %[
		tagname: this.nextWordTagName,
		text: "",
		hllength: 0,
		mllength: 0,
		hllengthb: 0,
		mllengthb: 0,
		hllengthi: 0,
		mllengthi: 0,
		hllengthbi: 0,
		mllengthbi: 0
	];
@endif
	var empty_line = [];

	function onConductorScenarioPreLoad(joined_cleaned_lines)
	{
		this.word_lines_space.clear();
		this.word_lines_chinese.clear();
		if (typeof(global.kag) !== "Object")
		{
			// We haven't finished initialization yet
			return;
		}
		if (isJapanese())
		{
			// Don't bother doing the wordwrap calculations since we won't be using them
			return;
		}
		var empty_scr = joined_cleaned_lines.replace(/[\n \t\[\]\(\)""'']+/g, "");
		if (empty_scr.length === 0)
		{
			return;
		}
		var empty_line = this.empty_line;
		var empty_word = this.empty_word;
		var cleaned_lines = this.conductor.cleaned_lines;
		var word_lines_needed = this.word_lines_needed;
		for (var i = 0; i < cleaned_lines.count; i += 1)
		{
			if (cleaned_lines[i].length === 0)
			{
				this.word_lines_space[i] = empty_line;
				continue;
			}
			var arr = [];
			var additionalWords = cleaned_lines[i].split(" ");
			for (var j = 0; j < additionalWords.count; j += 1)
			{
				var word = additionalWords[j];
				if (word.length === 0)
				{
					arr[j] = empty_word;
					continue;
				}
				if (this.word_length_cache[word] === void)
				{
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
					this.word_length_cache[word] = %[
						tagname: this.nextWordTagName,
						text: word
					];
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
					this.word_length_cache[word] = %[
						tagname: this.nextWordTagName,
						text: word,
					];
@endif
					word_lines_needed.add(this.word_length_cache[word]);
				}
				arr[j] = this.word_length_cache[word];
			}
			this.word_lines_space[i] = arr;
		}
		if (isChinese())
		{
			for (var i = 0; i < cleaned_lines.count; i += 1)
			{
				if (cleaned_lines[i].length === 0)
				{
					this.word_lines_chinese[i] = empty_line;
					continue;
				}
				var arr = [];
				//	Use continuous English characters as separators to split the line into an array of substrings. / 中英文分词
				var additionalWords = cleaned_lines[i].split(/([A-zＡ-ｚ-]+)/);
				for (var j = 0; j < additionalWords.count; j += 1)
				{
					var word = additionalWords[j];
					if (word.length === 0)
					{
						arr[j] = empty_word;
						continue;
					}
					if (this.word_length_cache[word] === void)
					{
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
						var lengths = this.getLengthsForString(word, hlf, mlf);
						this.word_length_cache[word] = %[
							tagname: this.nextWordTagName,
							text: word
						];
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
						this.word_length_cache[word] = %[
							tagname: this.nextWordTagName,
							text: word,
						];
@endif
						word_lines_needed.add(this.word_length_cache[word]);
					}
					arr[j] = this.word_length_cache[word];
				}
				this.word_lines_chinese[i] = arr;
			}
		}
	}

	function generate_word_wrapping_list(conductor)
	{
		var ml_charlayer = void;
		var invalidate_wordcache = false;
		if (typeof(this.current.getCharLayer) === "Object")
		{
			var ml = this.current;
			ml_charlayer = ml.tmpCharLayer;
			ml_charlayer.clear();
			ml_charlayer.setFont(ml.fontFace, ml.fontAngle, ml.bold, ml.fontItalic, ml.fontSize);
		}
		var hlf = this.historyLayer.font;
		var mlf = void;
		if (typeof(this.current.lineLayer) === "Object")
		{
			mlf = this.current.lineLayer.font;
		}
		else if (ml_charlayer !== void)
		{
			mlf = ml_charlayer.font;
		}
@if(WORDWRAP_BOLDITALIC_MODIFIER)
		var hlf_gtw = hlf.getTextWidth;
		var mlf_gtw = mlf.getTextWidth;
		var save_bold_hlf = hlf.bold;
		var save_italic_hlf = hlf.italic;
		var save_bold_mlf = mlf.bold;
		var save_italic_mlf = mlf.italic;
		hlf.bold = false;
		hlf.italic = false;
		mlf.bold = false;
		mlf.italic = false;
		var word_length_test_str = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
		var word_length_test_hl = hlf_gtw(word_length_test_str);
		var word_length_test_ml = mlf_gtw(word_length_test_str);
		if (word_length_test_hl !== word_length_test[0] || word_length_test_ml !== word_length_test[1])
		{
			invalidate_wordcache = true;
			var word_length_cache_arr = [];
			word_length_cache_arr.assign(this.word_length_cache);
			for (var i = 0; i < word_length_cache_arr.count; i += 2)
			{
				var word_tag = word_length_cache_arr[i + 1];
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
				var lengths = this.getLengthsForString(word_tag.text, hlf, mlf);
				word_tag.hllength = lengths[0];
				word_tag.mllength = lengths[1];
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
				needed_lengths[word_tag.text] = word_tag;
@endif
			}
			word_length_test[0] = word_length_test_hl;
			word_length_test[1] = word_length_test_ml;
		}
@endif
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
		var word_length_test_cur = this.getLengthsForString("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", hlf, mlf);
		if (word_length_test_cur[0] !== word_length_test[0] || word_length_test_cur[1] !== word_length_test[1])
		{
			invalidate_wordcache = true;
			var word_length_cache_arr = [];
			word_length_cache_arr.assign(this.word_length_cache);
			for (var i = 0; i < word_length_cache_arr.count; i += 2)
			{
				var word_tag = word_length_cache_arr[i + 1];
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
				var lengths = this.getLengthsForString(word_tag.text, hlf, mlf);
				word_tag.hllength = lengths[0];
				word_tag.mllength = lengths[1];
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
				needed_lengths[word_tag.text] = word_tag;
@endif
			}
			word_length_test.assign(word_length_test_cur);
		}
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
		var needed_lengths = %[];
@endif
		var word_lines_needed = this.word_lines_needed;
		for (var i = 0; i < word_lines_needed.count; i += 1)
		{
			var word_tag = word_lines_needed[i];
@if(!WORDWRAP_BOLDITALIC_MODIFIER)
			var lengths = this.getLengthsForString(word_tag.text, hlf, mlf);
			word_tag.hllength = lengths[0];
			word_tag.mllength = lengths[1];
@endif
@if(WORDWRAP_BOLDITALIC_MODIFIER)
			needed_lengths[word_tag.text] = word_tag;
@endif
		}
@if(WORDWRAP_BOLDITALIC_MODIFIER)
		var needed_lengths_arr = [];
		needed_lengths_arr.assign(needed_lengths);
		for (var i = 0; i < needed_lengths_arr.count; i += 2)
		{
			var word = needed_lengths_arr[i];
			var dic = needed_lengths_arr[i + 1];
			hlf.bold = false;
			hlf.italic = false;
			mlf.bold = false;
			mlf.italic = false;
			dic.hllength = hlf_gtw(word);
			dic.mllength = mlf_gtw(word);
			hlf.bold = true;
			mlf.bold = true;
			dic.hllengthb = hlf_gtw(word);
			dic.mllengthb = mlf_gtw(word);
			hlf.italic = true;
			mlf.italic = true;
			dic.hllengthbi = hlf_gtw(word);
			dic.mllengthbi = mlf_gtw(word);
			hlf.bold = false;
			mlf.bold = false;
			dic.hllengthi = hlf_gtw(word);
			dic.mllengthi = mlf_gtw(word);
		}
		hlf.bold = save_bold_hlf;
		hlf.italic = save_italic_hlf;
		mlf.bold = save_bold_mlf;
		mlf.italic = save_italic_mlf;
@endif
		if (ml_charlayer !== void)
		{
			ml_charlayer.clear();
		}

@if(CACHE_CHAR_LAYERS_FROM_TEXT)
		if (invalidate_wordcache)
		{
			global.reload_messagelayer_config(this);
			this.setMessageLayerUserFont();
		}
@if(CACHE_CHAR_LAYERS_FROM_TEXT_FIRSTLOAD_ONLY)
		if (invalidate_wordcache)
@endif
		{
			if (typeof(this.current.cacheCharLayerFromText) === "Object")
			{
				var cclft = this.current.cacheCharLayerFromText;
				for (var i = 0; i < word_lines_needed.count; i += 1)
				{
					var word_tag = word_lines_needed[i];
					cclft(word_tag.text, 1);
				}
			}
		}
@endif
		word_lines_needed.clear();
		// Garbage collection.
		global.System.doCompact(global.clIdle);
	}

	function onNewLineWordWrapSpace(linenum)
	{
		var words = this.words;
		if (words.count > 0)
		{
			words.erase(0);
		}

		var word_lines = this.word_lines_space;

		var word_line = word_lines[linenum];
		if (word_line === void)
		{
			return;
		}
		if (words.count === 0)
		{
			words.assign(word_line);
		}
		else
		{
			if (typeof(words.push) === "Object")
			{
				words.push(word_line*);
			}
			else
			{
				var arr = word_line;
				for (var i = 0; i < arr.count; i += 1)
				{
					words.add(arr[i]);
				}
			}
		}
		/*if (additionalWords.count > 0) {
			dm("clean line: " + clean);
			dm("found " + additionalWords.count + " words.");

			for(var i=0; i<words.count; i++) {
				dm("word: '"+words[i][0]+"'");
			}
		}*/
	}

	function onNewLineWordWrapChinese(linenum)
	{
		var words = this.words;
		var word_lines = this.word_lines_chinese;
		var word_line = word_lines[linenum];
		if (word_line === void)
		{
			return;
		}
		if (words.count === 0)
		{
			words.assign(word_line);
		}
		else
		{
			if (typeof(words.push) === "Object")
			{
				words.push(word_line*);
			}
			else
			{
				var arr = word_line;
				for (var i = 0; i < arr.count; i += 1)
				{
					words.add(arr[i]);
				}
			}
		}

		currentWordIndex = 0;
		currentCharPos = -2;

		/*if (words.count > 0) {
			dm("clean line: " + clean);
			dm("found " + words.count + " words.");

			for(var i=0; i<words.count; i++) {
				dm("word: ['"+words[i][0]+"', "+i%2+"]");
			}
		}*/
	}

	function processWordWrapping(elm)
	{
		if (isChinese()) {
			return processWordWrappingChinese(elm);
		} else if (!isJapanese()) {
			return processWordWrappingSpace(elm);
		}
		return false;
	}

	function processWordWrappingSpace(elm)
	{
		if (
			#(elm.text) === 32 // " "
			&& words.count > 1
			)
		{
			words.erase(0);
			var nextWord = words[0];

			conductor.pendings.insert(0, nextWord);
			//dm("word: ["+nextWord[0]+"]");
		}
		return false;
	}

	function getHandlers()
	{
		var handlers = super.getHandlers();
		handlers[nextWordTagName] = function(elm)
		{
			if (processNextWord(elm))
			{
				return showPageBreakAndClear();
			}
			return 0;
		} incontextof this;
		handlers.ch_patch_wordwrap_original = handlers.ch;
		handlers.ch = function(elm)
		{
			// 文字表示
			var acs = actualChSpeed;
			if(updateBeforeCh)
			{
				if(acs) { updateBeforeCh--; return -5; } else { updateBeforeCh--; }
			}

			if (conductor.isNewLine()) {
				onNewLine(elm);
			}
			replaceCharacters(elm);
			if(processWordWrapping(elm)) {
				return showPageBreakAndClear();
			}

			var text = elm.text;
			if(currentWithBack) current.comp.processCh(text);
			if(current.processCh(text))
			{
				return showPageBreakAndClear();
			}
			if(historyWriteEnabled) historyLayer.store(text);

@if(0)
			processQuotesIndent(elm);
@endif

			if(autoWCEnabled)
			{
				// 自動ウェイト
				var ind;
				if((ind = autoWCChars.indexOf(text)) != -1)
				{
					return (acs * autoWCWaits[ind]) | 0;
				}
			}
			return acs;
		} incontextof this;
		return handlers;
	}

	function processWordWrappingChinese(elm)
	{
		if(words.count > 1) {
	//			dm(@"words[${currentWordIndex}][0] = ${words[currentWordIndex][0]}");
			switch(currentCharPos)
			{	//	Lookup the position of the first occurrence of current character in the current word. / 在当前词组中查找该字符第一次出现的位置
				case -3: // 禁用
					return false;
				case -1:
					break;
				case -2:	//	This is a new word or need start from 0 position. / 新词组
					currentCharPos++;
				default:
					currentCharPos = words[currentWordIndex].text.indexOf(elm.text, currentCharPos+1);
					break;
			}
			if(currentCharPos == -1) {	//	To determine the current word needs to be processed. / 处理
				while(currentWordIndex++ <= words.count) {
					if(words[currentWordIndex] === void)
					{
						currentCharPos = -3;
						return false;
					}
					else if(words[currentWordIndex].text.indexOf(elm.text) != -1)
					{
						currentCharPos = -2;
						if(currentWordIndex%2)
						{
							var word = words[currentWordIndex];
							return processNextWord(word);
						}
						return false;
					}
				}
			}
			//	End of the word, the next word should be determined it needs to process. / 到该词组末尾，下一词组需要处理
			if(currentCharPos == words[currentWordIndex].text.length - 1) currentCharPos = -1;
		}
		return false;
	}

	function processNextWord(elm)
	{
		historyLayer.nextWord(elm);
		if(currentWithBack) current.comp.nextWord(elm);
		return current.nextWord(elm);
	}

@if(0)
	var quotesIndentedLeft = 1;
	var afterQuotesIndentedRight = 2;
	var quotesMethod = 0;
	var inQuotes = 0;
	var openingQuote = "“";
	var endingQuote = "”";
	var lineStartsWithOpeningQuoteRegex = new RegExp(" {2}"+openingQuote);
	var lineInSpeechRegex = new RegExp("^ {3}");

	function processQuotesIndent(obj)
	{
		with (obj) {
			if (.text == openingQuote) {
				inQuotes++;
				onOpeningQuote();
			} else if (.text == endingQuote) {
				inQuotes--;
				onEndingQuote();
			}
		}
	}

	var quoteIndentation = false;
	function processQuotedLine()
	{
		if ([quotesIndentedLeft, afterQuotesIndentedRight].find(quotesMethod) == -1) {
			return;
		}

		if (!quoteIndentation) {
			quoteIndentation = lineStartsWithOpeningQuoteRegex.test(conductor.curLineStr);
		}

		if (!quoteIndentation) return;

		if (quotesMethod == afterQuotesIndentedRight) {
			if (lineInSpeechRegex.test(conductor.curLineStr)) {
				for (var i = 0; i < 3; i++) {
					conductor.getNextTag();
				}
			}
		}
	}

	function onOpeningQuote()
	{
		if (quotesMethod == afterQuotesIndentedRight && quoteIndentation) {
			tagHandlers.indent();
		}
	}

	function onEndingQuote()
	{
		if (inQuotes == 0 && quoteIndentation) {
			quoteIndentation = false;
			if (quotesMethod == afterQuotesIndentedRight) {
				tagHandlers.endindent();
			}
		}
	}
@endif
}
global.KAGWindow = KAGWindow_patch_wordwrap_override;


// Splits text into an array of lines with wordwrapping on spaces.
// Offset is an amount to add to the first line if you want it to be shorter
// than the rest of the lines (negative number for longer).
// Preserves leading spaces. Breaks lines at end of word and discards the first space between words.
// Words longer than one line break at the first character that is over the limit.
// If maxlines is reached, the rest of the string is returned in the last line regardless of length.
// Note: Breaking on characters other than space (e.g. tab, hyphen) is not supported.
function wordWrapSplit(text, maxWidth, font, offset=0, maxLines=0, directiveCharacters="")
{
	var directiveCharactersRegex = directiveCharacters != ""? new RegExp("["+directiveCharacters+"]", "g") : void;

	var totalTextToTest = directiveCharactersRegex === void? text : text.replace(directiveCharactersRegex, "");
	var textwidth = font.getTextWidth(totalTextToTest);
	if (textwidth+offset < maxWidth || maxLines == 1) {
		return [text];
	}

	var out = [];
	var words = [].split(" ", text);

	var tmp = "";
	for (var i = 0; i < words.count; i++)
	{
		var space = i != 0 ? " " : "";
		var word = space + words[i];
		var textToTest = directiveCharactersRegex === void? (tmp+word) : (tmp+word).replace(directiveCharactersRegex, "");
		if (font.getTextWidth(textToTest)+offset < maxWidth) {
			tmp += word;
		} else {
			out.add(tmp);

			if (out.count == maxLines) {
				for (var j = i; j < words.count; j++) {
					out[out.count-1] += space + words[j];
				}
				return out;
			} else {
				offset = 0;
				tmp = words[i]; //No need to add space here.
			}
		}
	}
	if (tmp != "") out.add(tmp);
	return out;
}


function wordWrapSplitLines(lines, maxWidth, font, offset=0, maxLines=0)
{
	if (typeof lines == "String") {
		lines = lines.split("\n");
	}
	var out = [];
	for (var i=0; i<lines.count; i++) {
		var sublines = wordWrapSplit(lines[i], maxWidth, font, offset, maxLines);
		for (var j=0; j<sublines.count; j++) {
			out.add(sublines[j]);
		}
	}
	return out;
}

function wordWrapSplitParagraphs(paragraphs, maxWidth, font, offset=0, maxLines=0) {
	if (typeof paragraphs == "String") {
		paragraphs = paragraphs.replace(/\n\n/g, "\v");
		paragraphs = paragraphs.split("\v");
	}
	for (var p = 0; p < paragraphs.count; p++) {
		paragraphs[p] = wordWrapSplitLines(paragraphs[p], maxWidth, font, offset, maxLines);
	}
	return paragraphs;
}

@endif
