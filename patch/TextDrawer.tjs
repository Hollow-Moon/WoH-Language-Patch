@if(__TEXTDRAWER_DEFINED__==0)
@set(__TEXTDRAWER_DEFINED__=1)

class EntriesSettings
{
	var useDictionary = true;
	var dictionary;
	var cleanBgImage = void;
	var emptyLayerImage = false;
	var imageWidth;
	var imageHeight;
	var rubyTitle = new TextualSettings();
	var title = new TextualSettings();
	var text = new TextualSettings();
	var distanceBetweenEntries;
	var layerLeft;
	var layerTop;
	var layerWidth;
	var layerHeight;
	var hint;
	var updateSize = true;

	function EntriesSettings()
	{
		rubyTitle.exists = false;
	}
}

class TextualSettings
{
	var content;
	var alignment = "center";
	var verticalAlignment = "center";
	var exists = true;
	var leftOffset=0;
	var rightOffset=0;
	var topOffset=0;
	var bottomOffset=0;
	var fontHeight=14;
	var fontFace;
	var fontContext;
	var fontBold = false;
	var fontItalic = false;
	var lineSpace=0;
	var paragraphSpace=0;
	var maxHeight;
	var color;
	var opacity=255;
	var shadowColor = 0x000000;
	var shadowOpacity = 0;
	var shadowWidth = 0;
	var shadowOffsetX = 0;
	var shadowOffsetY = 0;
	var glow = false;
	var glowColor;
	var glowOpacity;
	var glowStrength;
	var glowSize = 1;

	property horizontalOffset {
		getter {
			return leftOffset + rightOffset;
		}
		setter(offset) {
			leftOffset = offset/2;
			rightOffset = offset/2;
		}
	}

	property verticalOffset {
		getter {
			return topOffset + bottomOffset;
		}
		setter(offset) {
			topOffset = offset/2;
			bottomOffset = offset/2;
		}
	}
}

global.loadDictionaryIfExists = function(dictionaryName)
{
	if (Storages.isExistentStorage(dictionaryName)) {
		return Scripts.evalStorage(dictionaryName);
	}
	return void;
};

global.textDrawerSettingsFileName = "TextDrawerSettings.tjs";
Scripts.execStorage(textDrawerSettingsFileName) if Storages.isExistentStorage(textDrawerSettingsFileName);

class TextDrawer
{
	function drawPlayTime(layer, storage) {
		// XXX: uses _x, so need to re-evaluate
		var labels = Scripts.evalStorage("play_time.ksc");
		var timeUnitsLeftOffsets = global.timeUnitsLeftOffsets;
		var timeUnitsLeftOffsetsKeys = global.timeUnitsLeftOffsetsKeys;
		var playTimeSettings2 = global.playTimeSettings2;
		for (var i = 0, internal_forloop_count = playTimeSettings2.count; i < internal_forloop_count; i += 1)
		{
			var currentPlayTimeSettings2 = playTimeSettings2[i];
			var timeUnitsLeftOffsetsKey = timeUnitsLeftOffsetsKeys[i];
			currentPlayTimeSettings2.title.leftOffset = __si(timeUnitsLeftOffsets[timeUnitsLeftOffsetsKey], timeUnitsLeftOffsetsKey);
		}

		playTimeSettings.dictionary = %["pt_base" => labels.playtime];
		drawCenteredEntry(layer, storage, playTimeSettings);
		for (var i = 0, internal_forloop_count = playTimeSettings2.count; i < internal_forloop_count; i += 1) {
			playTimeSettings2[i].dictionary = %["pt_base" => labels.units[i]];
			drawCenteredEntry(layer, storage, playTimeSettings2[i]);
		}
	}

	function drawTigerDojoName(layer, storage, frameKey) {
		// XXX: uses _x, so need to re-evaluate
		tigerDojoSettings.dictionary = loadDictionaryIfExists("tiger_dojo_names.dic");
		drawCenteredEntry(layer, storage, tigerDojoSettings, frameKey);
	}

	function drawSkills(layer, storage, name)
	{
		skillsTitleSettings.title.content = name;
		drawCenteredEntry(layer, storage, skillsTitleSettings);

		drawCenteredEntry(layer, storage, skillsSettings);
	}

	function drawWeaponsText(layer, storage)
	{
		drawCenteredEntry(layer, storage, weaponsTextSettings);
	}

	function drawWeaponsTitle(layer, storage, name, ruby)
	{
		if (ruby !== void) {
			if (layer.window.sflags.language == "english") {
				weaponsTitleSettings.title.content = name;
				weaponsTitleSettings.rubyTitle.content = ruby;
			} else {
				weaponsTitleSettings.title.content = ruby;
				weaponsTitleSettings.rubyTitle.content = name;
			}
		} else {
			weaponsTitleSettings.title.content = name;
			weaponsTitleSettings.rubyTitle.content = void;
		}
		drawCenteredEntry(layer, storage, weaponsTitleSettings);
	}

	function drawWeaponsUser(layer, storage, name)
	{
		weaponsUserSettings.text.content = name;
		drawCenteredEntry(layer, storage, weaponsUserSettings);
	}

	function drawWeaponsName(layer, storage, name)
	{
		for (var i = 0, internal_forloop_count = weaponsNameSettings.count; i < internal_forloop_count; i += 1) {
			weaponsNameSettings[i].text.content = name;
			drawCenteredEntry(layer, storage, weaponsNameSettings[i]);
		}
	}

	function drawVoiceName(layer, storage, settings) {
		if (sf.language == japaneseLanguage) {
			if (storage == "voicename_イリヤ") {
				settings.text.fontHeight = 15;
			} else {
				settings.text.fontHeight = 20; // should be the same as the settings in VoiceConfigLayer.tjs
			}
		}
		drawCenteredEntry(layer, storage, settings);
	}

	function drawStatusButtons(layer, storage)
	{
		layer.loadImages("ss_button_mask");
		for (var i = 0, internal_forloop_count = statusButtonsSettings.count; i < internal_forloop_count; i += 1) {
			statusButtonsSettings[i].dictionary = statusButtonsDictionary;
			if(storage == "ss_宝具ボタン" && layer.window.sflags.language == "english") {
				statusButtonsSettings[i].text.fontHeight = 15;
				statusButtonsSettings[i].text.rightOffset = (statusButtonsImageWidth / statusButtonsNumber) * (statusButtonsNumber - (i+1)) + 15;
			}
			else
			{
				statusButtonsSettings[i].text.fontHeight = 18;
				statusButtonsSettings[i].text.rightOffset = ((statusButtonsImageWidth / statusButtonsNumber) * (statusButtonsNumber - (i+1)) + 30) | 0;
			}
			drawCenteredEntry(layer, storage, statusButtonsSettings[i]);
		}
	}

	function drawNoblePhantasmSpecification(layer, storage)
	{
		// XXX: uses _n, so need to re-evaulate
		noblePhantasmSpecificationSettings.dictionary = loadDictionaryIfExists("status_noble_phantasm_specification.dic");
		drawCenteredEntry(layer, storage, noblePhantasmSpecificationSettings);
	}

	function drawNoblePhantasmText(layer, storage)
	{
		drawCenteredEntry(layer, storage, noblePhantasmTextSettings);
	}

	function drawNoblePhantasmButtons(layer, storage)
	{
		var noblePhantasmImageWidth = layer.imageWidth;
		for (var i = 0, internal_forloop_count = noblePhantasmButtonsSettings.count; i < internal_forloop_count; i += 1) {
			{
				var d = noblePhantasmButtonsSettings[i];
				{
					var dd = d.title;
					dd.imageWidth = noblePhantasmImageWidth;
					dd.leftOffset = i * ((noblePhantasmImageWidth / noblePhantasmButtonsNumber) | 0);
					dd.rightOffset = ((noblePhantasmImageWidth / noblePhantasmButtonsNumber) * (noblePhantasmButtonsNumber - (i+1))) | 0;
				}
				d.rubyTitle.imageWidth = d.title.imageWidth;
				d.rubyTitle.leftOffset = d.title.leftOffset;
				d.rubyTitle.rightOffset = d.title.rightOffset;
			}
			drawCenteredEntry(layer, storage, noblePhantasmButtonsSettings[i]);
		}
	}

	function drawDetails(layer, storage)
	{
		drawCenteredEntry(layer, storage, detailsSettings);
	}

	function initializeStatusLabels(statusLabelLayers, layer) {
		if (statusLabelLayers[layer] == void) {
			statusLabelLayers[layer] = [];
			for (var i = 0, internal_forloop_count = statusRankSettings.count; i < internal_forloop_count; i += 1) {
				var settings = statusRankSettings[i];
				var statusLabelLayer = new global.Layer(layer.window, layer);
				{
					var l = statusLabelLayer;
					l.setPos(settings.layerLeft, settings.layerTop);
					l.setSize(settings.layerWidth, settings.layerHeight);
					l.visible = true;
					l.hitThreshold = 0;
				}
				statusLabelLayers[layer].add(statusLabelLayer);
			}
		}

		// XXX: uses _x, so need to re-evaulate
		var rankLabels = Scripts.evalStorage("rank_labels.ksc");
		for (var i = 0, internal_forloop_count = statusRankSettings.count; i < internal_forloop_count; i += 1) {
			statusRankSettings[i].text.content = rankLabels[i][0];
			statusRankSettings[i].hint = rankLabels[i][1];
			var statusLabelLayer = statusLabelLayers[layer][i];
			{
				var l = statusLabelLayer;
				drawCenteredEntry(statusLabelLayer,, statusRankSettings[i]);
				layer.operateRect(l.left, l.top, statusLabelLayer, 0, 0, l.imageWidth, l.height);
				l.fillRect(0, 0, l.imageWidth, l.imageHeight, 0x00000000);
			}
		}
	}

	function setStatusLabelsVisibility(statusLabelLayers, layers, value) {
		for (var i = 0, internal_forloop_count = layers.count; i < internal_forloop_count; i += 1) {
			if (statusLabelLayers[layers[i]] != void) {
				for (var j = 0, internal_forloop_count = statusLabelLayers[layers[i]].count; j < internal_forloop_count; j += 1) {
					statusLabelLayers[layers[i]][j].visible = value;
				}
			}
		}
	}

	function drawStatusLabels(layer, storage)
	{
		// XXX: uses _x, so need to re-evaulate
		var labels = Scripts.evalStorage("status_labels.ksc");
		statusLabelsSettings.text.content = labels.labels.join("\n");
		drawCenteredEntry(layer, storage, statusLabelsSettings);
		classAbilitiesSettings.title.content = labels.abilities;
		drawCenteredEntry(layer, storage, classAbilitiesSettings);
	}

	function drawId(layer, storage) {
		if (sf.language == japaneseLanguage) {
			if (storage == "ss_マスターイリヤ") {
				idSettings.text.fontHeight = 15;
			} else {
				idSettings.text.fontHeight = 18; // should be same as idSettings in TextDrawerSettings.tjs
			}
		}
		drawCenteredEntry(layer, storage, idSettings);
	}

	function drawClassNameTitle(layer, storage) {
		drawCenteredEntry(layer, storage, classNameTitleSettings);
	}

	function drawClassName(layer, storage) {
		drawCenteredEntry(layer, storage, classNameSettings);
	}

	function drawWallpaperName(layer, storage, name, settings)
	{
		settings.text.content = name;
		drawCenteredEntry(layer, storage, settings);
	}

	function drawExtraButtons(layer, storage)
	{
		for (var i = 0, internal_forloop_count = extraMenuButtonsSettings.count; i < internal_forloop_count; i += 1) {
			drawCenteredEntry(layer, storage, extraMenuButtonsSettings[i]);
		}
	}

	function formatDictionary(dic)
	{
		var format = __(dic.format);
		var arguments = [];
		arguments.assignStruct(dic.arguments);
		for (var i = 0, internal_forloop_count = arguments.count; i < internal_forloop_count; i += 1)
		{
			if (typeof(arguments[i]) === "String")
			{
				arguments[i] = __(arguments[i]);
			}
			else if (typeof(arguments[i]) === "Object" && typeof(arguments[i].format) === "String")
			{
				arguments[i] = formatDictionary(arguments[i]);
			}
		}
		return format.sprintf(arguments*);
	}

	function drawCenteredEntry(layer, storage, settings, frameKey)
	{
		{
			var l = layer;
			var previousFace = l.face;

			if (settings.useDictionary && (settings.dictionary == void || settings.dictionary[storage] == void)) {
				l.loadImages(storage, frameKey);
				l.setSizeToImageSize() if settings.updateSize;
				return;
			}

			if (settings.cleanBgImage != void) {
				l.loadImages(isExistentImage(settings.cleanBgImage)? settings.cleanBgImage : storage, frameKey);
				l.setSizeToImageSize() if settings.updateSize;
			} else {
				if (settings.imageWidth != void && settings.imageHeight != void) {
					l.setImageSize(settings.imageWidth, settings.imageHeight);
					l.setSizeToImageSize() if settings.updateSize;
				}
				if (settings.emptyLayerImage) {
					l.fillRect(0, 0, l.imageWidth, l.imageHeight, 0x00000000);
				}
			}

			if (settings.hint != void) {
				l.hint = settings.hint;
			}

			l.face = dfAlpha;

			var text;
			var title;
			var content;
			var originalSettings = %[];
			if (settings.useDictionary) {
				var dictionaryItem = settings.dictionary[storage];
				if (typeof dictionaryItem == "String") {
					text = __(dictionaryItem);
				} else if (typeof(dictionaryItem) === "Object" && typeof(dictionaryItem.format) === "String") {
					text = formatDictionary(dictionaryItem);
				} else {
					if (typeof(dictionaryItem[0]) === "Object" && typeof(dictionaryItem[0].format) === "String")
					{
						text = formatDictionary(dictionaryItem[0]);
					}
					else
					{
						text = __(dictionaryItem[0]);
					}
					var settingsOverride = dictionaryItem[1];
					originalSettings = applyOverrideSettings(settings, settingsOverride);
				}
				if (settings.title.exists && settings.text.exists) {
					var items = [].split("|", text);
					title = items[0];
					content = items[1];
				} else if (settings.title.exists) {
					title = text;
				} else if (settings.text.exists) {
					content = text;
				}
			} else {
				title = settings.title.content;
				content = settings.text.content;
			}

			if (settings.title.exists && title != "") {
				var titleRuby;
				var titleText;
				var textHeight = 0;
				if (settings.rubyTitle.exists && title.indexOf("$") !== -1) {
					var titleItems = [].split("$",title);
					titleRuby = titleItems[0];
					titleText = titleItems[1];

					setFontFromSettings(l.font, settings.rubyTitle);
					textHeight += getTextHeight([[titleRuby]], settings.rubyTitle, l.font);
				} else if (settings.rubyTitle.content != "") {
					titleRuby = settings.rubyTitle.content;
					titleText = title;

					setFontFromSettings(l.font, settings.rubyTitle);
					textHeight += getTextHeight([[titleRuby]], settings.rubyTitle, l.font);
				} else {
					titleText = title;
				}

				setFontFromSettings(l.font, settings.title);
				var titleLines = wordWrapSplitLines(titleText, l.imageWidth - settings.title.horizontalOffset, l.font);
				textHeight += getTextHeight([titleLines], settings.title, l.font);

				var titleY = getYByAlignment(layer, settings.title, textHeight);

				if (titleRuby !== void) {
					setFontFromSettings(l.font, settings.rubyTitle);
					var titleX = getXByAlignment(layer, settings.rubyTitle, titleRuby);

					drawTextGlow(settings.title, titleX, titleY, titleRuby, layer);
					l.drawText(titleX, titleY, titleRuby, settings.title.color);
					titleY += l.font.height + settings.title.lineSpace;
				}

				setFontFromSettings(l.font, settings.title);
				drawLines(layer, titleY, titleLines, settings.title);
			}

			if (settings.text.exists) {
				setFontFromSettings(l.font, settings.text);

				var paragraphs = wordWrapSplitParagraphs(content, l.imageWidth - settings.text.horizontalOffset, l.font);

				var textHeight = getTextHeight(paragraphs, settings.text, l.font);
				var textY = getYByAlignment(layer, settings.text, textHeight);

				for (var p = 0, internal_forloop_count = paragraphs.count; p < internal_forloop_count; p += 1) {
					var textLines = paragraphs[p];
					textY = drawLines(layer, textY, textLines, settings.text);
					if (p < paragraphs.count-1) {
						textY += settings.text.paragraphSpace;
					}
				}
			}

			l.face = previousFace;

			applyOverrideSettings(settings, originalSettings);
		}
	}

	function drawLines(layer, y, lines, textSettings) {
		{
			var l = layer;
			for (var i = 0, internal_forloop_count = lines.count; i < internal_forloop_count; i += 1) {
				var x = getXByAlignment(layer, textSettings, lines[i]);

				drawTextGlow(textSettings, x, y, lines[i], layer);
				l.drawText(x, y, lines[i], textSettings.color, textSettings.opacity,,textSettings.shadowOpacity, textSettings.shadowColor, textSettings.shadowWidth, textSettings.shadowOffsetX, textSettings.shadowOffsetY);
				y += l.font.height;
				if (i < lines.count-1) {
					y += textSettings.lineSpace;
				}
			}
		}
		return y;
	}

	function drawTextGlow(textSettings, x, y, text, layer) {
		{
			var l = layer;
			if (textSettings.glow) {
				l.drawText(x, y, text, textSettings.glowColor, textSettings.glowOpacity,, textSettings.glowStrength, textSettings.glowColor, textSettings.glowSize, 0, 0);
			}
		}
	}

	function getTextHeight(paragraphs, textSettings, font) {
		var height = 0;
		for (var i = 0, internal_forloop_count = paragraphs.count; i < internal_forloop_count; i += 1) {
			var lines = paragraphs[i];
			height += font.height * lines.count + textSettings.lineSpace * (lines.count-1);
			if (i < paragraphs.count - 1) {
				height += textSettings.paragraphSpace;
			}
		}
		return height;
	}

	function getXByAlignment(layer, textSettings, text) {
		var x;
		{
			var l = layer;
			if (textSettings.alignment == "center") {
				x = textSettings.leftOffset+(l.imageWidth - textSettings.horizontalOffset - l.font.getTextWidth(text))/2;
			} else if (textSettings.alignment == "left") {
				x = textSettings.leftOffset;
			}
		}
		return x;
	}

	function getYByAlignment(layer, textSettings, textHeight) {
		var y = 0;
		{
			var l = layer;
			var maxHeight = textSettings.maxHeight != void? textSettings.maxHeight : l.imageHeight - textSettings.verticalOffset;
			if (textSettings.verticalAlignment == "center") {
				y = textSettings.topOffset+(maxHeight - textHeight)/2;
			} else if (textSettings.verticalAlignment == "top") {
				y = textSettings.topOffset;
			} else if (textSettings.verticalAlignment == "bottom") {
				y = textSettings.topOffset + maxHeight - textHeight;
			}
		}
		return y;
	}

	function setFontFromSettings(font, textSettings) {
		font.face = __s(textSettings.fontFace, textSettings.fontContext);
		font.height = textSettings.fontHeight;
		font.bold = textSettings.fontBold;
		font.italic = textSettings.fontItalic;
	}

	function drawAbilities(layer, storage)
	{
		var settings = abilitiesSettings;

		{
			var l = layer;
			if (settings.dictionary == void || settings.dictionary[storage] == void) {
				l.loadImages(storage);
				l.setSizeToImageSize();
				return;
			}

			var abilities = settings.dictionary[storage];

			l.loadImages(isExistentImage(settings.cleanBgImage + abilities.count)? (settings.cleanBgImage + abilities.count) : storage);
			l.setSizeToImageSize();

			var longestTitleWidth = getLongestTitle(l.font, settings.title, abilities);

			for (var i = 0, internal_forloop_count = abilities.count; i < internal_forloop_count; i += 1) {
				var title = __(abilities[i][0]);
				var rank = ": "+__(abilities[i][1]);
				var content = __(abilities[i][2]);

				var abilityHeight = (l.height - (abilities.count-1)*settings.distanceBetweenEntries)/abilities.count;

				setFontFromSettings(l.font, settings.title);

				var titleX = settings.title.leftOffset + (longestTitleWidth - l.font.getTextWidth(title))/2;
				var titleY = i*(abilityHeight+settings.distanceBetweenEntries) + (abilityHeight-l.font.height)/2 + settings.abilityTopOffset*-(abilities.count-2);
				l.drawText(titleX, titleY, title, settings.title.color,,, settings.title.shadowOpacity, settings.title.shadowColor, settings.title.shadowWidth, settings.title.shadowOffsetX, settings.title.shadowOffsetY);

				var rankX = settings.title.leftOffset +  longestTitleWidth;
				l.drawText(rankX, titleY, rank, settings.title.color,,, settings.title.shadowOpacity, settings.title.shadowColor, settings.title.shadowWidth, settings.title.shadowOffsetX, settings.title.shadowOffsetY);

				setFontFromSettings(l.font, settings.text);

				var textX = rankX + settings.text.leftOffset;
				var textMaxWidth = l.imageWidth - textX - settings.text.rightOffset;
				var textLines = wordWrapSplitLines(content, textMaxWidth, l.font);
				var textY = i*(abilityHeight+settings.distanceBetweenEntries) + (abilityHeight - textLines.count * l.font.height - (textLines.count-1) * settings.text.lineSpace)/2 + settings.abilityTopOffset*-(abilities.count-2);
				for (var j = 0, internal_forloop_count = textLines.count; j < internal_forloop_count; j += 1) {
					l.drawText(textX, textY, textLines[j], settings.text.color,,, settings.text.shadowOpacity, settings.text.shadowColor, settings.text.shadowWidth, settings.text.shadowOffsetX, settings.text.shadowOffsetY);
					textY += l.font.height + settings.text.lineSpace;
				}
			}
		}
	}

	function getLongestTitle(font, settings, abilities)
	{
		setFontFromSettings(font, settings);
		var longestTitleWidth = settings.minWidth;
		for (var i = 0, internal_forloop_count = abilities.count; i < internal_forloop_count; i += 1) {
			var title = __(abilities[i][0]);
			var titleWidth = font.getTextWidth(title);
			if ((titleWidth + settings.rightOffset) > longestTitleWidth) {
				longestTitleWidth = titleWidth + settings.rightOffset;
			}
		}
		return longestTitleWidth;
	}

	function applyOverrideSettings(settings, settingsOverride) {
		var originalSettings = %[];

		var keys = [];
		keys.assign(settingsOverride);
		for (var i = 0, internal_forloop_count = keys.count; i < internal_forloop_count; i += 2) {
			var key = keys[i];
			var subkeys = [].split(".", key);
			var subsettings = settings;
			for (var j = 0, internal_forloop_count = subkeys.count - 1; j < internal_forloop_count; j += 1) {
				subsettings = subsettings[subkeys[j]];
			}
			var subkey = subkeys[subkeys.count-1];
			originalSettings[key] = subsettings[subkey];
			subsettings[subkey] = settingsOverride[key];
		}
		invalidate keys;

		return originalSettings;
	}
}

@endif
