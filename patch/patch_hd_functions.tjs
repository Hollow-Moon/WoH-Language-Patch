global.scalePosition = function(v, size, scaledSize, parentSize, parentScaledSize, align=0, positionScaleMode=0)
{
    if (size >= parentSize) {
        v *= scaledSize / size;
        if (size == parentSize) {
            v += (parentScaledSize - scaledSize) * align;
        }
    } else {
		// positionScaleMode
		//	0: discrete transform
		//	1: center point scaling (unscaled sprites will not touch sides but maintain relative position)
		if (positionScaleMode == 1) {
			v = ((v + size/2) * (parentScaledSize/parentSize)) - (scaledSize/2);
		}
		else {
			if (v < 0) {
				v *= scaledSize / size;
			} else if (v > parentSize - size) {
				var m = scaledSize / size;
				var n = parentScaledSize - m * parentSize;
				v = m * v + n;
			} else {
				v *= (parentScaledSize - scaledSize) / (parentSize - size);
			}
        }
    }
	return global.Math.round(v) | 0;
};

// Equivalently to scalePosition(), which calculates the scaled left/top coordinate,
// scalePosition2() calculates the scaled right/bottom coordinate.
// Currently used by fillRect_patch_hd_layer() and colorRect_patch_hd_layer()
global.scalePosition2 = function(v, size, scaledSize, parentSize, parentScaledSize, align=0, positionScaleMode=0)
{
    if (size >= parentSize) {
        v *= scaledSize / size;
        if (size == parentSize) {
            v += (parentScaledSize - scaledSize) * align;
        }
    } else {
		if (positionScaleMode == 1) {
			v = ((v - size/2) * (parentScaledSize/parentSize)) + (scaledSize/2);
		}
		else {
			if (v < size) {
				v *= scaledSize / size;
			} else if (v > parentSize) {
				var m = scaledSize / size;
				var n = parentScaledSize - m * parentSize;
				v = m * v + n;
			} else {
				v = ((parentScaledSize - scaledSize) / (parentSize - size)) * v   + (((parentSize * scaledSize) - (parentScaledSize * size)) / (parentSize - size));
			}
		}
	}
		
	return global.Math.round(v) | 0;
};

global.scaleSize = function(v, scale)
{
    v *= scale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
    v = global.Math.round(v);
@endif
    return v | 0;
};

global.unscaleSize = function(v, scale)
{
// Some consumers will need float (e.g. font kerning).
// So output float and round in consumer, where needed (e.g. window sizing).
return v/scale;
};
