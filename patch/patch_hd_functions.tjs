global.scalePosition = function(v, size, scaledSize, parentSize, parentScaledSize, align=0)
{
    if (size >= parentSize) {
        v *= scaledSize / size;
        if (size == parentSize) {
            v += (parentScaledSize - scaledSize) * align;
        }
    } else {
        if (v < 0) {
            v *= scaledSize / size;
        } else if (v > parentSize - size) {
            var m = scaledSize / size;
            var n = parentScaledSize - m * parentSize;
            v = m * v + n;
        } else {
            v *= (parentScaledSize - scaledSize) / (parentSize - size);
        }
    }
@if(SCALE_ROUND_TOWARDS_NEAREST)
    v = global.Math.round(v);
@endif
    return v | 0;
};

// Equivalently to scalePosition(), which calculates the scaled left/top coordinate,
// scalePosition2() calculates the scaled right/bottom coordinate.
global.scalePosition2 = function(v, size, scaledSize, parentSize, parentScaledSize, align=0)
{
    if (size >= parentSize) {
        v *= scaledSize / size;
        if (size == parentSize) {
            v += (parentScaledSize - scaledSize) * align;
        }
    } else {
        if (v < size) {
            v *= scaledSize / size;
        } else if (v > parentSize) {
            var m = scaledSize / size;
            var n = parentScaledSize - m * parentSize;
            v = m * v + n;
        } else {
            v = ((parentScaledSize - scaledSize) / (parentSize - size)) * v   + (((parentSize * scaledSize) - (parentScaledSize * size)) / (parentSize - size));
        }
    }
@if(SCALE_ROUND_TOWARDS_NEAREST)
    v = global.Math.round(v);
@endif
    return v | 0;
};

global.scaleSize = function(v, scale)
{
    v *= scale;
@if(SCALE_ROUND_TOWARDS_NEAREST)
    v = global.Math.round(v);
@endif
    return v | 0;
};

global.unscaleSize = function(v, scale)
{
    // round() seems to give correct unscaled results both for scaled values that were floored and for ones that were rounded.
    return global.Math.round(v/scale) | 0;
};
