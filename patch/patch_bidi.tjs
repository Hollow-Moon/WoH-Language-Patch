
class BidiUtilities
{
	function from_char_code(code_point)
	{
		if (code_point > 0xFFFF)
		{
			code_point -= 0x10000;
			return $(0xD800 + (code_point >> 10)) + $(0xDC00 + (code_point & 0x3FF));
		}
		else
		{
			return $(code_point);
		}
	}

	function unpack_string(str)
	{
		var result = [];
		var pos = 0;
		while (pos < str.length)
		{
			var code = #(str[pos++]);
			var next = #(str[pos]);
			// If a surrogate pair
			if ((0xd800 <= code && code <= 0xdbff) && (0xdc00 <= next && next <= 0xdfff))
			{
				pos += 1;
				result.add(((code - 0xd800) * 0x400) + (next - 0xdc00) + 0x10000);
			}
			else
			{
				result.add(code);
			}
		}
		return result;
	}

	function pack_array(char_arr)
	{
		return ((function(char_arr) {
			var _i, _len, _results;
			_results = [];
			for (_i = 0, _len = char_arr.count; _i < _len; _i++)
			{
				_results.add(BidiUtilities.from_char_code(char_arr[_i]));
			}
			return _results;
		}) incontextof this)(char_arr).join("");
	}

	function arraycopy(orig, orig_index, dest, dest_index, length)
	{
		var count, elem, _i, _len, _ref;
		_ref = []; // orig.slice(orig_index, orig_index + length);
		for (var i = orig_index; i < orig_index + length; i += 1)
		{
			_ref.add(orig[i]);
		}
		for (count = _i = 0, _len = _ref.count; _i < _len; count = ++_i)
		{
			elem = _ref[count];
			dest[dest_index + count] = elem;
		}
	}

	function max(arr)
	{
		var elem, i, max, start_index, _i, _j, _len, _ref;
		max = void;
		for (start_index = _i = 0, _len = arr.count; _i < _len; start_index = ++_i)
		{
			elem = arr[start_index];
			if (elem !== void)
			{
				max = elem;
				break;
			}
		}
		for (i = _j = start_index, _ref = arr.count; start_index <= _ref ? _j <= _ref : _j >= _ref; i = start_index <= _ref ? ++_j : --_j)
		{
			if (arr[i] > max)
			{
				max = arr[i];
			}
		}
		return max;
	}

	function min(arr)
	{
		var elem, i, min, start_index, _i, _j, _len, _ref;
		min = void;
		for (start_index = _i = 0, _len = arr.count; _i < _len; start_index = ++_i)
		{
			elem = arr[start_index];
			if (elem !== void)
			{
				min = elem;
				break;
			}
		}
		for (i = _j = start_index, _ref = arr.count; start_index <= _ref ? _j <= _ref : _j >= _ref; i = start_index <= _ref ? ++_j : --_j)
		{
			if (arr[i] < min)
			{
				min = arr[i];
			}
		}
		return min;
	}

	function is_even(num)
	{
		return num % 2 === 0;
	}

	function is_odd(num)
	{
		return num % 2 === 1;
	}
}

global.bidi_classes = Scripts.evalStorage("patch_bidi_classes.dic");

class Bidi
{
	var MAX_DEPTH = 62;

	function Bidi(options)
	{
		if (options === void)
		{
			options = %[];
		}
		this.string_arr = options.string_arr !== void ? options.string_arr : options.types;
		this.types = options.types !== void ? options.types : [];
		this.levels = [];
		this.runs = [];
		this.direction = options.direction;
		this.default_direction = options.default_direction !== void ? options.default_direction : "LTR";
		this.count = this.types.count;
		this.run_bidi();
	}

	function bidi_class_for(code_point)
	{
		var end, range, start, _i, _len;
		var _ref = global.bidi_classes;
		var _ref_keys = [];
		_ref_keys.assign(_ref);
		for (var i = 0; i < _ref_keys.count; i += 2)
		{
			var bidi_class = _ref_keys[i];
			var ranges = _ref[bidi_class];
			var ranges_keys = [];
			ranges_keys.assign(ranges);
			for (var j = 0; j < ranges_keys.count; j += 2)
			{
				var range_offset = ranges_keys[j];
				var range_list = ranges[range_offset];
				for (_i = 0, _len = range_list.count; _i < _len; _i++)
				{
					range = range_list[_i];
					start = range;
					end = start + (range_offset | 0);
					if ((code_point >= start) && (code_point <= end))
					{
						return bidi_class;
					}
				}
			}
		}
		return void;
	}

	function from_string(str, options)
	{
		var string_arr;
		if (options === void)
		{
			options = %[];
		}
		string_arr = BidiUtilities.unpack_string(str);
		if (typeof(string_arr) === "Object")
		{
			options.types = Bidi.compute_types(string_arr);
		}
		if (typeof(string_arr) === "Object")
		{
			options.string_arr = string_arr;
		}
		return new Bidi(options);
	}

	function from_type_array(types, options)
	{
		if (options === void)
		{
			options = %[];
		}
		if (typeof(types) === "Object")
		{
			options.types = types;
		}
		return new Bidi(options);
	}

	function compute_types(arr)
	{
		var _i, _len, _results;
		_results = [];
		for (_i = 0, _len = arr.count; _i < _len; _i++)
		{
			_results.add(Bidi.bidi_class_for(arr[_i]));
		}
		return _results;
	}

	function toString()
	{
		return BidiUtilities.pack_array(this.string_arr);
	}

	function reorder_visually()
	{
		var depth, finish, i, level, lowest_odd, max, start, tmpb, tmpo, _i, _j, _k, _len, _ref, _ref1;
		if (!this.string_arr)
		{
			throw "No string given!";
		}
		max = 0;
		lowest_odd = MAX_DEPTH + 1;
		_ref = this.levels;
		for (_i = 0, _len = _ref.count; _i < _len; _i++)
		{
			level = _ref[_i];
			max = BidiUtilities.max([level, max]);
			if (!BidiUtilities.is_even(level))
			{
				lowest_odd = BidiUtilities.min([lowest_odd, level]);
			}
		}
		for (depth = _j = max; max <= 0 ? _j < 0 : _j > 0; depth = max <= 0 ? ++_j : --_j)
		{
			start = 0;
			while (start < this.levels.count)
			{
				while (start < this.levels.count && this.levels[start] < depth)
				{
					start += 1;
				}
				if (start === this.levels.count)
				{
					break;
				}
				finish = start + 1;
				while (finish < this.levels.count && this.levels[finish] >= depth)
				{
					finish += 1;
				}
				for (i = _k = 0, _ref1 = (finish - start) \ 2; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k)
				{
					tmpb = this.levels[finish - i - 1];
					this.levels[finish - i - 1] = this.levels[start + i];
					this.levels[start + i] = tmpb;
					tmpo = this.string_arr[finish - i - 1];
					this.string_arr[finish - i - 1] = this.string_arr[start + i];
					this.string_arr[start + i] = tmpo;
				}
				start = finish + 1;
			}
		}
		return this;
	}

	function compute_paragraph_embedding_level()
	{
		var type, _i, _len, _ref;
		if (["LTR", "RTL"].find(this.direction) !== -1)
		{
			return this.direction === "LTR" ? 0 : 1;
		}
		else
		{
			_ref = this.types;
			for (_i = 0, _len = _ref.count; _i < _len; _i++)
			{
				type = _ref[_i];
				if (type === "L")
				{
					return 0;
				}
				if (type === "R")
				{
					return 1;
				}
			}
			return this.default_direction === "LTR" ? 0 : 1;
		}
	}

	function compute_explicit_levels()
	{
		var current_embedding, directional_override, embedding_stack, i, input, is_ltr, is_special, len, new_embedding, next_fmt, output, size, sp, _i, _j, _ref, _ref1;
		current_embedding = this.base_embedding;
		directional_override = -1;
		embedding_stack = [];
		if (typeof(this.formatter_indices) !== "Object")
		{
			this.formatter_indices = [];
		}
		sp = 0;
		for (i = _i = 0, _ref = this.count; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i)
		{
			is_ltr = false;
			is_special = true;
			is_ltr = this.types[i] === "LRE" || this.types[i] === "LRO";
			switch (this.types[i])
			{
				case "RLE":
				case "RLO":
				case "LRE":
				case "LRO":
					new_embedding = is_ltr ? (current_embedding & ~1) + 2 : (current_embedding + 1) | 1;
					if (new_embedding < MAX_DEPTH)
					{
						if (directional_override !== -1)
						{
							current_embedding |= -0x80;
						}
						embedding_stack[sp] = current_embedding;
						current_embedding = new_embedding;
						sp += 1;
						directional_override = this.types[i] === "LRO" ? "L" : this.types[i] === "RLO" ? "R" : -1;
					}
					break;
				case "PDF":
					if (sp > 0)
					{
						sp -= 1;
						new_embedding = embedding_stack[sp];
						current_embedding = new_embedding & 0x7f;
						directional_override = new_embedding < 0 ? (_ref1 = (new_embedding & 1) === 0) ? _ref1 : %["L" => "R"] : -1;
					}
					break;
				default:
					is_special = false;
			}
			this.levels[i] = current_embedding;
			if (is_special)
			{
				this.formatter_indices.add(i);
			}
			else if (directional_override !== -1)
			{
				this.types[i] = directional_override;
			}
		}
		output = 0;
		input = 0;
		size = this.formatter_indices.count;
		for (i = _j = 0; 0 <= size ? _j <= size : _j >= size; i = 0 <= size ? ++_j : --_j)
		{
			next_fmt = i === size ? this.count : this.formatter_indices[i];
			len = next_fmt - input;
			BidiUtilities.arraycopy(this.levels, input, this.levels, output, len);
			BidiUtilities.arraycopy(this.types, input, this.types, output, len);
			output += len;
			input = next_fmt + 1;
		}
		return this.count -= this.formatter_indices.count;
	}

	function compute_runs()
	{
		var current_embedding, i, last_run_start, run_count, where, _i, _j, _ref, _ref1;
		run_count = 0;
		current_embedding = this.base_embedding;
		for (i = _i = 0, _ref = this.count; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i)
		{
			if (this.levels[i] !== current_embedding)
			{
				current_embedding = this.levels[i];
				run_count += 1;
			}
		}
		where = 0;
		last_run_start = 0;
		current_embedding = this.base_embedding;
		for (i = _j = 0, _ref1 = this.count; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j)
		{
			if (this.levels[i] !== current_embedding)
			{
				this.runs[where] = last_run_start;
				where += 1;
				last_run_start = i;
				current_embedding = this.levels[i];
			}
		}
		return this.runs[where] = last_run_start;
	}

	function resolve_weak_types()
	{
		var eor, finish, i, j, k, level, next_level, next_type, prev_strong_type, prev_type, previous_level, run_count, run_idx, sor, start, _i, _j, _k;
		run_count = this.runs.count;
		previous_level = this.base_embedding;
		for (run_idx = _i = 0; 0 <= run_count ? _i < run_count : _i > run_count; run_idx = 0 <= run_count ? ++_i : --_i)
		{
			start = this.get_run_start(run_idx);
			finish = this.get_run_limit(run_idx);
			level = this.get_run_level(run_idx);
			if (level === void)
			{
				level = 0;
			}
			sor = BidiUtilities.is_even(BidiUtilities.max([previous_level, level])) ? "L" : "R";
			next_level = run_idx === (run_count - 1) ? this.base_embedding : this.get_run_level(run_idx + 1);
			if (next_level === void)
			{
				next_level = 0;
			}
			eor = BidiUtilities.is_even(BidiUtilities.max([level, next_level])) ? "L" : "R";
			prev_type = sor;
			prev_strong_type = sor;
			for (i = _j = start; start <= finish ? _j < finish : _j > finish; i = start <= finish ? ++_j : --_j)
			{
				next_type = i === (finish - 1) ? eor : this.types[i + 1];
				if (this.types[i] === "NSM")
				{
					this.types[i] = prev_type;
				}
				else
				{
					prev_type = this.types[i];
				}
				if (this.types[i] === "EN")
				{
					if (prev_strong_type === "AL")
					{
						this.types[i] = "AN";
					}
				}
				else if (this.types[i] === "L" || this.types[i] === "R" || this.types[i] === "AL")
				{
					prev_strong_type = this.types[i];
				}
				if (this.types[i] === "AL")
				{
					this.types[i] = "R";
				}
				if (prev_type === "EN" && next_type === "EN")
				{
					if (this.types[i] === "ES" || this.types[i] === "CS")
					{
						this.types[i] = nextType;
					}
				}
				else if (prev_type === "AN" && next_type === "AN" && this.types[i] === "CS")
				{
					this.types[i] = next_type;
				}
				if (this.types[i] === "ET" || this.types[i] === "BN")
				{
					if (prev_type === "EN")
					{
						this.types[i] = prev_type;
					}
					else
					{
						j = i + 1;
						while (j < finish && this.types[j] === "ET" || this.types[j] === "BN")
						{
							j += 1;
						}
						if (j < finish && this.types[j] === "EN")
						{
							for (k = _k = i; i <= j ? _k < j : _k > j; k = i <= j ? ++_k : --_k)
							{
								this.types[k] = "EN";
							}
						}
					}
				}
				if (this.types[i] === "ET" || this.types[i] === "CS" || this.types[i] === "BN")
				{
					this.types[i] = "ON";
				}
				if (prev_strong_type === "L" && this.types[i] === "EN")
				{
					this.types[i] = prev_strong_type;
				}
			}
			previous_level = level;
		}
	}

	function get_run_count()
	{
		return this.runs.count;
	}

	function get_run_level(which)
	{
		return this.levels[this.runs[which]];
	}

	function get_run_limit(which)
	{
		if (which === (this.runs.count - 1))
		{
			return this.count;
		}
		else
		{
			return this.runs[which + 1];
		}
	}

	function get_run_start(which)
	{
		return this.runs[which];
	}

	function resolve_implicit_levels()
	{
		var i, _i, _ref;
		for (i = _i = 0, _ref = this.count; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i)
		{
			if ((this.levels[i] & 1) === 0)
			{
				if (this.types[i] === "R")
				{
					this.levels[i] += 1;
				}
				else if (this.types[i] === "AN" || this.types[i] === "EN")
				{
					this.levels[i] += 2;
				}
			}
			else
			{
				if (this.types[i] === "L" || this.types[i] === "AN" || this.types[i] === "EN")
				{
					this.levels[i] += 1;
				}
			}
		}
	}

	function resolve_neutral_types()
	{
		var embedding_direction, eor, finish, i, j, level, neutral_start, new_strong, next_level, override, prev_strong, previous_level, run, run_count, sor, start, this_type, _i, _j, _k;
		run_count = this.get_run_count();
		previous_level = this.base_embedding;
		for (run = _i = 0; 0 <= run_count ? _i < run_count : _i > run_count; run = 0 <= run_count ? ++_i : --_i)
		{
			start = this.get_run_start(run);
			finish = this.get_run_limit(run);
			level = this.get_run_level(run);
			if (level === void)
			{
				continue;
			}
			embedding_direction = BidiUtilities.is_even(level) ? "L" : "R";
			sor = BidiUtilities.is_even(BidiUtilities.max([previous_level, level])) ? "L" : "R";
			next_level = run === (run_count - 1) ? this.base_embedding : this.get_run_level(run + 1);
			eor = BidiUtilities.is_even(BidiUtilities.max([level, next_level])) ? "L" : "R";
			prev_strong = sor;
			neutral_start = -1;
			for (i = _j = start; start <= finish ? _j <= finish : _j >= finish; i = start <= finish ? ++_j : --_j)
			{
				new_strong = -1;
				this_type = i === finish ? eor : this.types[i];
				switch (this_type)
				{
					case "L":
						new_strong = "L";
						break;
					case "R":
					case "AN":
					case "EN":
						new_strong = "R";
						break;
					case "BN":
					case "ON":
					case "S":
					case "B":
					case "WS":
						if (neutral_start === -1)
						{
							neutral_start = i;
						}
				}
				if (new_strong !== -1)
				{
					if (neutral_start !== -1)
					{
						override = prev_strong === new_strong ? prev_strong : embedding_direction;
						for (j = _k = neutral_start; neutral_start <= i ? _k < i : _k > i; j = neutral_start <= i ? ++_k : --_k)
						{
							this.types[j] = override;
						}
					}
					prev_strong = new_strong;
					neutral_start = -1;
				}
			}
			previous_level = level;
		}
	}

	function reinsert_formatting_codes()
	{
		var index, input, left_level, len, next_fmt, output, right_level, _i, _ref;
		if ((this.formatter_indices !== void) && this.formatter_indices.count > 0)
		{
			input = this.count;
			output = this.levels.count;
			for (index = _i = _ref = this.formatter_indices.count - 1; _ref <= 0 ? _i <= 0 : _i >= 0; index = _ref <= 0 ? ++_i : --_i)
			{
				next_fmt = this.formatter_indices[index];
				len = output - next_fmt - 1;
				output = next_fmt;
				input -= len;
				if (next_fmt + 1 < this.levels.count)
				{
					BidiUtilities.arraycopy(this.levels, input, this.levels, next_fmt + 1, len);
				}
				right_level = output === this.levels.count - 1 ? this.base_embedding : this.levels[output + 1] !== void ? this.levels[output + 1] : 0;
				left_level = input === 0 ? this.base_embedding : this.levels[input] !== void ? this.levels[input] : 0;
				this.levels[output] = BidiUtilities.max([left_level, right_level]);
			}
		}
		return this.count = this.levels.count;
	}

	function run_bidi()
	{
		this.base_embedding = this.compute_paragraph_embedding_level();
		this.compute_explicit_levels();
		this.compute_runs();
		this.resolve_weak_types();
		this.resolve_neutral_types();
		this.resolve_implicit_levels();
		this.reinsert_formatting_codes();
		this.compute_runs();
	}
}


@if(0)
{
	if (false)
	{
		// adapted from https://github.com/bminor/newlib/blob/80cda9bbda04a1e9e3bee5eadf99061ed69ca5fb/newlib/libc/stdlib/utoa.c
		global.utoa = function(value, base)
		{
			var digits = "0123456789abcdefghijklmnopqrstuvwxyz";
			var str = "";
			var remainder = 0;

			// Check base is supported.
			if ((base < 2) || (base > 36))
			{ 
				return str;
			}

			// Convert to string. Digits are in reverse order.
			do
			{
				var remainder = value % base;
				str += digits[remainder];
				value = value \ base;
			} while (value != 0);  

			return str.reverse();
		};

		global.expand_bitset_str = function(bitset)
		{
			var padded_str = ("0000" + utoa(bitset | 0, 2));
			padded_str = padded_str.substring(padded_str.length - 3);
			var result = [];

			for (var padded_str_i = 0; padded_str_i < padded_str.length; padded_str_i += 1)
			{
				result.add(padded_str[padded_str_i] == "1");
			}
			result.reverse();

			return result;
		};

		var DIRECTIONS = [void, "LTR", "RTL"];

		var data = [];
		data.load("classpath_bidi_test.txt");

		var expected_level_data = [];
		var expected_reorder_data = [];
		var num_failed = 0;
		var num_succeeded = 0;
		var input_bitset, input, bitset, result_list, bitset_arr, index, check;
		var types, bidi, passed, idx, level, levels, level_idx, string_arr, i;
		var position, positions, pos_idx, line_idx, cur_line, first_char;

		for (var data_i = 0; data_i < data.count; data_i += 1)
		{
			cur_line = data[data_i].trim();
			first_char = cur_line[0];

			switch (first_char)
			{
				case "#":
				{
					continue;
				}

				case "@":
				{
					if (cur_line.indexOf("@Levels:") !== -1)
					{
						expected_level_data = [];
						levels = / /.split(/@Levels:/.replace(cur_line, "").trim());
						for (var levels_i = 0; levels_i < levels.count; levels_i += 1)
						{
							var level = levels[levels_i];
							expected_level_data.add(level | 0);
						}
					}

					if (cur_line.indexOf("@Reorder:") !== -1)
					{
						expected_reorder_data = [];
						positions = / /.split(/@Reorder:/.replace(cur_line, "").trim());
						for (var positions_i = 0; positions_i < positions.count; positions_i += 1)
						{
							var position = positions[positions_i];
							expected_reorder_data.add(position | 0);
						}
					}

					break;
				}


				default:
				{
					input_bitset = /; /.split(cur_line);
					input = input_bitset[0];
					bitset = input_bitset[1];
					result_list = [];
					bitset_arr = expand_bitset_str(bitset);

					for (var bitset_arr_i = 0; bitset_arr_i < bitset_arr.length; bitset_arr_i += 1)
					{
						check = bitset_arr[bitset_arr_i];

						if (check)
						{
							types = / /.split(input);
							bidi = Bidi.from_type_array(types, %["direction" => DIRECTIONS[bitset_arr_i], "default_direction" => "LTR"]);
							passed = true;

							var levels = bidi.levels;
							for (var levels_i = 0; levels_i < levels.count; levels_i += 1)
							{
								level = levels[levels_i];
								passed = passed && (level === expected_level_data[levels_i]);
							}

							string_arr = [];

							for (i = 0; i < types.count; i += 1)
							{
								string_arr.add(i);
							}

							bidi.string_arr = string_arr;
							bidi.reorder_visually();

							var new_string_arr = bidi.string_arr;
							for (var new_string_arr_i = 0; new_string_arr_i < new_string_arr.count; new_string_arr_i += 1)
							{
								position = new_string_arr[new_string_arr_i];
								passed = passed && (position === expected_reorder_data[new_string_arr_i]);
							}

							if (passed)
							{
								//Debug.message("Succeed");
								num_succeeded += 1;
							}
							else
							{
								//Debug.message("fail");
								//Debug.message("Failed on line " + data_i);
								num_failed += 1;
								//System.exit();
							}
						}
					}

					break;
				}

			}
		}

		Debug.message("Success: " + num_succeeded);
		Debug.message("Fail: " + num_failed);

	}

	if (false)
	{
		var bidi_str = Bidi.from_string("hello نزوة world", %["direction" => "RTL"]);
		bidi_str.reorder_visually();
		var tst = bidi_str.toString();
		Debug.message(tst);
		Debug.message(tst == "world ةوزن hello");
	}
}
@endif
