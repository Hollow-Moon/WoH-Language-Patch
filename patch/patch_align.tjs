
global.HistoryLayer_patch_align_original = global.HistoryLayer;
class HistoryLayer_patch_align_override extends global.HistoryLayer_patch_align_original
{
	function HistoryLayer_patch_align_override()
	{
		super.HistoryLayer(...);
	}

	function HistoryLayer()
	{
		this.HistoryLayer_patch_align_override(...);
	}

	function locateAlign(anchor, text, offsetText="", offsetTextDirection=0) {
		var right = this.relinePos;
		var x = void;
		var anchorValue = 0;
		if (anchor == "right") {
			anchorValue = 1;
		} else if (anchor == "center") {
			anchorValue = 0.5;
		} else if (("" + (+anchor)) == anchor) {
			anchorValue = +anchor;
		}
		x = (right - this.font.getTextWidth(text)) * anchorValue + this.font.getTextWidth(offsetText)*offsetTextDirection;
		this.lineStart[this.dataPage][this.dataPos] = x;
		this.limitPos = this.limitPos_org - x;
		this.relinePos = this.relinePos_org - x;
	}
}
global.HistoryLayer = global.HistoryLayer_patch_align_override;

global.MessageLayer_patch_align_original = global.MessageLayer;
class MessageLayer_patch_align_override extends global.MessageLayer_patch_align_original
{
	function MessageLayer_patch_align_override()
	{
		super.MessageLayer(...);
	}

	function MessageLayer()
	{
		this.MessageLayer_patch_align_override(...);
	}

	function locateAlign(anchor, text, offsetText="", offsetTextDirection=0)
	{
		var right = this.relinexpos - this.marginL;
		var x = void;
		var anchorValue = 0;
		if (anchor == "right") {
			anchorValue = 1;
		} else if (anchor == "center") {
			anchorValue = 0.5;
		} else if (("" + (+anchor)) == anchor) {
			anchorValue = +anchor;
		}
@if(!MESSAGELAYER_USECHARLAYER)
		x = (right - this.lineLayer.font.getTextWidth(text)) * anchorValue + this.lineLayer.font.getTextWidth(offsetText)*offsetTextDirection;
@endif
@if(MESSAGELAYER_USECHARLAYER)
		x = (right - this.getChWidth(text)[1]) * anchorValue + this.getChWidth(offsetText)[1]*offsetTextDirection;
@endif
		this.locate(x, void);
	}

	function locateAlignImage(anchor, imageWidth, y)
	{
		var right = this.window.scWidth - this.marginL;
		var anchorValue = global.getAnchorValue(anchor);
		var x = (right - imageWidth) * anchorValue;
		this.locate(x, y);
	}
}
global.MessageLayer = global.MessageLayer_patch_align_override;

global.KAGWindow_patch_align_original = global.KAGWindow;
class KAGWindow_patch_align_override extends global.KAGWindow_patch_align_original
{
	function KAGWindow_patch_align_override()
	{
		super.KAGWindow(...);
	}

	function KAGWindow()
	{
		this.KAGWindow_patch_align_override(...);
	}

	function getHandlers()
	{
		var handlers = super.getHandlers();
		handlers.locatealign = function(elm)
		{
			this.historyLayer.locateAlign(elm.anchor, elm.textForLength, elm.offsetText, elm.offsetTextDirection);
			if(this.currentWithBack) this.current.comp.locateAlign(elm.anchor, elm.textForLength, elm.offsetText, elm.offsetTextDirection);
			this.current.locateAlign(elm.anchor, elm.textForLength, elm.offsetText, elm.offsetTextDirection);
			return 0;
		} incontextof this;
		handlers.align = function(elm)
		{
			var textToAlign = elm.text;
			var textForLength = textToAlign;
			textForLength = elm.textforlength if elm.textforlength !== void;
			var offsetText = "";
			offsetText = elm.offsettext if elm.offsettext !== void;
			var offsetTextDirection = 0;
			offsetTextDirection = elm.offsettextdirection if elm.offsettextdirection !== void;
			if (elm.rubytext !== void) {
				var rubyTag = %[tagname:"ruby", text:elm.rubytext];
				rubyTag.o2o    = elm.rubyo2o    if elm.rubyo2o    !== void;
				rubyTag.pos    = elm.rubypos    if elm.rubypos    !== void;
				rubyTag.char   = elm.rubychar   if elm.rubychar   !== void;
				rubyTag.offset = elm.rubyoffset if elm.rubyoffset !== void;
				this.conductor.queueTag(0, rubyTag);
			}
			if (elm.text !== void) {
				textToAlign = this.conductor.cleanLine(textToAlign);
				if (textToAlign.indexOf(this.conductor.dash_character) !== -1 || textToAlign.indexOf(this.conductor.block_character) !== -1)
				{
					var tag_index = 0;
					for (var i = 0, internal_forloop_count = textToAlign.length; i < internal_forloop_count; i += 1) {
						var character = textToAlign[i];
						var line_tag = %[tagname:"line", len:0];
						var block_tag = %[tagname:"block", len:0];
						while (character == this.conductor.dash_character) {
							i++;
							line_tag.len++;
							character = textToAlign[i];
						}
						while (character == this.conductor.block_character) {
							i++;
							block_tag.len++;
							character = textToAlign[i];
						}
						if (line_tag.len > 0 || block_tag.len > 0) {
							if (line_tag.len > 0) {
								this.conductor.queueTag(tag_index, line_tag);
								i--;
							}
							if (block_tag.len > 0) {
								this.conductor.queueTag(tag_index, block_tag);
								i--;
							}
						} else {
							var chTag = %[tagname:"ch", text:textToAlign[i]];
							this.conductor.queueTag(tag_index, chTag);
						}
						tag_index++;
					}
				}
				else
				{
					this.conductor.queueText(textToAlign, elm);
				}
			}
			if (elm.indent) {
				var indentTag = %[tagname:"indent"];
				var indentOffset = 0;
				if (elm.indentoffset !== void) {
					indentOffset = elm.indentoffset;
				}
				this.conductor.queueTag(indentOffset, indentTag);
			}
			if (elm.anchor !== void) {
				if(elm.rubychar != void && ("" + (+elm.rubychar)) != elm.rubychar) {
					textForLength = elm.rubychar;
				}
				textForLength = this.conductor.cleanLine(textForLength);
				offsetText = this.conductor.cleanLine(offsetText);
				var locatealignTag = %[tagname:"locatealign", anchor:elm.anchor, textForLength:textForLength, offsetText:offsetText, offsetTextDirection:offsetTextDirection];
				this.conductor.queueTag(0, locatealignTag);
			}
			return 0;
		} incontextof this;
		return handlers;
	}

}
global.KAGWindow = global.KAGWindow_patch_align_override;
