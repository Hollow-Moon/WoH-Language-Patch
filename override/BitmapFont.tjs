@if(__BITMAPFONT_DEFINED__==0)
@set(__BITMAPFONT_DEFINED__=1)

//	ビットマップフォントの設定
var	fontFileExt	= ".tft";
var	fontItalicSuffix	= "_i";	//	italic=true のときに末尾に付加する
var	bitmapFonts	= [
//	face名			ファイル名
	"明朝D",		%[26=>"筑紫明朝d",		24=>"筑紫明朝d24",		12=>"筑紫明朝d_rb" ],
	"明朝B",		%[26=>"筑紫明朝b",		24=>"筑紫明朝b24",		12=>"筑紫明朝b_rb" ],
	"明朝E",		%[26=>"筑紫明朝e",		24=>"筑紫明朝e24",		12=>"筑紫明朝e_rb" ],
	"ゴシックD",	%[26=>"筑紫ゴシックd",	24=>"筑紫ゴシックd24",	12=>"筑紫ゴシックd_rb" ],
	"ゴシックB",	%[26=>"筑紫ゴシックb",	24=>"筑紫ゴシックb24",	12=>"筑紫ゴシックb_rb" ],
	"ゴシックE",	%[26=>"筑紫ゴシックe",	24=>"筑紫ゴシックe24",	12=>"筑紫ゴシックe_rb" ]
];
var	loadedBitmapFonts	= %[];
for (var i = 0, internal_forloop_count = bitmapFonts.count; i < internal_forloop_count; i += 2)
	loadedBitmapFonts[bitmapFonts[i]]	= bitmapFonts[i+1];
global.all_bitmap_fonts = [];

global.test_font_if_renders = function(layer, text="A", check_using_text_size=false)
{
	var rect;
	try
	{
		rect = layer.font.getGlyphDrawRect(text);
	}
	catch (e)
	{
		return false;
	}
	var	font_width, font_height;
	if (typeof(rect) === "Object")
	{
		font_width = rect.right;
		font_height = rect.bottom;
	}
	if ((typeof(rect) !== "Object") || check_using_text_size)
	{
		font_width = layer.font.getTextWidth(text);
		font_height = layer.font.getTextHeight(text);
	}
	if (font_width === 0 || font_height === 0)
	{
		return false;
	}
	layer.setImageSize(font_width, font_height);
	layer.setSize(font_width, font_height);
	layer.setImageSize(font_width, font_height);
	layer.colorRect(0, 0, layer.imageWidth, layer.imageHeight, 0x000000);
	(global.Layer.drawText incontextof layer)(0, 0, text, 0xFFFFFF, 255);
	var has_drawn = false;
	for (var j = 0; j < layer.imageWidth - 1; j += 1)
	{
		if (layer.getMainPixel(j, layer.imageHeight \ 2) !== 0x000000)
		{
			has_drawn = true;
			break;
		}
	}
	return has_drawn;
};

/*
 *	フォントを一度だけ読み込むようにすると、文字レイヤーが破棄されたタイミングで読み込まれていない状態になるため
 *	念のため毎回ビットマップフォントファイルを設定するようにしている
 */

global.all_font_list = null;

Layer.getFontList	= function(opt)
{
	opt	= fsfSameCharSet | fsfNoVertical if opt === void;
	opt = void;
	if (global.all_font_list !== null)
	{
		return global.all_font_list;
	}
	var tmp_layer = this.window.temporaryLayer;
	var	lastface = tmp_layer.font.face, lastheight = tmp_layer.font.height, lastholdalpha = tmp_layer.holdAlpha;
	tmp_layer.face = dfMain;
	tmp_layer.holdAlpha = false;
	var	list	= [];
	try
	{
		list = tmp_layer.font.getList(opt);
	}
	catch (e)
	{
		list = [];
	}
	var removes = [
		"FixedSys",
		"System",
		"Terminal",
		"Small Fonts",
		"Apple Color Emoji",
		"Courier",
		"GB18030 Bitmap",
		"MS Sans Serif",
		"Fira Mono",
		"Fira Mono Medium",
		"Fixedsys",
		"Modern",
		"Script",
		"Roman",
		"MS Serif"
	];
	for (var i = 0, internal_forloop_count = list.count; i < internal_forloop_count; i += 1)
	{
		if (list[i].length > 1 && list[i][0] === "@")
		{
			removes.add(list[i]);
		}
	}
	for (var i = 0, internal_forloop_count = removes.count; i < internal_forloop_count; i += 1)
	{
		list.remove(removes[i]);
	}
	removes.clear();
	for (var i = 0, internal_forloop_count = list.count; i < internal_forloop_count; i += 1)
	{
		try
		{
			tmp_layer.font.face = list[i];
			if (!global.test_font_if_renders(tmp_layer, global.isJapanese(typeof(global.kag) === "Object" ? global.kag : this.window) ? "あ" : "A"))
			{
				removes.add(list[i]);
			}
		}
		catch (e)
		{
			throw new Exception(("An error occurred while attempting to enumerate the font \"%s\".").sprintf(list[i]));
		}
	}
	for (var i = 0, internal_forloop_count = removes.count; i < internal_forloop_count; i += 1)
	{
		list.remove(removes[i]);
	}
	invalidate removes;
	delete removes;

	var prerendered_fonts_added = 0;
	for (var i = 0, internal_forloop_count = bitmapFonts.count; i < internal_forloop_count; i += 2)
	{
		var	fc	= bitmapFonts[i];
//		list.add(fc);
		var	keys	= [];
		keys.assign(bitmapFonts[i+1]);
		var has_rendered = false;
		for (var j = 0, internal_forloop_count = keys.count; j < internal_forloop_count; j += 2)
		{
			var	fh	= keys[i];
			var	st	= keys[i+1]+fontFileExt;
			tmp_layer.font.face	= fc;
			tmp_layer.font.height	= fh;
			var default_has_rendered = false;
			if(Storages.isExistentStorage(st))
			{
				tmp_layer.font.mapPrerenderedFont(st);
				default_has_rendered = global.test_font_if_renders(tmp_layer, global.isJapanese(typeof(global.kag) === "Object" ? global.kag : this.window) ? "あ" : "A", true);
				if (!default_has_rendered)
				{
					tmp_layer.font.unmapPrerenderedFont();
				}
				else
				{
					has_rendered = true;
				}
			}

			//	イタリックフォントが存在したら、それも追加
			st	= keys[i+1] + fontItalicSuffix + fontFileExt;
			var italic_has_rendered = false;
			if(Storages.isExistentStorage(st))
			{
				tmp_layer.font.italic	= true;
				tmp_layer.font.mapPrerenderedFont(st);
				italic_has_rendered = global.test_font_if_renders(tmp_layer, global.isJapanese(typeof(global.kag) === "Object" ? global.kag : this.window) ? "あ" : "A", true);
				if (!italic_has_rendered)
				{
					tmp_layer.font.unmapPrerenderedFont();
				}
				else
				{
					has_rendered = true;
					if (!default_has_rendered)
					{
						tmp_layer.font.italic = false;
						tmp_layer.font.mapPrerenderedFont(st);
					}
				}
				tmp_layer.font.italic	= false;
			}
		}
		if (has_rendered)
		{
			list.insert(prerendered_fonts_added, fc);
			global.all_bitmap_fonts.add(fc);
			prerendered_fonts_added += 1;
		}
	}
	tmp_layer.font.face	= lastface;
	tmp_layer.font.height	= lastheight;
	tmp_layer.holdAlpha = lastholdalpha;
	global.all_font_list = list;
	return list;
};

@if(0)
Layer.setFontFace	= function(face, height=font.height, italic=font.italic)
{
@if(0)
	if (typeof(global.load_prerendered_fonts) === "Object")
	{
		global.load_prerendered_fonts(sf.language);
	}
@endif
	var	fh	= Math.abs(font.height);
	var	nh	= Math.abs(height);
	fh |= 0;
	nh |= 0;
//	dm(name+": "+font.face+" !== "+face+" || "+fh+" !== "+nh+" || "+font.italic+" !== "+italic);
	if(font.face != face || fh != nh || font.italic != italic)
	{
@if(0)
		global.Layer.getFontList();
@endif
		font.height	= height;
		font.italic	= italic;
		//dm(" font.face = " + font.face + " / face = " + face);
		font.face = face if face !== void && face != "";
@if(0)
		var	loaded	= loadedBitmapFonts[font.face], st;
		if(loaded !== void && (st = loaded[nh]) !== void)
		{
			st	+= fontItalicSuffix if italic;
			st	+= fontFileExt;
			if(Storages.isExistentStorage(st))
				font.mapPrerenderedFont(st);
//			else
//				dm(name+".setFontFace: "+st+" is not found.");
		}
@endif
		return true;
	}
	return false;
};
@endif


@endif
