// MessageCharLayer - ActingMessageLayer に表示される文字を描画するレイヤー
@if(__MESSAGE_CHAR_LAYER_DEFINED__==0)
@set(__MESSAGE_CHAR_LAYER_DEFINED__=1)

var	fonts;

@set(MESSAGECHARLAYER_MEMORY_EFFICIENT=1)

class MessageCharLayer extends KAGLayer // 演出を行なうなら、AffineLayer などに変更のこと
{
	var	ea	= 4;	//	縁取り部分のサイズ

	var	drawed = 0;		//	描画されたか/描画内容
	var	lastParams = [];//	描画時のパラメータ(drawTextのみ)
	var	lastParamsTmp = [];
	var lastFontParams = [];
	var curFontParams = [];

	var	pitch;		//	前の文字との字間

	var	textWidth, textHeight;

	var	clearcolor	= 0x00000000;

	var group_set_callback = void;
	var	group_;
	var row;
	var column;
	var ruby;
	property group
	{
		setter(v)
		{
			if (v !== this.group_)
			{
//				dmt(name+".group = "+group+" → "+v);
				var old_group = this.group_;
				this.group_ = v;
//				name	= name.substr(0, 11) + "("+v+")";
				if (group_set_callback !== void)
				{
					group_set_callback(this, old_group, this.group_);
				}
			}
		}
		getter
		{
			return this.group_;
		}
	};

	var	_linkno;	//	対応するリンク

	function MessageCharLayer(win, par)
	{
		super.Layer(...);
		hitThreshold	= 256;

		this.clear();

@if(0)
		if(global.fonts == void)
		{
			if(typeof getFontList != "undefined")
				global.fonts	= getFontList();
			else
			{
				with(global.fonts = font.getList(fsfSameCharSet | fsfNoVertical))
				{
					.remove("FixedSys");
					.remove("System");
					.remove("Terminal");
				}
			}
		}
@endif
	}

	function finalize()
	{
		super.finalize();
	}

	function store()
	{
		var	dic	= %[];
		with(dic)
		{
			.name		= name;
			.ea			= ea;
			.drawed		= drawed;
			.pitch		= pitch;
			.textWidth	= textWidth;
			.textHeight	= textHeight;
			.group		= group;
			.row		= row;
			.column		= column;
			.ruby		= ruby;
			.left		= left;
			.top		= top;
			.opacity	= opacity;
			.lastParams	= [];
			.lastParams.assign(lastParams);
			.lastFontParams = [];
			.lastFontParams.assign(lastFontParams);
			.curFontParams = [];
			.curFontParams.assign(curFontParams);
		}
		return dic;
	}

	function restore(dic)
	{
		this.clear();
		with(dic)
		{
			name		= .name;
			ea			= .ea;
			drawed		= .drawed;
			pitch		= .pitch;
			textWidth	= .textWidth;
			textHeight	= .textHeight;
			group		= .group;
			row			= .row;
			column		= .column;
			ruby		= .ruby;
			opacity		= .opacity;
			lastParams.assign(.lastParams);
			lastFontParams.assign(.lastFontParams);
			curFontParams.clear();
			setFont(.curFontParams[0], .curFontParams[1], .curFontParams[2], .curFontParams[3], .curFontParams[4], .curFontParams[5], .curFontParams[6]);
			redraw();
			// Place the setPos call here because the redraw call sets position to (0,0)
			this.setPos(.left, .top);
		}
	}

	function assignImages(src)
	{
		this.clear();
		super.assignImages(...);

		with(src)
		{
			name		= .name;
			ea			= .ea;
			drawed		= .drawed;
			pitch		= .pitch;
			textWidth	= .textWidth;
			textHeight	= .textHeight;
			this.setSizeToImageSize();
			this.setPos(.left, .top);
			opacity		= .opacity;
			lastParams.assign(.lastParams);
			lastFontParams.assign(.lastFontParams);
			curFontParams.assign(.curFontParams);
		}
	}

	function setFont(face, angle, bold, italic, strikeout, underline, size)
	{
		if (size < 0)
		{
			size = -size;
		}
		if (angle == 2700 && face.length > 0 && face[0] === "@")
		{
			face = face.substring(1);
		}
		var font_changed = false;
		with(font)
		{
			if (.angle != angle)
			{
				font_changed = true;
				.angle	= angle;
			}
			font_changed = setFontFace((angle == 2700 ? "@" : "") +face, - size, bold, italic, strikeout, underline) || font_changed;
			if (font_changed)
			{
				this.curFontParams.clear();
				this.curFontParams.push(.face, .angle, .bold, .italic, .strikeout, .underline, .height, ea);
			}
		}
	}

	function hasFontChanged()
	{
		return !global.struct_is_equal(this.lastFontParams, this.curFontParams);
	}
@if(0)
	property left
	{
		setter(v)
		{
			if(left !== v)
			{
				dmt(name+".left = "+left+" → "+v);
				super.left	= v;
			}
		}
		getter	{ return super.left; }
	}
@endif
	//	縁取りなどを無視した、テキストのみの左上座標
	property textLeft
	{
		setter(v)	{ left = v - ea; }
		getter		{ return left + ea; }
	}

	property textTop
	{
		setter(v)	{ top = v - ea; }
		getter		{ return top + ea; }
	}

	function setTextPos(l, t)
	{
		setPos(l - ea, t - ea);
	}

	function resize(w, h, esc_w, esc_h)
	{
		if (esc_w !== void)
		{
			textWidth = esc_w;
		}
		else
		{
			textWidth = w;
		}
		if (esc_h !== void)
		{
			textHeight = esc_h;
		}
		else
		{
			textHeight = h;
		}
		w	+= (ea << 1);
		h	+= (ea << 1);
		clear();

@if(MESSAGECHARLAYER_MEMORY_EFFICIENT)
		if (!this.hasImage)
		{
			this.hasImage = true;
		}
@endif
		if (imageWidth != w || imageHeight != h)
		{
			setImageSize(w, h);
			setSizeToImageSize();
			fillRect(0, 0, imageWidth, imageHeight, clearcolor);
			drawed	= 1;	//	clear で fillRect するため
		}
	}

	function clear()
	{
		this.setPos(0, 0, 1, 1);
@if(MESSAGECHARLAYER_MEMORY_EFFICIENT)
		if (drawed)
		{
			this.hasImage = false;
		}
@endif
@if(!MESSAGECHARLAYER_MEMORY_EFFICIENT)
		fillRect(0, 0, imageWidth, imageHeight, clearcolor) if drawed;
@endif
		drawed	= 0;
		this.lastParams.clear();
		this.lastFontParams.clear();
	}

	function resizeByText(ch, vert, max, min)
	{
@if(MESSAGECHARLAYER_MEMORY_EFFICIENT)
		if (!this.hasImage)
		{
			this.hasImage = true;
		}
@endif
@if(0)
		var	w = font.getTextWidth(ch), h = font.getTextHeight(ch);
@endif
		var rect = font.getGlyphDrawRect(ch);
		var	w, h;
		if (typeof(rect) === "Object")
		{
			w = rect.right;
			h = rect.bottom;
		}
		var	txt_w = font.getTextWidth(ch), txt_h = font.getTextHeight(ch);
		if (txt_w >= 65536 || txt_w < 0)
		{
			txt_w = 0;
		}
		if (txt_h >= 65536 || txt_h < 0)
		{
			txt_h = 0;
		}
		if ((typeof(rect) !== "Object") || (typeof(global.all_bitmap_fonts) === "Object" && global.all_bitmap_fonts.find(font.face) !== -1))
		{
			w = txt_w;
			h = txt_h;
		}

		var	ret = 0;
		if(ch.length == 1 || max === void || min === void)
			;	// 1文字なら関係ない
		else if(vert != void)
		{
			w <-> h;	//	getTextWidth,getTextHeight は angle の影響を受けないようなので、入れ替えて対応
			if(h > max)
			{
				// 文字の重なりが小さそうなら、均等割付する
				if(((h - max) / (ch.length - 1)) < 4)
					ret	= -2;	//	均等割付
				else
					ret	= 2;	//	縮小描画
				h = max;
			}
			else if(h < min)
				h = min, ret = -2;	//	均等割付
		}
		else if(vert !== void)
		{
			if(w > max)
			{
				// 文字の重なりが小さそうなら、均等割付する
				if(((w - max) / (ch.length - 1)) < 4)
					ret	= -2;	//	均等割付
				else
					ret	= 2;	//	縮小描画
				w = max;
			}
			else if(w < min)
				w = min, ret = -1;	//	均等割付
		}
//		dm("resizeByText("+ch+", "+vert+", "+max+", "+min+"): "+w+", "+h);
		resize(w, h, txt_w, txt_h);
		return ret;
	}

	//	縮小描画
	function drawMinimize(vert, ch, color, aa, sl, sc, sw, sox, soy)
	{
//		dm("draw minimize: "+ch);
		var	tmp	= window.temporaryLayer;
		with(tmp)
		{
			var	w, h;
			.face	= dfAlpha;
			.type	= ltAlpha;
			with(.font)
			{
				.angle	= font.angle;
				.bold	= font.bold;
				tmp.setFontFace(font.face, font.height, font.bold, font.italic, font.strikeout, font.underline);
				w	= .getTextWidth(ch);
				h	= .getTextHeight(ch);
			}
			.setImageSize(w + (ea << 1), h + (ea << 1));
			.fillRect(0, 0, .imageWidth, .imageHeight, clearcolor);
			.drawText(ea + (vert ? .font.height : 0), ea, ch, color, 255, aa, sl, sc, sw, sox, soy);
			stretchCopy(0, 0, width, height, tmp, 0, 0, .imageWidth, .imageHeight);
		}
	}

	//	均等割付
	function equableLayout(vert, ch, color, aa, sl, sc, sw, sox, soy)
	{
//		dm("equableLayout("+vert+", "+ch+", "+color+", ...)");
		var	tmp	= window.temporaryLayer;
		var	spc, step;
		with(tmp)
		{
			var	w, h;
			.face	= dfAlpha;
			.type	= ltAlpha;
			with(.font)
			{
				.angle	= font.angle;
				.bold	= font.bold;
				tmp.setFontFace(font.face, font.height, font.bold, font.italic, font.strikeout, font.underline);
				w	= .getTextWidth(ch);
				h	= .getTextHeight(ch);
			}
			if(vert)
			{
				w <-> h;
				.setImageSize(.font.getTextWidth(ch[0]) + (ea << 1), int(.font.getTextHeight(ch[0]) * 1.5) + (ea << 1));
				spc = step = (textHeight - h) / (ch.length - 1);
			}
			else
			{
				.setImageSize(int(.font.getTextWidth(ch[0]) * 1.5) + (ea << 1), .font.getTextHeight(ch[0]) + (ea << 1));
				spc = step = (textWidth - w) / (ch.length - 1);
			}
			var	l = 0, t = 0;
			for (var i = 0, internal_forloop_count = ch.length; i < internal_forloop_count; i += 1)
			{
//				dm(ch[i]+": "+l+", "+t+", "+spc+", "+step);
				.fillRect(0, 0, .imageWidth, .imageHeight, 0x00000000);
				.drawText(ea + (vert ? .font.height : 0), ea, ch[i], color, 255, aa, sl, sc, sw, sox, soy);
				operateRect(l, t, tmp, 0, 0, .imageWidth, .imageHeight);
				if(vert)
					t	+= .font.getTextHeight(ch[i]) + int(spc);
				else
					l	+= .font.getTextWidth(ch[i]) + int(spc);
				spc	+= step - int(spc);
			}
		}
	}

	function superDrawText(vert, text, color, aa=true, shadowlevel=0, shadowcolor=0x000000, shadowwidth=0, shadowofsx=0, shadowofsy=0)
	{
		if (imageWidth === 0 || imageHeight === 0)
		{
			return;
		}
@if(MESSAGECHARLAYER_MEMORY_EFFICIENT)
		if (!this.hasImage)
		{
			this.hasImage = true;
		}
@endif
		super.drawText(ea + (vert ? font.height : 0), ea, text, color, 255, aa, shadowlevel, shadowcolor, shadowwidth, shadowofsx, shadowofsy);
	}

	function drawText(ch, color, aa, vert, max, min)
	{
		var lastParams = this.lastParams;
		var lastParamsTmp = this.lastParamsTmp;
		lastParamsTmp.clear();
		lastParamsTmp.push(...);
		if (this.drawed === 1 && lastParams.count === 6)
		{
			if (!hasFontChanged() && global.struct_is_equal(lastParams, lastParamsTmp))
			{
				return;
			}
		}
@if(MESSAGECHARLAYER_MEMORY_EFFICIENT)
		if (!this.hasImage)
		{
			this.hasImage = true;
		}
@endif
		var	ret	= resizeByText(ch, vert, max, min);
		if(ret > 0)
			drawMinimize(vert, ch, color, aa);	//	縮小描画
		else if(ret < 0)
			equableLayout(vert, ch, color, aa);	//	均等割付
		else
			superDrawText(vert, ch, color, aa);
		drawed	= 1;
		lastParams.assign(lastParamsTmp);
		lastFontParams.assign(this.curFontParams);
	}

	function drawTextWithShadow(ch, color, aa, shadowcolor, shadowoffsetx, shadowoffsety, vert, max, min)
	{
		var lastParams = this.lastParams;
		var lastParamsTmp = this.lastParamsTmp;
		lastParamsTmp.clear();
		lastParamsTmp.push(...);
		if (this.drawed === 2 && lastParams.count === 9)
		{
			if (!hasFontChanged() && global.struct_is_equal(lastParams, lastParamsTmp))
			{
				return;
			}
		}
@if(MESSAGECHARLAYER_MEMORY_EFFICIENT)
		if (!this.hasImage)
		{
			this.hasImage = true;
		}
@endif
		var	ret	= resizeByText(ch, vert, max, min);
		if(ret > 0)
			drawMinimize(vert, ch, color, aa, shadowcolor, 0, shadowoffsetx, shadowoffsety);
		else if(ret < 0)
			equableLayout(vert, ch, color, aa, shadowcolor, 0, shadowoffsetx, shadowoffsety);
		else
			superDrawText(vert, ch, color, aa, 255, shadowcolor, 0, shadowoffsetx, shadowoffsety);
		drawed	= 2;
		lastParams.assign(lastParamsTmp);
		lastFontParams.assign(this.curFontParams);
	}

	function drawTextWithEdge(ch, color, aa, edgeemphasis, edgecolor, edgeextent, vert, max, min)
	{
		var lastParams = this.lastParams;
		var lastParamsTmp = this.lastParamsTmp;
		lastParamsTmp.clear();
		lastParamsTmp.push(...);
		if (this.drawed === 3 && lastParams.count === 9)
		{
			if (!hasFontChanged() && global.struct_is_equal(lastParams, lastParamsTmp))
			{
				return;
			}
		}
@if(MESSAGECHARLAYER_MEMORY_EFFICIENT)
		if (!this.hasImage)
		{
			this.hasImage = true;
		}
@endif
		var	ret	= resizeByText(ch, vert, max, min);
		if(ret > 0)
			drawMinimize(vert, ch, color, aa, edgeemphasis, edgecolor, edgeextent, 0, 0);
		else if(ret < 0)
			equableLayout(vert, ch, color, aa, edgeemphasis, edgecolor, edgeextent, 0, 0);
		else
			superDrawText(vert, ch, color, aa, edgeemphasis, edgecolor, edgeextent, 0, 0);
		drawed	= 3;
		lastParams.assign(lastParamsTmp);
		lastFontParams.assign(this.curFontParams);
	}

	function getGraph(storage, key)
	{
		var lay = window.temporaryLayer;

		lay.type = ltTransparent;
		lay.face = dfAuto;
		lay.loadImages(storage, key); // 画像読み込み

		return lay;
	}

	function drawGraph(storage, key, color=void, withresize=true)
	{
		var lastParams = this.lastParams;
		var lastParamsTmp = this.lastParamsTmp;
		lastParamsTmp.clear();
		lastParamsTmp.push(storage, key, color, withresize);
		if (this.drawed === 4 && lastParams.count === 4)
		{
			if (global.struct_is_equal(lastParams, lastParamsTmp))
			{
				return;
			}
		}
		var	layer	= getGraph(storage, key);
		var	iw = layer.imageWidth, ih = layer.imageHeight;
		if (withresize)
		{
			resize(iw, ih);
		}
		else
		{
@if(MESSAGECHARLAYER_MEMORY_EFFICIENT)
			if (!this.hasImage)
			{
				this.hasImage = true;
			}
@endif
		}
		if(color !== void)
		{
			layer.face	= dfOpaque;
			layer.holdAlpha	= true;
			layer.fillRect(0, 0, iw, ih, color);
		}
		operateRect(ea, ea, layer, 0, 0, iw, ih);
		drawed	= 4;
		lastParams.assign(lastParamsTmp);
		lastFontParams.clear();
	}

	function drawGraphWithShadow(storage, key, color, shadowcolor, shadowoffsetx, shadowoffsety)
	{
		var lastParams = this.lastParams;
		var lastParamsTmp = this.lastParamsTmp;
		lastParamsTmp.clear();
		lastParamsTmp.push(storage, key, color, shadowcolor, shadowoffsetx, shadowoffsety);
		if (this.drawed === 5 && lastParams.count === 6)
		{
			if (global.struct_is_equal(lastParams, lastParamsTmp))
			{
				return;
			}
		}
@if(MESSAGECHARLAYER_MEMORY_EFFICIENT)
		if (!this.hasImage)
		{
			this.hasImage = true;
		}
@endif
		var	layer	= getGraph(storage, key);
		var	iw = layer.imageWidth, ih = layer.imageHeight;
		resize(iw, ih);
		layer.face	= dfOpaque;
		layer.holdAlpha	= true;
		layer.fillRect(0, 0, iw, ih, shadowcolor);
		operateRect(ea + shadowoffsetx, ea + shadowoffsety, layer, 0, 0, iw, ih);

		drawGraph(layer, false);
		drawed	= 5;
		lastParams.assign(lastParamsTmp);
		lastFontParams.clear();
	}

	function drawGraphWithEdge(storage, key, color, edgeemphasis, edgecolor, edgeextent)
	{
		var lastParams = this.lastParams;
		var lastParamsTmp = this.lastParamsTmp;
		lastParamsTmp.clear();
		lastParamsTmp.push(...);
		if (this.drawed === 6 && lastParams.count === 6)
		{
			if (global.struct_is_equal(lastParams, lastParamsTmp))
			{
				return;
			}
		}
@if(MESSAGECHARLAYER_MEMORY_EFFICIENT)
		if (!this.hasImage)
		{
			this.hasImage = true;
		}
@endif
		var	layer	= getGraph(storage, key);
		var	iw = layer.imageWidth, ih = layer.imageHeight;
		resize(iw, ih);
		layer.face	= dfOpaque;
		layer.holdAlpha	= true;
		layer.fillRect(0, 0, iw, ih, edgecolor);

		var	tmp	= new global.Layer(window, this);
		tmp.setImageSize(iw + edgeextent * 2, ih + edgeextent * 2);
		tmp.fillRect(0, 0, tmp.imageWidth, tmp.imageHeight, 0x00000000);
		tmp.operateRect(edgeextent, edgeextent, layer, 0, 0, iw, ih);
		tmp.doBoxBlur(edgeextent, edgeextent);

		var	cnt	= int(edgeemphasis / 256);
		for (var i = 0, internal_forloop_count = cnt; i < internal_forloop_count; i += 1)
			operateRect(ea - edgeextent, ea - edgeextent, tmp, 0, 0, tmp.imageWidth, tmp.imageHeight);
		operateRect(ea - edgeextent, ea - edgeextent, tmp, 0, 0, tmp.imageWidth, tmp.imageHeight,, edgeemphasis - cnt * 256);
		invalidate tmp;

		drawGraph(storage, key, color, false);
		drawed	= 6;
		lastParams.assign(lastParamsTmp);
		lastFontParams.clear();
	}

	//	直前と同じ内容で描画
	function redraw()
	{
		var drawed = this.drawed;
		this.drawed = 0;
		switch(drawed)
		{
		case 0:	break;	//	描画していない
		case 1:	drawText(lastParams*);				break;
		case 2:	drawTextWithShadow(lastParams*);	break;
		case 3:	drawTextWithEdge(lastParams*);		break;
		case 4:	drawGraph(lastParams*);				break;
		case 5:	drawGraphWithShadow(lastParams*);	break;
		case 6:	drawGraphWithEdge(lastParams*);		break;
		}
	}

	function initBShutter()
	{
		lastTop	= top;
		lastHeight	= height;
	}

	var	lastTop, lastHeight;
	property BShutter
	{
		setter(v)
		{
			top		= lastTop + v;
			height	= lastHeight - v;
			imageTop= -v;
		}
		getter	{ return -imageTop; }
	}

	//	描画されている文字のフォントを変更する
	function changeFont(face)
	{
@if(1)
		if(face === void)
		{
			return;
		}
@endif
@if(0)
		face	= global.fonts[int(global.fonts.count * Math.random())] if face === void;
@endif
		setFontFace((font.angle == 2700 ? "@" : "") + face);

		redraw();	//	再描画
	}

	property changefont
	{
		setter(v)	{ changeFont(); }
		getter		{ return false; }
	}

	property linkno
	{
		setter(v)
		{
			if(linkno !== v)
			{
				_linkno	= v;
				if(v >= 0)
					hitThreshold	= 0;
				else
					hitThreshold	= 256;
			}
		}
		getter	{ return _linkno; }
	}

	function onMouseEnter()
	{
		parent.onEnterLink(linkno) if linkno >= 0;
	}

	function onMouseLeave()
	{
		parent.onLeaveLink(linkno) if linkno >= 0;
	}

	function onMouseDown(x, y, button, shift)
	{
		parent.onPressLink(linkno) if linkno >= 0;
	}
}

@endif
